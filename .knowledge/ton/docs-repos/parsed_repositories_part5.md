# GitHub Docs Parser - Part 5

`max_factor` =  [`max_stake_factor`](https://tonviewer.com/config#17) / [`validators_elected_for`](https://tonviewer.com/config#15)

### (Упрощенный) алгоритм выбора

Этот алгоритм, запущенный [смарт-контрактом Elector](/v3/documentation/smart-contracts/contracts-specs/governance#elector), выбирает лучших кандидатов-валидаторов на основе их стейка. Вот как это работает:

1. **Начальная выборка**: избиратели рассматривают всех кандидатов, которые имеют стейк больше установленной минимальной суммы (300 тыс., как указано в [конфигурации](https://tonviewer.com/config#17)).

2. **Сортировка кандидатов**: Затем эти кандидаты располагаются от самого высокого к самому низкому в зависимости от их стейка.

3. **Уточнение**:
   - Если количество кандидатов превышает максимально допустимое количество валидаторов ([см. конфигурацию](https://tonviewer.com/config#16)), то исключаются кандидаты с самым низким стейком.
   - Затем Elector оценивает каждую потенциальную группу кандидатов, начиная с самой большой группы и переходя к меньшим:
      - Он проверяет лучших кандидатов в упорядоченном списке, увеличивая число на единицу.
      - Для каждого кандидата Elector вычисляет его "эффективный стейк". Если стейк кандидата значительно выше минимального, он корректируется (например, если кто-то поставил 310 тыс., а минимум составляет 100 тыс., но есть правило, ограничивающее минимум в три раза, его эффективный стейк считается равной 300 тыс.).
      - Он суммирует эффективные стейки всех кандидатов в этой группе.

4. **Окончательный отбор**: группа кандидатов с наибольшим общим эффективным стейком выбирается Elector в качестве валидаторов.

#### Алгоритм выбора валидатора

На основе доступных стейков потенциальных валидаторов определяются оптимальные значения минимального и максимального стейка с целью максимизации величины общего стейка:

1. Elector выбирает всех кандидатов, у которых сумма стейка превышает минимальную ([300 тысяч в конфигурации](https://tonviewer.com/config#17)).
2. Elector сортирует их в *порядке убывания* стейка.
3. Если участников больше, чем [максимальное число](https://tonviewer.com/config#16) валидаторов, Elector удаляет последнюю часть списка. Затем Elector делает следующее:

   - Для каждого цикла **i** от *1 до N* (оставшееся число участников) он берет первые **i** заявок из отсортированного списка.
   - Он вычисляет эффективный стейк, учитывая `max_factor`. То есть, если человек вложил 310 тыс., но с `max_factor` 3, а минимальный стейк в списке составляет 100 тыс. Toncoin, то эффективный стейк будет минимум (310 тыс., 3\*100 тыс.) = 300 тыс. Один узел валидатора может использовать до 600 тыс. TON (в этом примере) в двух раундах (половина в нечетных раундах, половина в четных раундах). Чтобы увеличить стейк, необходимо настроить несколько узлов валидатора.
   - Он вычисляет общий эффективнуый стейк всех **i** участников.

Как только Elector находит такой **i**, где общий эффективный стейк максимальный, мы объявляем этих **i** участников валидаторами.

## Положительные вознаграждения

Как и во всех блокчейн сетях, каждая транзакция в TON требует платы за вычисления, называемый [газ](https://blog.ton.org/what-is-blockchain), который используется для хранения данных в сети и обработки транзакций on-chain. В TON эти платы накапливаются в контракте Elector в пуле вознаграждений.

Сеть также субсидирует создание блоков, добавляя субсидию в пул вознаграждений, равную 1,7 TON за каждый блок мастерчейна и 1 TON за каждый блок бейсчейна (параметры сети `Config14:masterchain_block_fee` и `Config14:basechain_block_fee`). Обратите внимание, что при разделении бейсчейна на несколько шардчейнов субсидия на блок шардчейна делится соответствующим образом. Этот процесс позволяет поддерживать субсидию за единицу времени практически постоянной.

:::info
В июне 2023 года был представлен [механизм дефляционного сжигания](https://blog.ton.org/ton-holders-and-validators-vote-in-favor-of-implementing-the-toncoin-real-time-burn-mechanism). С помощью этого механизма часть TON, сгенерированного сетью, сжигается вместо того, чтобы быть выделенной в пул вознаграждений.
:::

После раунда цикла валидации, длящегося 65536 секунд или ~18 часов (сетевой параметр `Config15:validators_elected_for`), каждый из проверяющих не сразу освобождает TON, а удерживает его в течение дополнительных 32768 секунд или ~9 часов (сетевой параметр `Config15:stake_held_for`. В течение этого периода снимается штраф (механизм наказания для неисправных валидаторов) с валидатора. После освобождения средств валидаторы могут выводить свои депозиты вместе с долей вознаграждений пула, пропорционально их весу голосования.

По состоянию на апрель 2023 года общий пул вознаграждений за раунд консенсуса для всех валидаторов в сети составляет приблизительно 40 000 TON, при этом среднее вознаграждение на валидатора составляет ~ 120 TON (максимальная разница между весом голоса и накопленными вознаграждениями составляет ~ 3 TON).

Учитывая общий запас Toncoin (5 миллиардов TON), уровень инфляции составляет приблизительно 0,3–0,6% в год.

Однако этот уровень инфляции не всегда постоянен и может отклоняться в зависимости от текущего состояния сети. В конечном итоге он будет иметь тенденцию к дефляции после активации механизма дефляции и роста использования сети.

:::info
Узнайте текущую статистику блокчейна TON [здесь](https://tontech.io/stats/).
:::

## Отрицательные стимулы

В блокчейне TON обычно есть два способа наказания валидаторов за неправильную работу: бездействие и злонамеренное ненадлежащее поведение; оба из них запрещены и могут привести к штрафу (в процессе, называемом слэшингом) за их действия.

Если валидатор не участвует в создании блоков и подписании транзакций в течение значительного периода времени во время раунда валидации, он потенциально оштрафован с использованием параметра *Standard fine*. По состоянию на апрель 2023 года накопленный стандартный штраф составляет 101 TON (сетевой параметр `ConfigParam40:MisbehaviorPunishmentConfig`).

В TON штрафы за слэшинг (штрафы, налагаемые валидаторам) позволяют любому участнику сети подать жалобу, если он считает, что валидатор ведет себя ненадлежащим образом. В ходе этого процесса участник, подающий жалобу, должен приложить криптографические доказательства ненадлежащего поведения для подачи Elector. В течение периода разрешения споров `stake_held_for` все валидаторы, работающие в сети, проверяют обоснованность жалоб и голосуют, будут ли они коллективно рассматривать жалобу (определяя при этом законность доказательств ненадлежащего поведения и распределение штрафов).

При достижении 66% одобрения валидатора (измеряемого равным весом голосования) с него списывается сумма штрафа, которая сокращает его общий стейк. Процесс валидации для штрафования и разрешения жалоб обычно проводится автоматически с помощью MyTonCtrl.

## Децентрализованная система штрафов

:::info
Следующая система штрафов плохо работающих валидаторов полностью работоспособна с 9 сентября 2024 г.
:::

### Определение плохой работы

TON поставляется с утилитой [lite-client](https://github.com/newton-blockchain/ton/tree/master/lite-client). В lite-client есть команда `checkloadall`.
Эта команда анализирует, сколько блоков должен был обработать валидатор, и сколько он фактически обработал за определенный период времени.

Если валидатор обработал менее 90% от ожидаемого количества блоков во время раунда валидации, он считается плохо работающим и должен быть оштрафован.
:::info
Узнайте больше о техническом описании процесса [здесь](https://github.com/ton-blockchain/TIPs/issues/13#issuecomment-786627474)
:::

### Рабочий процесс подачи жалоб

- Любой может подать жалобу и получить вознаграждение за правильную жалобу.
- Проверка жалобы поддерживается валидаторами и полностью децентрализована.

#### Подать жалобу

После каждого раунда валидации (~18 часов) стейки валидаторов, участвовавших в этом раунде, остаются на смарт-контракте Elector еще ~9 часов.
В это время любой может отправить жалобу на валидатора, который плохо выступил в указанном раунде. Это происходит on-chain на смарт-контракте Elector.

#### Проверка жалобы

После каждого раунда проверки валидаторы получают список жалоб от смарт-контракта Elector и перепроверяют их, вызывая `checkloadall`.
В случае подтверждения жалобы они голосуют on-chain в пользу этой жалобы.

Эти действия встроены в `mytonctrl` и происходят автоматически.
Если жалоба набирает 66% голосов валидаторов (по их весу), штраф снимается со стейка валидатора.
Никто не может единолично оштрафовать кого-либо.

[@tonstatus_notifications](https://t.me/tonstatus_notifications) - список оштрафованных валидаторов в каждом раунде.

### Штраф

Размер штрафа фиксирован и равен 101 TON (сетевой параметр `ConfigParam40:MisbehaviourPunishmentConfig`), что примерно равно доходу валидатора за раунд.

Размер штрафа может меняться, поскольку аудитория и количество транзакций в TON быстро растут, и крайне важно, чтобы качество работы было на высоте.

### Распределение штрафа

Штраф распределяется между валидаторами за вычетом сетевых расходов и небольшого вознаграждения (~8 TON) первому жалобщику, который отправил правильную жалобу в Elector.

### Руководство для валидатора

Чтобы предотвратить штраф вашего узла валидатора, рекомендуется убедиться, что оборудование, мониторинг и операции валидатора настроены правильно.
Убедитесь, что вы соблюдаете [руководства по обслуживанию валидатора](/v3/guidelines/nodes/running-nodes/validator-node#maintain-guidelines).
Если вы не хотите этого делать, рассмотрите возможность использования услуг стейкинга https://ton.org/stake.

## См. также

- [Запуск валидатора](/v3/guidelines/nodes/running-nodes/validator-node)
- [Транзакционные сборы](/v3/documentation/smart-contracts/transaction-fees/fees)
- [Что такое блокчейн? Что такое смарт-контракт? Что такое газ?](https://blog.ton.org/what-is-blockchain)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/blockchain-configs.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/blockchain-configs.md
================================================
# Параметры конфигурации

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::info
Читайте текущие значения через [tonviewer](https://tonviewer.com/config)
:::

## 👋 Введение

На этой странице вы можете найти описание параметров конфигурации, используемых в блокчейне TON.
TON имеет сложную конфигурацию со множеством технических параметров: некоторые используются самим блокчейном, некоторые — экосистемой. Однако лишь немногие понимают, что означают эти параметры. Эта статья необходима для предоставления пользователям простого способа понимания параметров и их назначения.

## 💡 Предварительные условия

Этот материал предназначен для чтения вместе со списком параметров.
Вы можете просмотреть значения параметров в [текущей конфигурации](https://explorer.toncoin.org/config), а способ их записи в [ячейки](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage) описан в файле [block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb) в формате [TL-B](/v3/documentation/data-formats/tlb/tl-b-language).

:::info
Двоичное кодирование в конце параметра блокчейна TON представляет собой сериализованное двоичное представление его конфигурации, что позволяет эффективно хранить или передавать конфигурацию. Точные детали сериализации зависят от конкретной схемы кодирования, используемой блокчейном TON.
:::

## 🚀 Давайте начнем!

Все параметры по порядку, и вы не заблудитесь. Для удобства используйте правую боковую панель для быстрой навигации.

## Param 0

Этот параметр — адрес специального смарт-контракта, в котором хранится конфигурация блокчейна. Конфигурация хранится в контракте для упрощения ее загрузки и изменения во время голосования валидаторов.

:::info
В параметре конфигурации записывается только хэш-часть адреса, так как контракт всегда находится в [мастерчейне](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#masterchain-blockchain-of-blockchains) (workchain -1). Поэтому полный адрес контракта будет записан как `-1:<value of the configuration parameter>`.
:::

## Param 1

Этот параметр — адрес смарт-контракта [Elector](/v3/documentation/smart-contracts/contracts-specs/governance#elector), отвечающего за назначение валидаторов, распределение вознаграждений и голосование по изменениям параметров блокчейна.

## Param 2

Этот параметр представляет собой адрес Системы, от имени которой выпускаются новые TON и отправляются в качестве вознаграждения за проверку блокчейна.

:::info
Если параметр 2 отсутствует, вместо него используется параметр 0 (вновь выпускаемые TON поступают из смарт-контракта конфигурации).
:::

## Param 3

Этот параметр — адрес сборщика комиссий за транзакции.

:::info
Если параметр 3 отсутствует (как это было на момент написания), комиссии за транзакции отправляются в смарт-контракт Elector (параметр 1).
:::

## Param 4

Этот параметр — адрес корневого DNS-контракта сети TON.

:::info
Более подробную информацию можно найти в статье [TON DNS & Domains](/v3/guidelines/web3/ton-dns/dns) и в более подробном оригинальном описании [здесь](https://github.com/ton-blockchain/TEPs/blob/master/text/0081-dns-standard.md).
Этот контракт не отвечает за продажу доменов .ton.
:::

## Param 6

Этот параметр отвечает за комиссии за выпуск новых валют.

:::info
Currently, minting additional currency is not implemented and does not work. The implementation and launch of the minter are planned.

Подробнее о проблемах и перспективах можно узнать в [соответствующей статье](/v3/documentation/infra/minter-flow).
:::

## Param 7

Этот параметр хранит объем каждой из дополнительных валют в обращении. Данные хранятся в виде [словаря](/v3/documentation/data-formats/tlb/tl-b-types#hashmap-parsing-example) (двоичное дерево; вероятно, во время разработки TON эта структура была ошибочно названа hashmap) `extracurrency_id -> amount`, сумма представлена ​​как `VarUint 32` - целое число от `0` до `2^248`.

## Param 8

Этот параметр указывает версию сети и дополнительные возможности, поддерживаемые валидаторами.

:::info
Валидаторы - это узлы в сети блокчейна, которые отвечают за создание новых блоков и проверку транзакций.
:::

- `version`: Это поле указывает версию.

- `capabilities`: Это поле представляет собой набор флагов, которые используются для указания наличия или отсутствия определенных функций или возможностей.

Таким образом, при обновлении сети валидаторы будут голосовать за изменение параметра 8. Таким образом, сеть TON может быть обновлена ​​без простоев.

## Param 9

Этот параметр содержит список (двоичное дерево) обязательных параметров. Он гарантирует, что определенные параметры конфигурации всегда присутствуют и не могут быть удалены предложением об изменении конфигурации, пока не изменится параметр 9.

## Param 10

Этот параметр представляет собой список (двоичное дерево) критических параметров TON, изменение которых существенно влияет на сеть, поэтому проводятся дополнительные раунды голосования.

## Param 11

Этот параметр указывает, при каких условиях принимаются предложения об изменении конфигурации TON.

- `min_tot_rounds` - минимальное количество раундов до того, как предложение может быть применено
- `max_tot_rounds` - максимальное количество раундов, по достижении которого предложение будет автоматически отклонено
- `min_wins` - необходимое количество побед (3/4 валидаторов по сумме залога должны проголосовать "за")
- `max_losses` - максимальное количество проигрышей, по достижении которого предложение будет автоматически отклонено
- `min_store_sec` и `max_store_sec` определяют возможный временной интервал, в течение которого предложение будет храниться
- `bit_price` и `cell_price` указывают цену хранения одного бита или одной ячейки предложения

## Param 12

Этот параметр представляет собой конфигурацию воркчейна в блокчейне TON. Воркчейны в блокчейне TON спроектированы как независимые блокчейны, которые могут работать параллельно, что позволяет TON масштабировать и обрабатывать очень большое количество транзакций и смарт-контрактов.

## Параметры конфигурации воркчейна

- `enabled_since`: метка времени UNIX момента включения этого воркчейна;

- `actual_min_split`: минимальная глубина разделения (шардинга) этого воркчейна, поддерживаемая валидаторами;

- `min_split`: минимальная глубина разделения этого воркчейна, задаваемая конфигурацией;

- `max_split`: максимальная глубина разделения этого воркчейна;

- `basic`: логический флаг (1 для true, 0 для false), указывающий, является ли этот воркчейн базовым (обрабатывает монеты TON, смарт-контракты на основе виртуальной машины TON);

- `active`: логический флаг, указывающий, активен ли этот воркчейн в данный момент;

- `accept_msgs`: логический флаг, указывающий, принимает ли этот воркчейн сообщения в данный момент;

- `flags`: дополнительные флаги для воркчейна (зарезервировано, в настоящее время всегда 0);

- `zerostate_root_hash` и `zerostate_file_hash`: хеши первого блока воркчейна;

- `version`: версия воркчейна;

- `format`: формат воркчейна, включающий vm_version и vm_mode — используемую там виртуальную машину.

## Param 13

Этот параметр определяет стоимость подачи жалоб на некорректную работу валидаторов в контракте [Elector](/v3/documentation/smart-contracts/contracts-specs/governance#elector).

## Param 14

Этот параметр представляет собой вознаграждение за создание блока в блокчейне TON. Nanogram — это nanoTON, таким образом, вознаграждение за создание блока в мастерчейне равно 1,7 TON, а в основном воркчейне — 1,0 TON (при этом в случае разделения воркччейна вознаграждение за блок также разделяется: если в воркчейне есть два шардчейна, то вознаграждение за блок шарда составит 0,5 TON).

## Param 15

Этот параметр содержит длительность различных этапов выборов и работы валидаторов в блокчейне TON.

Для каждого периода валидации существует `election_id`, равный времени в формате UNIX на момент начала валидации.
Вы можете получить текущий `election_id` (если выборы продолжаются) или прошлый, вызвав соответствующие get-методы контракта Elector `active_election_id` и `past_election_ids`.

## Параметры конфигурации воркчейна

- `validators_elected_for`: количество секунд, в течение которых выбранный набор валидаторов выполняет свою роль (один раунд).

- `elections_start_before`: за сколько секунд до окончания текущего раунда начнется процесс выборов на следующий период.

- `elections_end_before`: за сколько секунд до окончания текущего раунда будут выбраны валидаторы на следующий раунд.

- `stake_held_for`: период, в течение которого удерживается стейк валидатора (для обработки жалоб) после окончания раунда.

:::info
Каждое значение в аргументах определяется типом данных `uint32`.
:::

### Примеры

В блокчейне TON принято условно делить периоды валидации на четные и нечетные. Эти раунды следуют друг за другом. Поскольку голосование за следующий раунд происходит во время предыдущего, валидатору необходимо разделить средства на два пула, чтобы иметь возможность участвовать в обоих раундах.

#### Основная сеть

Текущие значения:

```python
constants = {
    'validators_elected_for': 65536,  # 18.2 hours
    'elections_start_before': 32768,  # 9.1 hours
    'elections_end_before': 8192,     # 2.2 hours
    'stake_held_for': 32768           # 9.1 hours
}
```

Схема:

![image](/img/docs/blockchain-configs/config15-mainnet.png)

#### Как рассчитать периоды?

Пусть `election_id = validation_start = 1600032768`. Тогда:

```python
election_start = election_id - constants['elections_start_before'] = 1600032768 - 32768 = 1600000000
election_end = delay_start = election_id - constants['elections_end_before'] = 1600032768 - 8192 = 1600024576
hold_start = validation_end = election_id + constants['validators_elected_for'] = 1600032768 + 65536 = 1600098304
hold_end = hold_start + constants['stake_held_for'] = 1600098304 + 32768 = 1600131072
```

Таким образом, на данный момент длина одного раунда одной четности составляет `1600131072 - 1600000000 = 131072 секунд = 36,40888... часов`

#### Тестовая сеть

##### Текущие значения:

```python
constants = {
    'validators_elected_for': 7200,  # 2 hours
    'elections_start_before': 2400,  # 40 minutes
    'elections_end_before': 180,     # 3 minutes
    'stake_held_for': 900            # 15 minutes
}
```

##### Схема

![image](/img/docs/blockchain-configs/config15-testnet.png)

###### Как рассчитать периоды?

Пусть `election_id = validation_start = 160002400`. Тогда:

```python
election_start = election_id - constants['elections_start_before'] = 160002400 - 2400 = 1600000000
election_end = delay_start = election_id - constants['elections_end_before'] = 160002400 - 180 = 160002220
hold_start = validation_end = election_id + constants['validators_elected_for'] = 160002400 + 7200 = 160009600
hold_end = hold_start + constants['stake_held_for'] = 160009600 + 900 = 160010500
```

Таким образом, на данный момент длина одного раунда одной четности составляет `160010500 - 1600000000 = 10500 секунд = 175 минут = 2,91666... ​​часов`

## Param 16

Этот параметр представляет собой ограничение на количество валидаторов в блокчейне TON. Он напрямую используется смарт-контрактом Elector.

### Параметры настройки количества валидаторов для выборов:

- `max_validators`: этот параметр представляет собой максимальное количество валидаторов, которые могут участвовать в работе сети в любой момент времени.

- `max_main_validators`: этот параметр представляет собой максимальное количество валидаторов мастерчейна.

- `min_validators`: этот параметр представляет собой минимальное количество валидаторов, которые должны поддерживать работу сети.

1. Максимальное количество валидаторов больше или равно максимальному количеству валидаторов мастерчейна.
2. Максимальное количество валидаторов мастерчейна должно быть больше или равно минимальному количеству валидаторов.
3. Минимальное количество валидаторов должно быть не менее 1.

## Param 17

Этот параметр представляет конфигурацию параметров стейка в блокчейне TON. Во многих системах блокчейна, особенно тех, которые используют алгоритм консенсуса Proof-of-Stake или Delegated Proof-of-Stake, владельцы криптовалюты, встроенные в сеть, могут "стейкать" свои токены, чтобы стать валидаторами и получать вознаграждения.

## Параметры конфигурации:

- `min_stake`: этот параметр представляет минимальное количество TON, которое заинтересованная сторона должна поставить в стейк для участия в процессе валидации.

- `max_stake`: этот параметр представляет максимальное количество TON, которое заинтересованная сторона может передать в стейк.

- `min_total_stake`: этот параметр представляет минимальное общее количество TON, которое должно удерживаться выбранным набором валидаторов.

- `max_stake_factor`: этот параметр является множителем, указывающим, во сколько раз максимально эффективный стейк (залог) может превышать минимальный стейк, отправленный любым другим валидатором.

:::info
Каждое значение в аргументах определяется типом данных `uint32`.
:::

## Param 18

Этот параметр представляет собой конфигурацию для определения цен на хранение данных в блокчейне TON. Это служит мерой предотвращения спама и поощряет обслуживание сети.

### Словарь параметров платы за хранение:

- `utime_since`: этот параметр предоставляет начальную временную метку Unix, с которой применяются указанные цены.

- `bit_price_ps` и `cell_price_ps`: эти параметры представляют цены на хранение одного бита или одной ячейки информации в основных воркчейнах блокчейна TON на 65536 секунд

- `mc_bit_price_ps` и `mc_cell_price_ps`: эти параметры представляют цены на вычислительные ресурсы, в частности, в мастерчейне TON на 65536 секунд

:::info

`utime_since` принимает значения в типе данных `uint32`.

Остальные принимают значения в типе данных `uint64`.
:::

## Param 20 и 21

Эти параметры определяют стоимость вычислений в сети TON. Сложность любого вычисления оценивается в единицах газа.

- `flat_gas_limit` и `flat_gas_price`: Определенное начальное количество газа предоставляется по цене `flat_gas_price` (для компенсации затрат на запуск виртуальной машины TON).

- `gas_price`: Этот параметр отражает цену газа в сети в nanoton за 65536 единиц газа.

- `gas_limit`: Этот параметр представляет максимальное количество газа, которое может быть потреблено за одну транзакцию.

- `special_gas_limit`: Этот параметр представляет ограничение на количество газа, которое может быть потреблено за одну транзакцию специального (системного) контракта.

- `gas_credit`: Этот параметр представляет кредит в единицах газа, который предоставляется транзакциям для проверки внешнего сообщения.

- `block_gas_limit`: Этот параметр представляет максимальное количество газа, которое может быть использовано в пределах одного блока.

- `freeze_due_limit` и `delete_due_limit`: лимиты накопленных комиссий за хранение (в nanoTON), при достижении которых контракт замораживается и соответственно удаляется.

:::info
Подробнее о "gas_credit" и других параметрах в разделе с внешними сообщениями [здесь](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects#external-messages).
:::

## Param 22 и 23

Эти параметры устанавливают ограничения на блок, по достижении которых блок завершается, а обратный вызов оставшихся сообщений (если таковые имеются) переносится в следующий блок.

### Параметры конфигурации:

- `bytes`: Этот раздел устанавливает ограничения на размер блока в байтах.

- `underload`: Недогрузка — это состояние, когда шард понимает, что нагрузки нет, и склоняется к слиянию, если соседний шард готов.

- `soft_limit`: Мягкий предел — при достижении этого предела внутренние сообщения перестают обрабатываться.

- `hard_limit`: Жесткий предел — это абсолютный максимальный размер.

- `gas`: Этот раздел устанавливает ограничения на количество газа, которое может потреблять блок. Газ в контексте блокчейна — это показатель вычислительной работы. Ограничения на недогрузку, мягкий и жесткий предел работают так же, как и для размера в байтах.

- `lt_delta`: Этот раздел устанавливает ограничения на разницу в логическом времени между первой и последней транзакцией. Логическое время — это концепция, используемая в блокчейне TON для упорядочивания событий. Ограничения на недогрузку, мягкий и жесткий лимит работают так же, как и для размера в байтах и ​​газе.

:::info
В случае недостаточной нагрузки на шард и, соответственно, желания объединиться с соседом, `soft_limit` определяет состояние, выше которого внутренние сообщения перестают обрабатываться, но внешние продолжаются. Внешние сообщения обрабатываются до тех пор, пока не будет достигнут лимит, равный `(soft_limit + hard_limit)/2`.
:::

## Param 24 и 25

Параметр 24 представляет собой конфигурацию стоимости отправки сообщений в мастерчейне блокчейна TON.

Параметр 25 представляет собой конфигурацию стоимости отправки сообщений во всех остальных случаях.

### Параметры конфигурации, определяющие стоимость пересылки:

- `lump_price`: этот параметр означает базовую цену пересылки сообщения независимо от его размера или сложности.

- `bit_price`: этот параметр представляет стоимость за бит пересылки сообщения.

- `cell_price`: этот параметр отражает стоимость пересылки сообщения зя ячейку. Ячейка является базовой единицей хранения данных в блокчейне TON.

- `ihr_price_factor`: это фактор, используемый для расчета стоимости немедленной маршрутизации гиперкуба (IHR).
    :::info
    IHR — это метод доставки сообщений в сети блокчейна TON, где сообщения отправляются непосредственно в цепочку шардов получателя.
    :::

- `first_frac`: этот параметр определяет долю оставшегося остатка, которая будет использоваться для первого перехода по маршруту сообщения.

- `next_frac`: этот параметр определяет долю оставшегося остатка, которая будет использоваться для последующих переходов по маршруту сообщения.

## Param 28

Этот параметр обеспечивает конфигурацию протокола Catchain в блокчейне TON. Catchain — это протокол консенсуса самого низкого уровня, используемый в TON для достижения соглашения между валидаторами.

### Параметры конфигурации:

- `flags`: общее поле, которое можно использовать для установки различных двоичных параметров. В этом случае оно равно 0, что означает, что никакие конкретные флаги не установлены.

- `shuffle_mc_validators`: логическое значение, указывающее, следует ли перемешивать валидаторы мастерчейна или нет. Если этот параметр установлен в 1, валидаторы будут перемешиваться; в противном случае — нет.

- `mc_catchain_lifetime`: время жизни catchain групп мастерчейна в секундах.

- `shard_catchain_lifetime`: время жизни catchain групп шардчейна в секундах.

- `shard_validators_lifetime`: время жизни группы валидаторов шардчейна в секундах.

- `shard_validators_num`: количество валидаторов в каждой группе валидации шардчейна.

## Param 29

Этот параметр предоставляет конфигурацию для протокола консенсуса над catchain ([Param 28](#param-28)) в блокчейне TON. Протокол консенсуса является важнейшим компонентом сети блокчейна и гарантирует, что все узлы согласятся с состоянием распределенного реестра.

### Параметры конфигурации:

- `flags`: общее поле, которое можно использовать для установки различных двоичных параметров. В этом случае оно равно 0, что означает, что никакие конкретные флаги не установлены.

- `new_catchain_ids`: логическое значение, указывающее, следует ли генерировать новые идентификаторы Catchain. Если этот параметр установлен на 1, будут сгенерированы новые идентификаторы. В этом случае ему присваивается значение 1, что означает, что будут сгенерированы новые идентификаторы.

- `round_candidates`: Количество кандидатов, рассматриваемых в каждом раунде протокола консенсуса. Здесь он установлен на 3.

- `next_candidate_delay_ms`: Задержка в миллисекундах перед тем, как право на создание кандидата блока перейдет к следующему валидатору. Здесь он установлен на 2000 мс (2 секунды).

- `consensus_timeout_ms`: Время ожидания консенсуса блока в миллисекундах. Здесь он установлен на 16000 мс (16 секунд).

- `fast_attempts`: Количество "быстрых" попыток достижения консенсуса. Здесь он установлен на 3.

- `attempt_duration`: Длительность каждой попытки достижения соглашения. Здесь он установлен на 8.

- `catchain_max_deps`: Максимальное количество зависимостей блока Catchain. Здесь установлено значение 4.

- `max_block_bytes`: Максимальный размер блока в байтах. Здесь установлено значение 2097152 байта (2 МБ).

- `max_collated_bytes`: Максимальный размер сериализованных доказательств корректности блока в байтах. Здесь установлено значение 2097152 байта (2 МБ).

- `proto_version`: Версия протокола. Здесь установлено значение 2.

- `catchain_max_blocks_coeff`: Коэффициент, ограничивающий скорость генерации блоков в Catchain, [описание](https://github.com/ton-blockchain/ton/blob/master/doc/catchain-dos.md). Здесь он установлен на 10000.

## Param 31

Этот параметр представляет собой конфигурацию адресов смарт-контрактов, с которых не взимается плата за газ или хранение, и где можно создавать tick-tok транзакции. Список обычно включает контракты управления. Параметр представлен в виде двоичной древовидной структуры — дерева (HashMap 256), где ключи представляют собой 256-битное представление адреса. В этом списке могут присутствовать только адреса в мастерчейне.

## Param 32, 34 и 36

Списки валидаторов из предыдущего (32), текущего (34) и следующего (36) раундов. Параметр 36 устанавливается с конца выборов до начала раунда.

### Параметры конфигурации:

- `cur_validators`: это текущий список валидаторов. Валидаторы обычно отвечают за проверку транзакций в сети блокчейна.

- `utime_since` и `utime_until`: эти параметры предоставляют период времени, в течение которого эти валидаторы активны.

- `total` и `main`: эти параметры предоставляют общее количество валидаторов и количество валидаторов, проверяющих мастерчейн в сети.

- `total_weight`: это суммирует веса валидаторов.

- `list`: список валидаторов в формате дерева `id->validator-data`: `validator_addr`, `public_key`, `weight`, `adnl_addr`: эти параметры предоставляют сведения о каждом валидаторе - их 256 адресов в мастерчейне, открытый ключ, вес, адрес ADNL (адрес, используемый на сетевом уровне TON).

## Param 40

Этот параметр определяет структуру конфигурации для штрафа за ненадлежащую работу (неподтверждение). При отсутствии параметра, размер штрафа по умолчанию составляет 101 TON.

## Параметры конфигурации:

**`MisbehaviourPunishmentConfig`**: Эта структура данных определяет, как наказывается ненадлежащая работа в системе.

Она содержит несколько полей:

- `default_flat_fine`: Эта часть штрафа не зависит от размера стейка.

- `default_proportional_fine`: Эта часть штрафа пропорциональна размеру стейка валидатора.

- `severity_flat_mult`: Это множитель, применяемый к значению `default_flat_fine` для существенных нарушений валидатором.

- `severity_proportional_mult`: Это множитель, применяемый к значению `default_proportional_fine` для существенных нарушений валидатором.

- `unpunishable_interval`: Этот параметр представляет собой период, в течение которого нарушители не штрафуют для устранения временных сетевых проблем или других аномалий.

- `long_interval`, `long_flat_mult`, `long_proportional_mult`: Эти параметры определяют "длинный" период времени и множители для фиксированных и пропорциональных штрафов за ненадлежащую работу.

- `medium_interval`, `medium_flat_mult`, `medium_proportional_mult`: Аналогично, они определяют "средний" период времени и множители для фиксированных и пропорциональных штрафов за ненадлежащую работу.

## Param 43

Этот параметр относится к различным ограничениям по размеру и другим характеристикам аккаунтов и сообщений.

### Параметры конфигурации:

- `max_msg_bits`: максимальный размер сообщения в битах.

- `max_msg_cells`: максимальное количество ячеек (форма единицы хранения), которое может занимать сообщение.

- `max_library_cells`: максимальное количество ячеек, которые могут быть использованы для библиотеки ячеек.

- `max_vm_data_depth`: максимальная глубина ячеек в сообщениях и состоянии аккаунта.

- `max_ext_msg_size`: максимальный размер внешнего сообщения в битах.

- `max_ext_msg_depth`: максимальная глубина внешнего сообщения. Это может относиться к глубине структуры данных в сообщении.

- `max_acc_state_cells`: максимальное количество ячеек, которые может занимать состояние аккаунта.

- `max_acc_state_bits`: максимальный размер состояния аккаунта в битах.

Если отсутствует, то берутся параметры по умолчанию:

- `max_size` = 65535
- `max_depth` = 512
- `max_msg_bits` = 1 \<\< 21
- `max_msg_cells` = 1 \<\< 13
- `max_library_cells` = 1000
- `max_vm_data_depth` = 512
- `max_acc_state_cells` = 1 \<\< 16
- `max_acc_state_bits` = (1 \<\< 16) \* 1023

:::info
Вы можете просмотреть более подробную информацию о стандартных параметрах [здесь](https://github.com/ton-blockchain/ton/blob/fc9542f5e223140fcca833c189f77b1a5ae2e184/crypto/block/mc-config.h#L379) в исходном коде.
:::

## Param 44

Этот параметр определяет список приостановленных адресов, которые не могут быть инициализированы до `suspended_until`. Он применяется только к еще не инициированным аккаунтам. Это мера стабилизации токеномики (ограничение ранних майнеров). Если не задано - ограничений нет. Каждый адрес представлен как конечный узел в этом дереве, а древовидная структура позволяет эффективно проверять наличие или отсутствие адреса в списке.

:::info
Стабилизация токеномики более подробно описана в [официальном отчете](https://t.me/tonblockchain/178) канала Telegram "The Open Network".
:::

## Param 45

Список предварительно скомпилированных контрактов хранится в конфигурации мастерчейна:

```
precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
_ PrecompiledContractsConfig = ConfigParam 45;
```

Подробнее о предварительно скомпилированных контрактах на [этой странице](/v3/documentation/smart-contracts/contracts-specs/precompiled-contracts).

## Param 71 - 73

Этот параметр относится к мостам для обертывания TON в других сетях:

- ETH-TON \*\* (71)\*\*
- BSC-TON \*\* (72) \*\*
- Polygon-TON \*\* (73) \*\*

### Параметры конфигурации:

- `bridge_address`: Это адрес контракта моста, который принимает TON для выпуска обернутого TON в других сетях.

- `oracle_multisig_address`: Это адрес кошелька управления мостом. Кошелек с мультиподписью — это тип цифрового кошелька, который требует подписей от нескольких сторон для авторизации транзакции. Он часто используется для повышения безопасности. Оракулы выступают в качестве сторон.

- `oracles`: Список оракулов в виде дерева `id->address`

- `external_chain_address`: Это адрес контракта моста в соответствующем внешнем блокчейне.

## Param 79, 81 и 82

Этот параметр относится к мостам для обертывания токенов из других сетей в токены сети TON:

- ETH-TON \*\* (79) \*\*
- BSC-TON \*\* (81) \*\*
- Polygon-TON \*\* (82) \*\*

### Параметры конфигурации:

- `bridge_address` и `oracles_address`: Это адреса блокчейна моста и контракта управления мостом (мультиподпись оракула) соответственно.

- `oracles`: список оракулов в виде дерева `id->address`

- `state_flags`: Флаг состояния. Этот параметр отвечает за включение/отключение отдельных функций моста.

- `prices`: этот параметр содержит список или словарь цен на различные операции или комиссии, связанные с мостом, например `bridge_burn_fee`, `bridge_mint_fee`, `wallet_min_tons_for_storage`, `wallet_gas_consumption`, `minter_min_tons_for_storage`, `discover_gas_consumption`.

- `external_chain_address`: адрес контракта моста в другом блокчейне.

## Отрицательные параметры

:::info
Разница между отрицательными параметрами и положительными заключается в необходимости проверки валидаторов; обычно им не назначена определенная роль.
:::

## Следующие шаги

После глубокого погружения в эту статью настоятельно рекомендуется уделить время более детальному изучению следующих документов:

- Оригинальные, но ограниченные описания в [whitepaper.pdf](https://ton.org/whitepaper.pdf) и [tblkch.pdf](/tblkch.pdf).

- [mc-config.h](https://github.com/ton-blockchain/ton/blob/fc9542f5e223140fcca833c189f77b1a5ae2e184/crypto/block/mc-config.h), [block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb) и [тип BlockMasterConfig](https://docs.evercloud.dev/reference/graphql-api/field_descriptions#blockmasterconfig-type).

## 📖 Смотрите также

На этой странице вы можете найти активные сетевые конфигурации блокчейна TON:

- Основная сеть: https://ton.org/global-config.json
- Тестовая сеть: https://ton.org/testnet-global.config.json
- [Русская версия](https://github.com/delovoyhomie/description-config-for-TON-Blockchain/blob/main/Russian-version.md).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/config-params.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/config-params.md
================================================
# Изменение параметров

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Цель этого документа — предоставить базовое объяснение параметров конфигурации блокчейна TON и пошаговые инструкции по изменению этих параметров по консенсусу большинства валидаторов.

Мы предполагаем, что читатель уже знаком с [Fift](/v3/documentation/smart-contracts/fift/overview) и [Lite Client](/v3/guidelines/nodes/running-nodes/liteserver-node), как описано в [статье "Полный узел" (низкоуровневая)](/v3/guidelines/nodes/running-nodes/full-node) и [статье "Валидатор" (низкоуровневая)](/v3/guidelines/nodes/running-nodes/validator-node) в разделах, где описывается голосование валидаторов за предложения по конфигурации.

## 1. Параметры конфигурации

**Параметры конфигурации** — это определенные значения, которые влияют на поведение валидаторов и/или фундаментальных смарт-контрактов блокчейна TON. Текущие значения всех параметров конфигурации хранятся как особая часть состояния мастерчейна и извлекаются из текущего состояния мастерчейна при необходимости. Поэтому имеет смысл говорить о значениях параметров конфигурации относительно определенного блока мастерчейна. Каждый блок шардчейна содержит ссылку на последний известный блок мастерчейна; значения из соответствующего состояния мастерчейна считаются активными для этого блока шардчейна и используются во время его генерации и проверки. Для блоков мастерчейна состояние предыдущего блока мастерчейна используется для извлечения активных параметров конфигурации. Поэтому, даже если кто-то попытается изменить некоторые параметры конфигурации внутри блока мастерчейна, изменения станут активными только для следующего блока мастерчейна.

Каждый параметр конфигурации идентифицируется подписанным 32-битным целочисленным индексом, называемым **индексом параметра конфигурации** или просто **индексом**. Значением параметра конфигурации всегда является ячейка. Некоторые параметры конфигурации могут отсутствовать; тогда иногда предполагается, что значение этого параметра равно `Null`. Также существует список **обязательных** параметров конфигурации, которые должны присутствовать всегда; этот список хранится в параметре конфигурации `#10`.

Все параметры конфигурации объединены в **словарь конфигурации** - хэш-карту с подписанными 32-битными ключами (индексами параметров конфигурации) и значениями, состоящими ровно из одной ссылки на ячейку. Другими словами, словарь конфигурации - это значение типа TL-B (`HashmapE 32 ^Cell`). Фактически, коллекция всех параметров конфигурации хранится в состоянии мастерчейна как значение типа TL-B `ConfigParams`:

```
_ config_addr:bits256 config:^(Hashmap 32 ^Cell) = ConfigParams;
```

Мы видим, что, помимо словаря конфигурации, `ConfigParams` содержит `config_addr` - 256-битный адрес смарт-контракта конфигурации в мастерчейне. Более подробная информация о смарт-контракте конфигурации будет предоставлена ​​позже.

Словарь конфигурации, содержащий активные значения всех параметров конфигурации, доступен через специальный регистр TVM `c7` для всех смарт-контрактов, когда их код выполняется в транзакции. Точнее, когда выполняется смарт-контракт, `c7` инициализируется кортежем, единственным элементом которого является кортеж с несколькими "контекстными" значениями, полезными для выполнения смарт-контракта, такими как текущее время в Unix (как указано в заголовке блока). Десятая запись этого кортежа (т.е. запись с нулевым индексом 9) содержит ячейку, представляющую словарь конфигурации. Следовательно, к нему можно получить доступ с помощью команд TVM `PUSH c7; FIRST; INDEX 9` или эквивалентной команды `CONFIGROOT`. Фактически, специальные инструкции TVM `CONFIGPARAM` и `CONFIGOPTPARAM` объединяют предыдущие действия с поиском по словарю, возвращая любой параметр конфигурации по его индексу. Мы обращаемся к документации TVM для получения более подробной информации об этих инструкциях. Здесь важно то, что все параметры конфигурации легко доступны из всех смарт-контрактов (мастерчейн или шардчейн), и смарт-контракты могут проверять их и использовать для выполнения определенных проверок. Например, смарт-контракт может извлекать цены на хранение данных воркчейна из параметра конфигурации, чтобы вычислить цену за хранение части предоставленных пользователем данных.

Значения параметров конфигурации не являются произвольными. Фактически, если индекс параметра конфигурации `i` неотрицателен, то значение этого параметра должно быть допустимым значением типа TL-B (`ConfigParam i`). Это ограничение вводится валидаторами, которые не будут принимать изменения параметров конфигурации с неотрицательными индексами, если только они не являются допустимыми значениями соответствующего типа TL-B.

Следовательно, структура таких параметров определяется в исходном файле `crypto/block/block.tlb`, где (`ConfigParam i`) определяется для разных значений `i`. Например,

```
_ config_addr:bits256 = ConfigParam 0;
_ elector_addr:bits256 = ConfigParam 1;
_ dns_root_addr:bits256 = ConfigParam 4;  // root TON DNS resolver

capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
_ GlobalVersion = ConfigParam 8;  // all zero if absent
```

Мы видим, что параметр конфигурации `#8` содержит ячейку без ссылок и ровно 104 бита данных. Первые четыре бита должны быть `11000100`, затем сохраняются 32 бита с включенной в данный момент "глобальной версией", а затем следует 64-разрядное целое число с флагами, соответствующими включенным в данный момент возможностям. Более подробное описание всех параметров конфигурации будет приведено в приложении к документации по блокчейну TON, а пока можно ознакомиться со схемой TL-B в `crypto/block/block.tlb` и проверить, как различные параметры используются в источниках валидатора.

В отличие от параметров конфигурации с неотрицательными индексами, параметры конфигурации с отрицательными индексами могут содержать произвольные значения. По крайней мере, средства проверки не накладывают никаких ограничений на их значения. Таким образом, они могут использоваться для хранения важной информации (например, времени Unix, когда должны начать работать определенные смарт-контракты), которая не имеет решающего значения для генерации блоков, но используется некоторыми основными смарт-контрактами.

## 2. Изменение параметров конфигурации

Мы уже объяснили, что текущие значения параметров конфигурации хранятся в специальной части состояния мастерчейна. Как они вообще могут быть изменены?

Фактически, в мастерчейне находится специальный смарт-контракт, называемый **конфигурационным смарт-контрактом**. Его адрес определяется полем `config_addr` в `ConfigParams`, которое мы описали ранее. Первая ссылка на ячейку в его данных должна содержать актуальную копию всех параметров конфигурации. Когда генерируется новый блок мастерчейна, смарт-контракт конфигурации ищет по его адресу, `config_addr`, и новый словарь конфигурации извлекается из первой ссылки в ячейку его данных. После некоторых проверок достоверности (например, проверки того, что любое значение с неотрицательным 32-битным индексом `i` действительно является допустимым значением типа TL-B (`ConfigParam i`)) валидатор копирует этот новый словарь конфигурации в часть мастерчейна, содержащую ConfigParams. Это выполняется после создания всех транзакций, поэтому проверяется только окончательная версия нового словаря конфигурации, хранящегося в смарт-контракте конфигурации. Если проверки на валидность не пройдены, то "истинный" словарь конфигурации остается неизменным. Таким образом, смарт-контракт конфигурации не может устанавливать недействительные значения параметров конфигурации. Если новый словарь конфигурации совпадает с текущим словарем конфигурации, то проверки не выполняются и изменения не вносятся.

Таким образом, все изменения параметров конфигурации выполняются смарт-контрактом конфигурации, и именно его код определяет правила изменения параметров конфигурации. В настоящее время смарт-контракт конфигурации поддерживает два режима изменения параметров конфигурации:

1. Посредством внешнего сообщения, подписанного определенным закрытым ключом, который соответствует открытому ключу, хранящемуся в данных смарт-контракта конфигурации. Этот метод используется в общедоступной тестовой сети и, вероятно, в небольших частных тестовых сетях, контролируемых одним субъектом, поскольку он позволяет оператору легко изменять значения любых параметров конфигурации. Обратите внимание, что этот открытый ключ может быть изменен с помощью специального внешнего сообщения, подписанного старым ключом, и что если он будет изменен на ноль, то этот механизм будет отключен. Таким образом, можно было бы использовать его для точной настройки сразу после запуска, а затем отключить навсегда.
2. Путем создания "предложений по настройке", за которые впоследствии голосуют валидаторы. Как правило, предложение по настройке должно собрать голоса более чем 3/4 всех проверяющих (по весу), и не только за один раунд, но и за несколько раундов (т.е. несколько последовательных наборов проверяющих должны подтвердить предлагаемое изменение параметра). Это механизм распределенного управления, который будет использоваться основной сетью блокчейна TON.

Мы хотели бы подробнее описать второй способ изменения параметров конфигурации.

## 3. Создание предложений по конфигурации

Новое **предложение по конфигурации** содержит следующие данные:

- индекс параметра конфигурации, который необходимо изменить
- новое значение параметра конфигурации (или Null, если его необходимо удалить)
- время истечения срока действия предложения в Unix
- флаг, указывающий, является ли предложение **критическим** или нет
- необязательный **хеш старого значения** с хешем ячейки текущего значения (предложение может быть активировано только в том случае, если текущее значение имеет указанный хеш)

Любой, у кого есть кошелек в мастерчейне, может создать новое предложение по конфигурации, при условии, что он заплатит соответствующую плату. Однако только валидаторы могут голосовать за или против существующих предложений по конфигурации.

Обратите внимание, что существуют **критические** и **обычные** предложения конфигурации. Критическое предложение конфигурации может изменить любой параметр конфигурации, включая один из так называемых критических (список параметров критической конфигурации хранится в параметре конфигурации `#10`, который сам по себе является критическим). Однако создание предложений по критической конфигурации обходится дороже, и обычно для этого требуется собрать больше голосов валидаторов в большем количестве раундов (точные требования к голосованию для обычных и предложений критической конфигурации хранятся в параметре критической конфигурации `#11`). С другой стороны, обычные предложения конфигурации дешевле, но они не могут изменить критические параметры конфигурации.

Чтобы создать новое предложение конфигурации, сначала нужно сгенерировать файл BoC (bag-of-cells), содержащий предлагаемое новое значение. Точный способ сделать это зависит от изменяемого параметра конфигурации. Например, если мы хотим создать параметр `-239`, содержащий строку UTF-8 "TEST" (т. е. `0x54455354`), мы могли бы создать `config-param-239.boc` следующим образом: вызвать Fift и затем ввести

```
<b "TEST" $, b> 2 boc+>B "config-param-239.boc" B>file
bye
```

В результате будет создан 21-байтовый файл `config-param-239.boc`, содержащий сериализацию требуемого значения.

Для более сложных случаев, и особенно для параметров конфигурации с неотрицательными индексами, этот простой подход не так легко применим. Мы рекомендуем использовать `create-state` (доступный как `crypto/create-state` в каталоге сборки) вместо `fift` и копировать и редактировать подходящие части исходных файлов `crypto/smartcont/gen-zerostate.fif` и `crypto/smartcont/CreateState.fif`, которые обычно используются для создания нулевого состояния (соответствующего "генезис блоку" других блокчейн архитектур) блокчейна TON.

Рассмотрим, например, параметр конфигурации `#8`, который содержит текущую включенную глобальную версию блокчейна и возможности:

```
capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
_ GlobalVersion = ConfigParam 8;
```

Мы можем проверить его текущее значение, запустив lite client и введя `getconfig 8`:

```
> getconfig 8
...
ConfigParam(8) = (
  (capabilities version:1 capabilities:6))

x{C4000000010000000000000006}
```

Теперь предположим, что мы хотим включить функцию, представленную как bit `#3` (`+8`), которая называется "capReportVersion" (при включении эта функция заставляет все средства сортировки сообщать о поддерживаемых версиях и возможностях в заголовках блоков, которые они генерируют). Поэтому мы хотим, чтобы у нас были `version=1` и `capabilities=14`. В этом примере мы все еще можем угадать правильную сериализацию и создать BoC-файл напрямую, введя Fift.

```
x{C400000001000000000000000E} s>c 2 boc+>B "config-param8.boc" B>file
```

(В результате создается 30-байтовый файл `config-param8.boc`, содержащий желаемое значение.)

Однако в более сложных случаях это может оказаться невозможным, поэтому давайте рассмотрим этот пример по-другому. А именно, мы можем проверить исходные файлы `crypto/smartcont/gen-zerostate.fif` и `crypto/smartcont/createState.fif` для соответствующих частей.

```
// version capabilities --
{ <b x{c4} s, rot 32 u, swap 64 u, b> 8 config! } : config.version!
1 constant capIhr
2 constant capCreateStats
4 constant capBounceMsgBody
8 constant capReportVersion
16 constant capSplitMergeTransactions
```

и

```
// version capabilities
1 capCreateStats capBounceMsgBody or capReportVersion or config.version!
```

Мы видим, что `config.version!` без последнего `8 config! по сути, выполняет то, что нам нужно, поэтому мы можем создать временный скрипт Fift, например, `create-param8.fif\\`:

```
#!/usr/bin/fift -s
"TonUtil.fif" include

1 constant capIhr
2 constant capCreateStats
4 constant capBounceMsgBody
8 constant capReportVersion
16 constant capSplitMergeTransactions
{ <b x{c4} s, rot 32 u, swap 64 u, b> } : prepare-param8

// create new value for config param #8
1 capCreateStats capBounceMsgBody or capReportVersion or prepare-param8
// check the validity of this value
dup 8 is-valid-config? not abort"not a valid value for chosen configuration parameter"
// print
dup ."Serialized value = " <s csr.
// save into file provided as first command line argument
2 boc+>B $1 tuck B>file
."(Saved into file " type .")" cr
```

Теперь, если мы запустим `fift -s create-param8.fif config-param8.boc` или, что еще лучше, `crypto/create-state -s create-param8.fif config-param8.boc` (из каталога сборки), мы увидим следующий результат:

```
Serialized value = x{C400000001000000000000000E}
(Saved into file config-param8.boc)
```

и мы получим 30-байтовый файл `config-param8.boc` с тем же содержимым, что и раньше.

Как только у нас есть файл с нужным значением параметра конфигурации, мы вызываем скрипт `create-config-proposal.fif`, который можно найти в каталоге `crypto/smartcont` исходной ветки с подходящими аргументами. Опять же, мы рекомендуем использовать `create-state` (доступный как `crypto/create-state` из каталога сборки) вместо `fift`, поскольку это специальная расширенная версия Fift, которая может выполнять больше проверок валидности, связанных с блокчейном:

```
$ crypto/create-state -s create-config-proposal.fif 8 config-param8.boc -x 1100000


Loading new value of configuration parameter 8 from file config-param8.boc
x{C400000001000000000000000E}

Non-critical configuration proposal will expire at 1586779536 (in 1100000 seconds)
Query id is 6810441749056454664 
resulting internal message body: x{6E5650525E838CB0000000085E9455904_}
 x{F300000008A_}
  x{C400000001000000000000000E}

B5EE9C7241010301002C0001216E5650525E838CB0000000085E9455904001010BF300000008A002001AC400000001000000000000000ECD441C3C
(a total of 104 data bits, 0 cell references -> 59 BoC data bytes)
(Saved to file config-msg-body.boc)
```

Мы получили тело внутреннего сообщения для отправки в смарт-контракт конфигурации с подходящим количеством Toncoin из любого смарт-контракта (кошелька), находящегося в мастерчейне. Адрес смарт-контракта конфигурации можно получить, введя `getconfig 0` в lite client:

```
> getconfig 0
ConfigParam(0) = ( config_addr:x5555555555555555555555555555555555555555555555555555555555555555)
x{5555555555555555555555555555555555555555555555555555555555555555}
```

Мы видим, что адрес смарт-контракта конфигурации - `-1:5555...5555`. Запустив подходящие get-методы этого смарт-контракта, мы можем узнать требуемую оплату для создания этого предложения конфигурации:

```
> runmethod -1:5555555555555555555555555555555555555555555555555555555555555555 proposal_storage_price 0 1100000 104 0

arguments:  [ 0 1100000 104 0 75077 ] 
result:  [ 2340800000 ] 
remote result (not to be trusted):  [ 2340800000 ] 
```

Параметры get-метода `proposal_storage_price` — это критический флаг (в данном случае 0), временной интервал в течение в течение которого это предложение будет активно (1,1 мегасекунды), общее количество бит (104) и ссылки на ячейки (0) в данных. Последние две величины можно увидеть в выходных данных `create-config-proposal.fif`.

Мы видим, что для создания этого предложения нужно заплатить 2,3408 Toncoin. Лучше добавить в сообщение не менее 1,5 Tonoin для оплаты комиссий за обработку, поэтому мы отправим 4 Toncoin вместе с запросом (все лишние Toncoin будут возвращены). Теперь мы используем `wallet.fif` (или соответствующий скрипт Fift для используемого нами кошелька) для создания перевода из нашего кошелька в смарт-контракт конфигурации, содержащий 4 Toncoin и тело из `config-msg-body.boc`. Обычно это выглядит так:

```
$ fift -s wallet.fif my-wallet -1:5555555555555555555555555555555555555555555555555555555555555555 31 4. -B config-msg-body.boc

Transferring GR$4. to account kf9VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQft = -1:5555555555555555555555555555555555555555555555555555555555555555 seqno=0x1c bounce=-1 
Body of transfer message is x{6E5650525E835154000000085E9293944_}
 x{F300000008A_}
  x{C400000001000000000000000E}

signing message: x{0000001C03}
 x{627FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA773594000000000000000000000000000006E5650525E835154000000085E9293944_}
  x{F300000008A_}
   x{C400000001000000000000000E}

resulting external message: x{89FE000000000000000000000000000000000000000000000000000000000000000007F0BAA08B4161640FF1F5AA5A748E480AFD16871E0A089F0F017826CDC368C118653B6B0CEBF7D3FA610A798D66522AD0F756DAEECE37394617E876EFB64E9800000000E01C_}
 x{627FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA773594000000000000000000000000000006E5650525E835154000000085E9293944_}
  x{F300000008A_}
   x{C400000001000000000000000E}

B5EE9C724101040100CB0001CF89FE000000000000000000000000000000000000000000000000000000000000000007F0BAA08B4161640FF1F5AA5A748E480AFD16871E0A089F0F017826CDC368C118653B6B0CEBF7D3FA610A798D66522AD0F756DAEECE37394617E876EFB64E9800000000E01C010189627FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA773594000000000000000000000000000006E5650525E835154000000085E9293944002010BF300000008A003001AC400000001000000000000000EE1F80CD3
(Saved to file wallet-query.boc)
```

Теперь мы отправляем внешнее сообщение `wallet-query.boc` в блокчейн с помощью lite client.

```
> sendfile wallet-query.boc
....
external message status is 1
```

Подождав некоторое время, мы можем проверить входящие сообщения нашего кошелька, чтобы проверить наличие ответных сообщений от смарт-контракта конфигурации, или, если нам повезет, просто проверить список всех активных предложений конфигурации с помощью метода `list_proposals` смарт-контракта конфигурации.

```
> runmethod -1:5555555555555555555555555555555555555555555555555555555555555555 list_proposals
...
arguments:  [ 107394 ] 
result:  [ ([64654898543692093106630260209820256598623953458404398631153796624848083036321 [1586779536 0 [8 C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} -1] 112474791597373109254579258586921297140142226044620228506108869216416853782998 () 864691128455135209 3 0 0]]) ] 
remote result (not to be trusted):  [ ([64654898543692093106630260209820256598623953458404398631153796624848083036321 [1586779536 0 [8 C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} -1] 112474791597373109254579258586921297140142226044620228506108869216416853782998 () 864691128455135209 3 0 0]]) ] 
... caching cell FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC
```

Мы видим, что список всех активных предложений конфигурации состоит ровно из одной записи, представленной парой.

```
[6465...6321 [1586779536 0 [8 C{FDCD...} -1] 1124...2998 () 8646...209 3 0 0]]
```

Первое число `6465..6321` - это уникальный идентификатор предложения конфигурации, равный его 256-битному хешу. Второй компонент этой пары - это кортеж, описывающий статус этого предложения конфигурации. Первый компонент этого кортежа - это время истечения срока действия Unix предложения конфигурации (`1586779546`). Второй компонент (`0`) - это флаг критичности. Далее следует само предложение конфигурации, описываемое тройкой `[8 C{FDCD...} -1]`, где `8` - это индекс параметра конфигурации, который нужно изменить, `C{FDCD...}` - это ячейка с новым значением (представленная хешем этой ячейки), а `-1` - это необязательный хеш старого значения этого параметра (`-1` означает, что этот хеш не был указан). Далее мы видим большое число `1124...2998`, представляющее идентификатор текущего набора валидаторов, затем пустой список `()`, представляющий набор всех активных на данный момент валидаторов, которые проголосовали за это предложение на данный момент, затем `weight_remaining`, равный `8646...209` — число, которое положительно, если предложение еще не собрало достаточно голосов валидаторов в этом раунде, и отрицательно в противном случае. Затем мы видим три числа: `3 0 0`. Эти числа — `rounds_remaining` (это предложение выдержит не более трех раундов, т. е. изменения текущего набора валидаторов), `wins` (количество раундов, в которых предложение собрало голоса более 3/4 всех валидаторов по весу) и `losses` (количество раундов, в которых за него проголосовало более 3/4 всех голосов валидаторов).

Мы можем проверить предлагаемое значение для параметра конфигурации `#8`, попросив lite-client расширить ячейку `C{FDCD...}`, используя ее хэш `FDCD...` или достаточно длинный префикс этого хеша, чтобы однозначно идентифицировать рассматриваемую ячейку:

```
> dumpcell FDC
C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} =
  x{C400000001000000000000000E}
```

Мы видим, что значение равно `x{C400000001000000000000000E}`, что действительно является значением, которое мы встроили в наше предложение конфигурации. Мы даже можем попросить lite client отобразить эту ячейку как значение типа TL-B (`ConfigParam 8`).

```
> dumpcellas ConfigParam8 FDC
dumping cells as values of TLB type (ConfigParam 8)
C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} =
  x{C400000001000000000000000E}
(
    (capabilities version:1 capabilities:14))
```

Это особенно полезно, когда мы рассматриваем предложения по конфигурации, созданные другими пользователями.

Обратите внимание, что предложение по конфигурации отныне идентифицируется его 256-битным хешем — огромным десятичным числом `6465...6321`. Мы можем проверить текущий статус конкретного предложения конфигурации, запустив get-метод `get_proposal` с единственным аргументом, равным идентификатору предложения конфигурации:

```
> runmethod -1:5555555555555555555555555555555555555555555555555555555555555555 get_proposal 64654898543692093106630260209820256598623953458404398631153796624848083036321
...
arguments:  [ 64654898543692093106630260209820256598623953458404398631153796624848083036321 94347 ] 
result:  [ [1586779536 0 [8 C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} -1] 112474791597373109254579258586921297140142226044620228506108869216416853782998 () 864691128455135209 3 0 0] ] 
```

Мы получаем по сути тот же результат, что и раньше, но только для одного предложения конфигурации и без идентификатора предложения конфигурации в начале.

## 4. Голосование за предложения конфигурации

После создания предложения по конфигурации предполагается, что оно наберет голоса более чем от 3/4 всех текущих валидаторов (по весу, т.е. по доле участия) в текущем раунде и, возможно, в нескольких последующих раундах (избранные наборы валидаторов). Таким образом, решение об изменении параметра конфигурации должно быть одобрено значительным большинством голосов не только текущего набора валидаторов, но и нескольких последующих наборов валидаторов.

Голосование за предложение конфигурации возможно только для текущих валидаторов, перечисленных (с их постоянными открытыми ключами) в параметре конфигурации `#34`. Процесс примерно следующий:

- Оператор валидатора ищет `val-idx`, индекс (начиная с 0) своего валидатора в текущем наборе валидаторов, сохраненный в параметре конфигурации `#34`.
- Оператор вызывает специальный скрипт Fift `config-proposal-vote-req.fif`, находящийся в каталоге `crypto/smartcont` исходной ветки, указывая `val-idx` и `config-proposal-id` в качестве аргументов:

```
    $ fift -s config-proposal-vote-req.fif -i 0 64654898543692093106630260209820256598623953458404398631153796624848083036321
    Creating a request to vote for configuration proposal 0x8ef1603180dad5b599fa854806991a7aa9f280dbdb81d67ce1bedff9d66128a1 on behalf of validator with index 0 
    566F744500008EF1603180DAD5B599FA854806991A7AA9F280DBDB81D67CE1BEDFF9D66128A1
    Vm90RQAAjvFgMYDa1bWZ-oVIBpkaeqnygNvbgdZ84b7f-dZhKKE=
    Saved to file validator-to-sign.req
```

- После этого запрос на голосование должен быть подписан закрытым ключом текущего валидатора, используя `sign <validator-key-id> 566F744...28A1` в `validator-engine-console`, подключенном к валидатору. Этот процесс похож на тот, что описан в [статье о валидаторах](/v3/guidelines/nodes/running-nodes/validator-node) для участия в выборах валидатора, но на этот раз должен использоваться текущий активный ключ.
- Затем должен быть вызван другой скрипт `config-proposal-signed.fif`. Он имеет аргументы, похожие на `config-proposal-req.fif`, но он ожидает два дополнительных аргумента: представление открытого ключа в формате base64, используемого для подписи запроса на голосование, и представление самой подписи в формате base64. Опять же, это очень похоже на процесс, описанный в [статье о валидаторах](/v3/guidelines/nodes/running-nodes/validator-node).
- Таким образом, создается файл `vote-msg-body.boc`, содержащий тело внутреннего сообщения, содержащего подписанный голос за это предложение конфигурации.
- После этого `vote-msg-body.boc` должен быть передан во внутреннем сообщении из любого смарт-контракта, находящегося в мастерчейне (обычно будет использоваться контролирующий смарт-контракт валидатора) вместе с небольшим количеством Toncoin для обработки (обычно должно быть достаточно 1,5 Toncoin). Это снова полностью похоже на процедуру, используемую во время выборов валидатора. Обычно это достигается путем запуска:

```
$ fift -s wallet.fif my_wallet_id -1:5555555555555555555555555555555555555555555555555555555555555555 1 1.5 -B vote-msg-body.boc
```

(если для управления валидатором используется простой кошелек) и затем отправкой полученного файла `wallet-query.boc` из lite client:

```
> sendfile wallet-query.boc
```

Вы можете отслеживать ответные сообщения из смарт-контракта конфигурации в управляющий смарт-контракт, чтобы узнать статус ваших запросов на голосование. В качестве альтернативы вы можете проверить статус предложения конфигурации с помощью get-метода `show_proposal` смарт-контракта конфигурации:

```
> runmethod -1:5555555555555555555555555555555555555555555555555555555555555555 get_proposal 64654898543692093106630260209820256598623953458404398631153796624848083036321
...
arguments:  [ 64654898543692093106630260209820256598623953458404398631153796624848083036321 94347 ] 
result:  [ [1586779536 0 [8 C{FDCD887EAF7ACB51DA592348E322BBC0BD3F40F9A801CB6792EFF655A7F43BBC} -1] 112474791597373109254579258586921297140142226044620228506108869216416853782998 (0) 864691128455135209 3 0 0] ]
```

На этот раз список индексов валидаторов, проголосовавших за это предложение конфигурации, должен быть непустым и должен содержать индекс вашего валидатора. В этом примере этот список равен (`0`), что означает, что проголосовал только валидатор с индексом `0` в параметре конфигурации `#34`. Если список станет достаточно большим, предпоследнее целое число (первый ноль в `3 0 0`) в статусе предложения увеличится на единицу, что будет означать новую победу этого предложения. Если количество побед становится больше или равно значению, указанному в параметре конфигурации `#11`, то предложение конфигурации автоматически принимается, и предлагаемые изменения вступают в силу немедленно. С другой стороны, когда меняется набор валидаторов, то список валидаторов, которые уже проголосовали, становится пустым, значение `rounds_remaining` (три в `3 0 0`) уменьшается на единицу, и если оно становится отрицательным, предложение конфигурации уничтожается. Если оно не уничтожается, и если оно не победило в этом раунде, то количество проигрышей (второй ноль в `3 0 0`) увеличивается. Если оно становится больше значения, указанного в параметре конфигурации `#11`, то предложение конфигурации отбрасывается. В результате все валидаторы, которые не голосовали в раунде, неявно проголосовали против.

## 5. Автоматизированный способ голосования по предложениям конфигурации

Подобно автоматизации, предоставляемой командой `createelectionbid` из `validator-engine-console` для участия в выборах валидатора, `validator-engine` и `validator-engine-console` предлагают автоматизированный способ выполнения большинства шагов, описанных в предыдущем разделе, создавая `vote-msg-body.boc`, готовый к использованию с управляющим кошельком. Чтобы использовать этот метод, необходимо установить скрипты Fift `config-proposal-vote-req.fif` и `config-proposal-vote-signed.fif` в тот же каталог, который механизм проверки использует для поиска `validator-elect-req.fif` и `validator-elect-signed.fif`, как описано в разделе 5 [статье о валидаторе](/v3/guidelines/nodes/running-nodes/validator-node). После этого вы просто запускаете

```
    createproposalvote 64654898543692093106630260209820256598623953458404398631153796624848083036321 vote-msg-body.boc
```

в validator-engine-console, чтобы создать `vote-msg-body.boc` с телом внутреннего сообщения, которое будет отправлено в смарт-контракт конфигурации.

## 6. Обновление кода смарт-контракта конфигурации и смарт-контракта выборщика

Может случиться так, что потребуется обновить код самого смарт-контракта конфигурации или код смарт-контракта выборщика. Для этого используется тот же механизм, что и описанный выше. Новый код должен быть сохранен в единственной ссылке на ячейку значений, и эта ячейка значений должна быть предложена в качестве нового значения параметра конфигурации `-1000` (для обновления смарт-контракта конфигурации) или `-1001` (для обновления смарт-контракта выборщика). Эти параметры претендуют на роль критических, поэтому для изменения конфигурации смарт-контракта требуется много голосов валидаторов (это сродни принятию новой конституции). Мы ожидаем, что такие изменения будут сначала протестированы в тестовой сети и будут обсуждаться предлагаемые изменения на публичных форумах, прежде чем каждый оператор валидатора решит проголосовать за или против предлагаемых изменений.

В качестве альтернативы критические параметры конфигурации `0` (адрес смарт-контракта конфигурации) или `1` (адрес смарт-контракта выборщика) могут быть изменены на другие значения, которые должны соответствовать уже существующим и правильно инициализированным смарт-контрактам. В частности, новый смарт-контракт конфигурации должен содержать действительный словарь конфигурации в первой ссылке его постоянных данных. Поскольку не так-то просто правильно переносить изменяющиеся данные (например, список активных предложений конфигурации или предыдущие и текущие списки участников выборов валидатора) между различными смарт-контрактами, в большинстве случаев лучше обновить код существующего смарт-контракта, чем менять адрес смарт-контракта конфигурации.

Для создания таких предложений конфигурации используются два вспомогательных скрипта для обновления кода смарт-контракта конфигурации или выборщика. А именно, `create-config-upgrade-proposal.fif` загружает исходный файл ассемблера Fift (`auto/config-code.fif` по умолчанию, соответствующий коду, автоматически сгенерированному компилятором FunC из `crypto/smartcont/config-code.fc`) и создает соответствующее предложение конфигурации (для параметра конфигурации `-1000`). Аналогично, `create-elector-upgrade-proposal.fif` загружает исходный файл ассемблера Fift (`auto/elector-code.fif` по умолчанию) и использует его для создания предложения конфигурации для параметра конфигурации `-1001`. Таким образом, создание предложений конфигурации для обновления одного из этих двух смарт-контрактов должно быть очень простым. Однако следует также опубликовать измененный исходный код FunC смарт-контракта, точную версию компилятора FunC, использованного для его компиляции, чтобы все валидаторы (или, скорее, их операторы) могли воспроизвести код в предложении конфигурации (и сравнить хэши), а также изучить и обсудить исходный код и изменения в этом коде, прежде чем принять решение о голосовании за или против предлагаемых изменений.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/network-configs.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/configs/network-configs.md
================================================
# Конфигурации сети

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

На этой странице вы можете найти активные конфигурации сети блокчейна TON:

- Основная сеть: https://ton.org/global-config.json
- Тестовая сеть: https://ton.org/testnet-global.config.json

## См. также

- [Типы узлов](/v3/documentation/infra/nodes/node-types)
- [Конфигурация параметров блокчейна](/v3/documentation/network/configs/blockchain-configs)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/adnl-tcp.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/adnl-tcp.md
================================================
# ADNL TCP - Liteserver

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Это низкоуровневый протокол, на котором построено все взаимодействие в сети TON, он может работать поверх любого протокола, но чаще всего используется поверх TCP и UDP. UDP используется для связи между узлами, а TCP - для связи с lite-серверами.

Теперь мы проанализируем ADNL, работающий поверх TCP, и узнаем, как напрямую взаимодействовать с lite-серверами.

В TCP-версии ADNL сетевые узлы используют открытые ключи ed25519 в качестве адресов и устанавливают соединение с помощью общего ключа, полученного с помощью процедуры Диффи-Хеллмана на эллиптических кривых - ECDH.

## Структура пакета

Каждый пакет ADNL TCP, за исключением пакета рукопожатия, имеет следующую структуру:

- 4 байта размера пакета в порядке от младшего к старшему (N)
- 32 байта nonce (случайные байты для защиты от атак с контрольной суммой)
- (N - 64) байта полезной нагрузки
- 32 байта контрольной суммы SHA256 из nonce и полезной нагрузки

Весь пакет, включая размер, зашифрован **AES-CTR**.
После расшифровки необходимо проверить, соответствует ли контрольная сумма данным, для проверки нужно просто самостоятельно посчитать контрольную сумму и сравнить результат с тем, что у нас в пакете.

Пакет подтверждения связи является исключением, он передается в частично незашифрованном виде и описан в следующей главе.

## Установка соединения

Чтобы установить соединение, нам нужно знать IP, порт и открытый ключ сервера, а также сгенерировать собственный закрытый и открытый ключ ed25519.

Данные публичного сервера, такие как IP, порт и ключ, можно получить из [глобальной конфигурации](https://ton-blockchain.github.io/global.config.json). IP в конфигурации в числовой форме, его можно привести к нормальной форме, используя, например, [этот инструмент](https://www.browserling.com/tools/dec-to-ip). Открытый ключ в конфигурации в формате base64.

Клиент генерирует 160 случайных байтов, некоторые из которых будут использоваться сторонами в качестве основы для шифрования AES.

Из них создаются 2 постоянных шифра AES-CTR, которые будут использоваться сторонами для шифрования/расшифровки сообщений после подтверждения связи.

- Шифр ​​A - ключ 0 - 31 байт, iv 64 - 79 байт
- Шифр ​​B - ключ 32 - 63 байта, iv 80 - 95 байт

Шифры применяются в следующем порядке:

- Шифр ​​A используется сервером для шифрования отправляемых им сообщений.
- Шифр ​​A используется клиентом для расшифровки полученных сообщений.
- Шифр ​​B используется клиентом для шифрования отправляемых им сообщений.
- Шифр ​​B используется сервером для расшифровки полученных сообщений.

Чтобы установить соединение, клиент должен отправить пакет подтверждения, содержащий:

- [32 байта] **ID ключа сервера** [[Подробнее]](#getting-key-id)
- [32 байта] **Наш открытый ключ ed25519**
- [32 байта] **Хеш SHA256 из наших 160 байт**
- [160 байт] **Наши 160 байт зашифрованы** [[Подробнее]](#handshake-packet-data-encryption)

При получении пакета подтверждения связи сервер выполнит те же действия, получит ключ ECDH, расшифрует 160 байт и создаст 2 постоянных ключа. Если все получится, сервер ответит пустым пакетом ADNL, без полезной нагрузки, для расшифровки которого (а также последующих) нам нужно использовать один из постоянных шифров.

С этого момента соединение можно считать установленным.

После установления соединения мы можем начать получать информацию; язык TL используется для сериализации данных.

[Подробнее о TL](/v3/documentation/data-formats/tl)

## Ping&Pong

Оптимально отправлять пакет ping каждые 5 секунд. Это необходимо для поддержания соединения во время отсутствия передачи данных, в противном случае сервер может разорвать соединение.

Пакет ping, как и все остальные, строится по стандартной схеме, описанной [выше](#packet-structure), и несет в себе идентификатор запроса и идентификатор ping в качестве полезных данных.

Давайте найдем нужную схему для запроса ping [здесь](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L35) и вычислим идентификатор схемы как
`crc32_IEEE("tcp.ping random_id:long = tcp.Pong")`. При преобразовании в байты с прямым порядком байтов получаем **9a2b084d**.

Таким образом, наш пакет ping ADNL будет выглядеть так:

- 4 байта размера пакета в прямом порядке -> 64 + (4+8) = **76**
- 32 байта nonce -> случайные 32 байта
- 4 байта схемы ID TL -> **9a2b084d**
- 8 байт идентификатора запроса -> случайное число uint64
- 32 байта контрольной суммы SHA256 из nonce и полезной нагрузки

Мы отправляем наш пакет и ждем [tcp.pong](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L23), `random_id` будет равен тому, который мы отправили в пакете ping.

## Получение информации от Liteserver

Все запросы, направленные на получение информации из блокчейна, упакованы в схему [Liteserver запроса](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L83), которая в свою очередь упакована в схему [ADNL запроса](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L22).

Lite запрос:
`liteServer.query data:bytes = Object`, id **df068c79**

ADNL запрос:
`adnl.message.query query_id:int256 query:bytes = adnl.Message`, id **7af98bb4**

Lite запрос передается внутри ADNL запроса как `query:bytes`, а окончательный запрос передается внутри Lite запроса как `data:bytes`.

[Анализ кодирующих байтов в TL](/v3/documentation/data-formats/tl)

### getMasterchainInfo

Теперь, поскольку мы уже знаем, как генерировать пакеты TL для API Lite, мы можем запросить информацию о текущем блоке мастерчейна TON.
Блок мастерчейна используется во многих дальнейших запросах как входной параметр для указания состояния (момента), в котором нам нужна информация.

Мы ищем [нужную нам схему TL](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L60), вычисляем ее идентификатор и создаем пакет:

- 4 байта размера пакета в прямом порядке -> 64 + (4+32+(1+4+(1+4+3)+3)) = **116**
- 32 байта nonce -> случайные 32 байта
- 4 байта схемы ID ADNL запроса -> **7af98bb4**
- 32 байта `query_id:int256` -> случайные 32 байта
  - 1 байт размера массива -> **12**
  - 4 байта схемы ID Lite запроса -> **df068c79**
    - 1 байт размера массива -> **4**
    - 4 байта схемы ID getMasterchainInfo -> **2ee6b589**
    - 3 нулевых байта заполнения (выравнивание по 8)
  - 3 нулевых байта заполнения (выравнивание по 16)
- 32 байта контрольной суммы SHA256 из одноразового nonce и полезной нагрузки

Пример пакета в шестнадцатеричном формате:

```
74000000                                                             -> packet size (116)
5fb13e11977cb5cff0fbf7f23f674d734cb7c4bf01322c5e6b928c5d8ea09cfd     -> nonce
  7af98bb4                                                           -> ADNLQuery
  77c1545b96fa136b8e01cc08338bec47e8a43215492dda6d4d7e286382bb00c4   -> query_id
    0c                                                               -> array size
    df068c79                                                         -> LiteQuery
      04                                                             -> array size
      2ee6b589                                                       -> getMasterchainInfo
      000000                                                         -> 3 bytes of padding
    000000                                                           -> 3 bytes of padding
ac2253594c86bd308ed631d57a63db4ab21279e9382e416128b58ee95897e164     -> sha256
```

В ответ мы ожидаем получить [liteServer.masterchainInfo](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L30), состоящий из последнего: [ton.blockIdExt](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/tonlib_api.tl#L51) state_root_hash:int256 и init:[tonNode.zeroStateIdExt](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L359).

Полученный пакет десериализуется так же, как и отправленный — имеет тот же алгоритм, но в противоположном направлении, за исключением того, что ответ оборачивается только в [ADNL запросе](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L23).

После расшифровки ответа получаем пакет вида:

```
20010000                                                                  -> packet size (288)
5558b3227092e39782bd4ff9ef74bee875ab2b0661cf17efdfcd4da4e53e78e6          -> nonce
  1684ac0f                                                                -> ADNLAnswer
  77c1545b96fa136b8e01cc08338bec47e8a43215492dda6d4d7e286382bb00c4        -> query_id (identical to request)
    b8                                                                    -> array size
    81288385                                                              -> liteServer.masterchainInfo
                                                                          last:tonNode.blockIdExt
        ffffffff                                                          -> workchain:int
        0000000000000080                                                  -> shard:long
        27405801                                                          -> seqno:int   
        e585a47bd5978f6a4fb2b56aa2082ec9deac33aaae19e78241b97522e1fb43d4  -> root_hash:int256
        876851b60521311853f59c002d46b0bd80054af4bce340787a00bd04e0123517  -> file_hash:int256
      8b4d3b38b06bb484015faf9821c3ba1c609a25b74f30e1e585b8c8e820ef0976    -> state_root_hash:int256
                                                                          init:tonNode.zeroStateIdExt 
        ffffffff                                                          -> workchain:int
        17a3a92992aabea785a7a090985a265cd31f323d849da51239737e321fb05569  -> root_hash:int256      
        5e994fcf4d425c0a6ce6a792594b7173205f740a39cd56f537defd28b48a0f6e  -> file_hash:int256
    000000                                                                -> 3 bytes of padding
520c46d1ea4daccdf27ae21750ff4982d59a30672b3ce8674195e8a23e270d21          -> sha256
```

### runSmcMethod

Мы уже знаем, как получить блок мастерчейна, поэтому теперь мы можем вызывать любые методы lite-сервера.
Давайте проанализируем **runSmcMethod** — это метод, который вызывает функцию из смарт-контракта и возвращает результат. Здесь нам нужно понять некоторые новые типы данных, такие как [TL-B](/v3/documentation/data-formats/tlb/tl-b-language), [Cell](/v3/documentation/data-formats/tlb/cell-boc#cell) и [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells).

Для выполнения метода смарт-контракта нам нужно построить и отправить запрос с использованием схемы TL:

```tlb
liteServer.runSmcMethod mode:# id:tonNode.blockIdExt account:liteServer.accountId method_id:long params:bytes = liteServer.RunMethodResult
```

И дождаться ответа со схемой:

```tlb
liteServer.runMethodResult mode:# id:tonNode.blockIdExt shardblk:tonNode.blockIdExt shard_proof:mode.0?bytes proof:mode.0?bytes state_proof:mode.1?bytes init_c7:mode.3?bytes lib_extras:mode.4?bytes exit_code:int result:mode.2?bytes = liteServer.RunMethodResult;
```

В запросе мы видим следующие поля:

1. mode:# - битовая маска uint32 того, что мы хотим видеть в ответе, например, `result:mode.2?bytes` будет присутствовать в ответе только в том случае, если бит с индексом 2 равен единице.
2. id:tonNode.blockIdExt - это наше состояние главного блока, которое мы получили в предыдущей главе.
3. account:[liteServer.accountId](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L27) - данные адреса воркчейна и смарт-контракта.
4. method_id:long - 8 байт, в которых от имени вызываемого метода записан crc16 с таблицей XMODEM + установлен бит 17 [[Расчет]](https://github.com/xssnick/tonutils-go/blob/88f83bc3554ca78453dd1a42e9e9ea82554e3dd2/ton/runmethod.go#L16)
5. params:bytes - [Стек](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/crypto/block/block.tlb#L783) сериализованный в [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells), содержащий аргументы для вызова метода. [[Пример реализации]](https://github.com/xssnick/tonutils-go/blob/88f83bc3554ca78453dd1a42e9e9ea82554e3dd2/tlb/stack.go)

Например, нам нужно только `result:mode.2?bytes`, тогда наш режим будет равен 0b100, то есть 4. В ответ мы получим:

1. mode:# -> то, что было отправлено - 4.
2. id:tonNode.blockIdExt -> наш главный блок, на котором был выполнен метод
3. shardblk:tonNode.blockIdExt -> блок шарда, в котором находится аккаунт контракта
4. exit_code:int -> 4 байта, которые являются кодом выхода при выполнении метода. Если все успешно, то = 0, если нет, то равно коду исключения.
5. result:mode.2?bytes -> [Стек](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/crypto/block/block.tlb#L783) сериализованный в [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells), содержащий значения, возвращаемые методом.

Давайте проанализируем вызов и получение результата из метода `a2` контракта `EQBL2_3lMiyywU17g-or8N7v9hDmPCpttzBPE2isF2GTzpK4`:

Код метода в FunC:

```func
(cell, cell) a2() method_id {
  cell a = begin_cell().store_uint(0xAABBCC8, 32).end_cell();
  cell b = begin_cell().store_uint(0xCCFFCC1, 32).end_cell();
  return (a, b);
}
```

Заполняем наш запрос:

- `mode` = 4, нам нужен только результат -> `04000000`
- `id` = результат выполнения getMasterchainInfo
- `account` = воркчейн 0 (4 байта `00000000`), и int256 [полученое из нашего адреса контракта](/v3/documentation/data-formats/tlb/tl-b-types#addresses), т. е. 32 байта `4bdbfde5322cb2c14d7b83ea2bf0deeff610e63c2a6db7304f1368ac176193ce`
- `method_id` = [вычисленный](https://github.com/xssnick/tonutils-go/blob/88f83bc3554ca78453dd1a42e9e9ea82554e3dd2/ton/runmethod.go#L16) id из `a2` -> `0a2e010000000000`
- `params:bytes` = Наш метод не принимает входные параметры, поэтому нам нужно передать ему пустой стек (`000000`, ячейка 3 байта - глубина стека 0), сериализованный в [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells) -> `b5ee9c72010101010005000006000000` -> сериализовать в байтах и ​​получить `10b5ee9c72410101010005000006000000000000` 0x10 - размер, 3 байта в конце - заполнение.

В ответ получаем:

- `mode:#` -> не интересно
- `id:tonNode.blockIdExt` -> не интересно
- `shardblk:tonNode.blockIdExt` -> не интересно
- `exit_code:int` -> равно 0, если выполнение прошло успешно
- `result:mode.2?bytes` -> [Стек](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/crypto/block/block.tlb#L783), содержащий данные, возвращаемые методом в формате [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells), распакуем его.

Внутри `result` мы получили `b5ee9c7201010501001b000208000002030102020203030400080ccffcc1000000080aabbcc8`, это [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells), содержащий данные. При десериализации мы получим ячейку:

```json
32[00000203] -> {
  8[03] -> {
    0[],
    32[0AABBCC8]
  },
  32[0CCFFCC1]
}
```

Если мы ее разберем, то получим 2 значения типа ячейки, которые возвращает наш метод FunC.
Первые 3 байта корневой ячейки `000002` - это глубина стека, то есть 2. Это значит, что метод вернул 2 значения.

Продолжаем разбор, следующие 8 бит (1 байт) - это тип значения на текущем уровне стека. Для некоторых типов может потребоваться 2 байта. Возможные варианты можно увидеть в [схеме](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/crypto/block/block.tlb#L766).
В нашем случае у нас `03`, что означает:

```tlb
vm_stk_cell#03 cell:^Cell = VmStackValue;
```

То есть тип нашего значения - ячейка, и, согласно схеме, она хранит само значение как ссылку. Но, если мы посмотрим на схему хранения элементов стека:

```tlb
vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
```

Мы увидим, что первая ссылка `rest:^(VmStackList n)` - это ячейка следующего значения в стеке, а наше значение `tos:VmStackValue` идет вторым, поэтому для получения значения нам нужно прочитать вторую ссылку, то есть `32[0CCFFCC1]` - это наша первая ячейка, которую вернул контракт.

Теперь мы можем пойти глубже и получить второй элемент стека, проходим по первой ссылке, теперь у нас есть:

```json
8[03] -> {
    0[],
    32[0AABBCC8]
  }
```

Повторяем тот же процесс. Первые 8 бит = `03` - то есть снова ячейка. Вторая ссылка - это значение `32[0AABBCC8]` и так как глубина нашего стека равна 2, мы завершаем проход. Всего у нас есть 2 значения, возвращаемых контрактом - `32[0CCFFCC1]` и `32[0AABBCC8]`.

Обратите внимание, что они идут в обратном порядке. Точно так же нужно передавать аргументы при вызове функции - в обратном порядке от того, что мы видим в коде FunC.

[Пример реализации](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/ton/runmethod.go#L24)

### getAccountState

Чтобы получить данные о состоянии аккаунта, такие как баланс, код и данные контракта, мы можем использовать [getAccountState](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L68). Для запроса нам нужен [новый главный блок](#getmasterchaininfo) и адрес аккаунта. В ответ мы получим структуру TL [AccountState](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/lite_api.tl#L38).

Давайте проанализируем схему TL AccountState:

```tlb
liteServer.accountState id:tonNode.blockIdExt shardblk:tonNode.blockIdExt shard_proof:bytes proof:bytes state:bytes = liteServer.AccountState;
```

1. `id` - наш главный блок, относительно которого мы получили данные.
2. `shardblk` - блок шарда воркчейна, где находится наш аккаунт, относительно которого мы получили данные.
3. `shard_proof` - доказательство Меркла блока шарда.
4. `proof` - доказательство Меркла состояния аккаунта.
5. `state` - [BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells) TL-B [схема состояния аккаунта](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/crypto/block/block.tlb#L232).

Из всех этих данных, то, что нам нужно, находится в состоянии, мы его и проанализируем.

Например, получим статус аккаунта `EQAhE3sLxHZpsyZ_HecMuwzvXHKLjYx4kEUehhOy2JmCcHCT`, `state` в ответе будет (на момент написания статьи):

```hex
b5ee9c720102350100051e000277c0021137b0bc47669b3267f1de70cbb0cef5c728b8d8c7890451e8613b2d899827026a886043179d3f6000006e233be8722201d7d239dba7d818134001020114ff00f4a413f4bcf2c80b0d021d0000000105036248628d00000000e003040201cb05060013a03128bb16000000002002012007080043d218d748bc4d4f4ff93481fd41c39945d5587b8e2aa2d8a35eaf99eee92d9ba96004020120090a0201200b0c00432c915453c736b7692b5b4c76f3a90e6aeec7a02de9876c8a5eee589c104723a18020004307776cd691fbe13e891ed6dbd15461c098b1b95c822af605be8dc331e7d45571002000433817dc8de305734b0c8a3ad05264e9765a04a39dbe03dd9973aa612a61f766d7c02000431f8c67147ceba1700d3503e54c0820f965f4f82e5210e9a3224a776c8f3fad1840200201200e0f020148101104daf220c7008e8330db3ce08308d71820f90101d307db3c22c00013a1537178f40e6fa1f29fdb3c541abaf910f2a006f40420f90101d31f5118baf2aad33f705301f00a01c20801830abcb1f26853158040f40e6fa120980ea420c20af2670edff823aa1f5340b9f2615423a3534e2a2d2b2c0202cc12130201201819020120141502016616170003d1840223f2980bc7a0737d0986d9e52ed9e013c7a21c2b2f002d00a908b5d244a824c8b5d2a5c0b5007404fc02ba1b04a0004f085ba44c78081ba44c3800740835d2b0c026b500bc02f21633c5b332781c75c8f20073c5bd0032600201201a1b02012020210115bbed96d5034705520db3c8340201481c1d0201201e1f0173b11d7420c235c6083e404074c1e08075313b50f614c81e3d039be87ca7f5c2ffd78c7e443ca82b807d01085ba4d6dc4cb83e405636cf0069006031003daeda80e800e800fa02017a0211fc8080fc80dd794ff805e47a0000e78b64c00015ae19574100d56676a1ec40020120222302014824250151b7255b678626466a4610081e81cdf431c24d845a4000331a61e62e005ae0261c0b6fee1c0b77746e102d0185b5599b6786abe06fedb1c68a2270081e8f8df4a411c4605a400031c34410021ae424bae064f613990039e2ca840090081e886052261c52261c52265c4036625ccd88302d02012026270203993828290111ac1a6d9e2f81b609402d0015adf94100cc9576a1ec1840010da936cf0557c1602d0015addc2ce0806ab33b50f6200220db3c02f265f8005043714313db3ced542d34000ad3ffd3073004a0db3c2fae5320b0f26212b102a425b3531cb9b0258100e1aa23a028bcb0f269820186a0f8010597021110023e3e308e8d11101fdb3c40d778f44310bd05e254165b5473e7561053dcdb3c54710a547abc2e2f32300020ed44d0d31fd307d307d33ff404f404d10048018e1a30d20001f2a3d307d3075003d70120f90105f90115baf2a45003e06c2170542013000c01c8cbffcb0704d6db3ced54f80f70256e5389beb198106e102d50c75f078f1b30542403504ddb3c5055a046501049103a4b0953b9db3c5054167fe2f800078325a18e2c268040f4966fa52094305303b9de208e1638393908d2000197d3073016f007059130e27f080705926c31e2b3e63006343132330060708e2903d08308d718d307f40430531678f40e6fa1f2a5d70bff544544f910f2a6ae5220b15203bd14a1236ee66c2232007e5230be8e205f03f8009322d74a9802d307d402fb0002e83270c8ca0040148040f44302f0078e1771c8cb0014cb0712cb0758cf0158cf1640138040f44301e201208e8a104510344300db3ced54925f06e234001cc8cb1fcb07cb07cb3ff400f400c9
```

[Разбем этот BoC](/v3/documentation/data-formats/tlb/cell-boc#bag-of-cells) и получим

<details>
  <summary>большая ячейка</summary>

```json
473[C0021137B0BC47669B3267F1DE70CBB0CEF5C728B8D8C7890451E8613B2D899827026A886043179D3F6000006E233BE8722201D7D239DBA7D818130_] -> {
  80[FF00F4A413F4BCF2C80B] -> {
    2[0_] -> {
      4[4_] -> {
        8[CC] -> {
          2[0_] -> {
            13[D180],
            141[F2980BC7A0737D0986D9E52ED9E013C7A218] -> {
              40[D3FFD30730],
              48[01C8CBFFCB07]
            }
          },
          6[64] -> {
            178[00A908B5D244A824C8B5D2A5C0B5007404FC02BA1B048_],
            314[085BA44C78081BA44C3800740835D2B0C026B500BC02F21633C5B332781C75C8F20073C5BD00324_]
          }
        },
        2[0_] -> {
          2[0_] -> {
            84[BBED96D5034705520DB3C_] -> {
              112[C8CB1FCB07CB07CB3FF400F400C9]
            },
            4[4_] -> {
              2[0_] -> {
                241[AEDA80E800E800FA02017A0211FC8080FC80DD794FF805E47A0000E78B648_],
                81[AE19574100D56676A1EC0_]
              },
              458[B11D7420C235C6083E404074C1E08075313B50F614C81E3D039BE87CA7F5C2FFD78C7E443CA82B807D01085BA4D6DC4CB83E405636CF0069004_] -> {
                384[708E2903D08308D718D307F40430531678F40E6FA1F2A5D70BFF544544F910F2A6AE5220B15203BD14A1236EE66C2232]
              }
            }
          },
          2[0_] -> {
            2[0_] -> {
              323[B7255B678626466A4610081E81CDF431C24D845A4000331A61E62E005AE0261C0B6FEE1C0B77746E0_] -> {
                128[ED44D0D31FD307D307D33FF404F404D1]
              },
              531[B5599B6786ABE06FEDB1C68A2270081E8F8DF4A411C4605A400031C34410021AE424BAE064F613990039E2CA840090081E886052261C52261C52265C4036625CCD882_] -> {
                128[ED44D0D31FD307D307D33FF404F404D1]
              }
            },
            4[4_] -> {
              2[0_] -> {
                65[AC1A6D9E2F81B6090_] -> {
                  128[ED44D0D31FD307D307D33FF404F404D1]
                },
                81[ADF94100CC9576A1EC180_]
              },
              12[993_] -> {
                50[A936CF0557C14_] -> {
                  128[ED44D0D31FD307D307D33FF404F404D1]
                },
                82[ADDC2CE0806AB33B50F60_]
              }
            }
          }
        }
      },
      872[F220C7008E8330DB3CE08308D71820F90101D307DB3C22C00013A1537178F40E6FA1F29FDB3C541ABAF910F2A006F40420F90101D31F5118BAF2AAD33F705301F00A01C20801830ABCB1F26853158040F40E6FA120980EA420C20AF2670EDFF823AA1F5340B9F2615423A3534E] -> {
        128[DB3C02F265F8005043714313DB3CED54] -> {
          128[ED44D0D31FD307D307D33FF404F404D1],
          112[C8CB1FCB07CB07CB3FF400F400C9]
        },
        128[ED44D0D31FD307D307D33FF404F404D1],
        40[D3FFD30730],
        640[DB3C2FAE5320B0F26212B102A425B3531CB9B0258100E1AA23A028BCB0F269820186A0F8010597021110023E3E308E8D11101FDB3C40D778F44310BD05E254165B5473E7561053DCDB3C54710A547ABC] -> {
          288[018E1A30D20001F2A3D307D3075003D70120F90105F90115BAF2A45003E06C2170542013],
          48[01C8CBFFCB07],
          504[5230BE8E205F03F8009322D74A9802D307D402FB0002E83270C8CA0040148040F44302F0078E1771C8CB0014CB0712CB0758CF0158CF1640138040F44301E2],
          856[DB3CED54F80F70256E5389BEB198106E102D50C75F078F1B30542403504DDB3C5055A046501049103A4B0953B9DB3C5054167FE2F800078325A18E2C268040F4966FA52094305303B9DE208E1638393908D2000197D3073016F007059130E27F080705926C31E2B3E63006] -> {
            112[C8CB1FCB07CB07CB3FF400F400C9],
            384[708E2903D08308D718D307F40430531678F40E6FA1F2A5D70BFF544544F910F2A6AE5220B15203BD14A1236EE66C2232],
            504[5230BE8E205F03F8009322D74A9802D307D402FB0002E83270C8CA0040148040F44302F0078E1771C8CB0014CB0712CB0758CF0158CF1640138040F44301E2],
            128[8E8A104510344300DB3CED54925F06E2] -> {
              112[C8CB1FCB07CB07CB3FF400F400C9]
            }
          }
        }
      }
    }
  },
  114[0000000105036248628D00000000C_] -> {
    7[CA] -> {
      2[0_] -> {
        2[0_] -> {
          266[2C915453C736B7692B5B4C76F3A90E6AEEC7A02DE9876C8A5EEE589C104723A1800_],
          266[07776CD691FBE13E891ED6DBD15461C098B1B95C822AF605BE8DC331E7D45571000_]
        },
        2[0_] -> {
          266[3817DC8DE305734B0C8A3AD05264E9765A04A39DBE03DD9973AA612A61F766D7C00_],
          266[1F8C67147CEBA1700D3503E54C0820F965F4F82E5210E9A3224A776C8F3FAD18400_]
        }
      },
      269[D218D748BC4D4F4FF93481FD41C39945D5587B8E2AA2D8A35EAF99EEE92D9BA96000]
    },
    74[A03128BB16000000000_]
  }
}
```

</details>

Теперь нам нужно проанализировать ячейку в соответствии со структурой TL-B:

```tlb
account_none$0 = Account;

account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```

Наша структура ссылается на другие структуры, такие как:

```tlb
anycast_info$_ depth:(#<= 30) { depth >= 1 } rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
   
storage_info$_ used:StorageUsed last_paid:uint32 due_payment:(Maybe Grams) = StorageInfo;
storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7) public_cells:(VarUInteger 7) = StorageUsed;
  
account_storage$_ last_trans_lt:uint64 balance:CurrencyCollection state:AccountState = AccountStorage;

currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection;
           
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;  
           
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;
```

Как мы видим, ячейка содержит много данных, но мы проанализируем основные случаи и получим баланс. Остальное можно проанализировать аналогичным образом.

Приступим к разбору. В корневой ячейке у нас есть данные:

```
C0021137B0BC47669B3267F1DE70CBB0CEF5C728B8D8C7890451E8613B2D899827026A886043179D3F6000006E233BE8722201D7D239DBA7D818130_
```

Преобразуем их в двоичную форму и получим:

```
11000000000000100001000100110111101100001011110001000111011001101001101100110010011001111111000111011110011100001100101110110000110011101111010111000111001010001011100011011000110001111000100100000100010100011110100001100001001110110010110110001001100110000010011100000010011010101000100001100000010000110001011110011101001111110110000000000000000000000110111000100011001110111110100001110010001000100000000111010111110100100011100111011011101001111101100000011000000100110
```

Посмотрим на нашу основную структуру TL-B, увидим, что у нас есть 2 варианта того, что там может быть - `account_none$0` или `account$1`. Понять, какой у нас вариант, можно, прочитав префикс, объявленный после символа $, в нашем случае это 1 бит. Если там 0, то у нас `account_none`, или 1, то есть `account`.

Наш первый бит из приведенных выше данных равен 1, поэтому мы работаем с `account$1` и будем использовать схему:

```tlb
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;
```

Далее у нас есть `addr:MsgAddressInt`, мы видим, что для MsgAddressInt у нас также есть несколько вариантов:

```tlb
addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
```

Чтобы понять, с каким работать, мы, как и в прошлый раз, считываем префиксные биты, на этот раз мы считываем 2 бита. Мы отсекаем уже считанный бит, остается `1000000...`, мы считываем первые 2 бита и получаем `10`, что означает, что мы работаем с `addr_std$10`.

Далее нам нужно разобрать `anycast:(Maybe Anycast)`, Maybe означает, что мы должны прочитать 1 бит, и если он один, прочитать Anycast, в противном случае пропустить. Наши оставшиеся биты `00000...`, считываем 1 бит, это 0, поэтому мы пропускаем Anycast.

Далее у нас `workchain_id: int8`, тут все просто, считываем 8 бит, это будет идентификатор воркчейна. Считываем следующие 8 бит, все нули, поэтому воркчейн равен 0.

Далее считываем `address:bits256`, это 256 бит адреса, так же как и с `workchain_id`. При считывании получаем `21137B0BC47669B3267F1DE70CBB0CEF5C728B8D8C7890451E8613B2D8998270` в шестнадцатеричном представлении.

Считываем адрес `addr:MsgAddressInt`, затем у нас есть `storage_stat:StorageInfo` из основной структуры, ее схема:

```tlb
storage_info$_ used:StorageUsed last_paid:uint32 due_payment:(Maybe Grams) = StorageInfo;
```

Сначала идет `used:StorageUsed`, со схемой:

```tlb
storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7) public_cells:(VarUInteger 7) = StorageUsed;
```

Это количество ячеек и бит, используемых для хранения данных аккаунта. Каждое поле определяется как `VarUInteger 7`, что означает единицу динамического размера, но максимум 7 бит. Вы можете понять, как оно устроено в соответствии со схемой:

```tlb
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n;
```

В нашем случае n будет равно 7. В len у нас будет `(#< 7)`, что означает количество бит, которые могут содержать число до 7. Вы можете определить это, переведя 7-1=6 в двоичную форму - `110`, мы получаем 3 бита, поэтому длина len = 3 бита. А значение равно `(uint (len * 8))`. Чтобы определить его, нам нужно прочитать 3 бита длины, получить число и умножить на 8, это будет размер `value`, то есть количество бит, которое нужно прочитать, чтобы получить значение VarUInteger.

Читаем `cells:(VarUInteger 7)`, берем наши следующие биты из корневой ячейки, смотрим на следующие 16 бит, чтобы понять, это `0010011010101000`. Читаем первые 3 бита len, это `001`, т. е. 1, получаем размер (uint (1 \* 8)), получаем uint 8, читаем 8 бит, это будет `cells`, `00110101`, т. е. 53 в десятичной форме. То же самое делаем для `bits` и `public_cells`.

Мы успешно прочитали `used:StorageUsed`, далее у нас `last_paid:uint32`, считываем 32 бита. Все так же просто с `due_payment:(Maybe Grams)` здесь Maybe, который будет равен 0, поэтому мы пропускаем Grams. Но, если Maybe равен 1, мы можем посмотреть на схему Grams `amount:(VarUInteger 16) = Grams` и сразу понять, что мы уже знаем, как с этим работать. Как и в прошлый раз, только вместо 7 у нас 16.

Далее у нас есть `storage:AccountStorage` со схемой:

```tlb
account_storage$_ last_trans_lt:uint64 balance:CurrencyCollection state:AccountState = AccountStorage;
```

Считываем `last_trans_lt:uint64`, это 64 бита, хранящие lt последней транзакции по счету. И, наконец, баланс, представленный схемой:

```tlb
currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection;
```

Отсюда мы будем считывать `grams:Grams`, который будет балансом аккаунта в nano-tone.
`grams:Grams` - это `VarUInteger 16`, для хранения 16 (в двоичной форме `10000`, вычитая 1, получаем `1111`), затем считываем первые 4 бита и умножаем полученное значение на 8, затем считываем полученное количество бит, это наш баланс.

Давайте проанализируем наши оставшиеся биты в соответствии с нашими данными:

```
100000000111010111110100100011100111011011101001111101100000011000000100110
```

Считываем первые 4 бита - `1000`, это 8. 8\*8=64, читаем следующие 64 бита = `0000011101011111010010001110011101101110100111110110000001100000`, удаляя лишние нулевые биты, получаем `11101011111010010001110011101101110100111110110000001100000`, что равно `531223439883591776`, и, переводя из nano в TON, получаем `531223439.883591776`.

На этом остановимся, так как все основные случаи мы уже разобрали, остальное можно получить аналогичным образом с тем, что мы разобрали. Также дополнительную информацию по разбору TL-B можно найти в [официальной документации](/v3/documentation/data-formats/tlb/tl-b-language)

### Другие методы

Теперь, изучив всю информацию, вы можете вызывать и обрабатывать ответы и для других методов lite-server. Принцип тот же :)

## Дополнительные технические детали подтверждения связи

### Получение идентификатора ключа

Идентификатор ключа — это хэш SHA256 сериализованной схемы TL.

Наиболее часто используемые схемы TL для ключей:

```tlb
pub.ed25519 key:int256 = PublicKey -- ID c6b41348
pub.aes key:int256 = PublicKey     -- ID d4adbc2d
pub.overlay name:bytes = PublicKey -- ID cb45ba34
pub.unenc data:bytes = PublicKey   -- ID 0a451fb6
pk.aes key:int256 = PrivateKey     -- ID 3751e8a5
```

Например, для ключей типа ED25519, которые используются для подтверждения связи, идентификатором ключа будет хэш SHA256 из
**[0xC6, 0xB4, 0x13, 0x48]** и **открытого ключа**, (массив из 36 байт, префикс + ключ)

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/crypto.go#L16)

### Шифрование пакетных данных при установлении связи

Пакет подтверждения связи отправляется в полуоткрытом виде, зашифровано всего 160 байт, содержащих информацию о постоянных шифрах.

Для их шифрования нам понадобится шифр AES-CTR, для его получения нам понадобится хэш SHA256 из 160 байт и [общий ключ ECDH](#getting-a-shared-key-using-ecdh)

Шифр строится следующим образом:

- key = (0 - 15 байт открытого ключа) + (16 - 31 байт хеша)
- iv = (0 - 3 байта хеша) + (20 - 31 байт открытого ключа)

После того, как шифр собран, мы шифруем с его помощью наших 160 байт.

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/connection.go#L361)

### Получение общего ключа с помощью ECDH

Для вычисления общего ключа нам понадобится наш закрытый ключ и открытый ключ сервера.

Суть DH заключается в получении общего секретного ключа, не раскрывая закрытую информацию. Приведу пример того, как это происходит, в максимально упрощенном виде. Предположим, нам нужно сгенерировать общий ключ между нами и сервером, процесс будет выглядеть так:

1. Мы генерируем секретные и открытые числа, например **6** и **7**
2. Сервер генерирует секретные и открытые числа, например **5** и **15**
3. Мы обмениваемся открытыми числами с сервером, отправляем **7** на сервер, он отправляет нам **15**.
4. Мы вычисляем: **7^6 mod 15 = 4**
5. Сервер вычисляет: **7^5 mod 15 = 7**
6. Мы обмениваемся полученными числами, отдаем серверу **4**, он дает нам **7**
7. Мы вычисляем **7^6 mod 15 = 4**
8. Сервер вычисляет: **4^5 mod 15 = 4**
9. Общий ключ = **4**

Детали самого ECDH будут опущены для простоты. Он вычисляется с использованием 2 ключей, закрытого и открытого, путем нахождения общей точки на кривой. Если интересно, лучше почитать об этом отдельно.

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/crypto.go#L32)

## Ссылки

*Вот [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/ADNL-TCP-Liteserver.md) [Олега Баранова](https://github.com/xssnick).*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/adnl-udp.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/adnl-udp.md
================================================
# ADNL UDP - Межузловое взаимодействие

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

ADNL через UDP используется узлами и компонентами TON для связи друг с другом. Это низкоуровневый протокол, поверх которого работают другие, более высокоуровневые протоколы TON, такие как DHT и RLDP.
В этой статье мы узнаем, как ADNL через UDP работает для базовой связи между узлами.

В отличие от ADNL через TCP, в реализации UDP обмен данными происходит в другой форме, и используется дополнительный уровень в виде каналов, но другие принципы схожи:
ключи шифрования также генерируются на основе нашего закрытого ключа и открытого ключа партнера, который заранее известен из конфигурации или получен от других узлов сети.

В UDP-версии ADNL соединение устанавливается одновременно с получением исходных данных от однорангового узла, если инициатор отправил сообщение "создать канал", ключ канала будет вычислен и создание канала будет подтверждено.
Когда канал будет установлен, дальнейшая связь будет продолжаться внутри него.

## Структура пакетов и обмен данными

### Первые пакеты

Давайте проанализируем инициализацию соединения с узлом DHT и получение подписанного списка его адресов, чтобы понять, как работает протокол.

Найдите нужный вам узел в [global config](https://ton-blockchain.github.io/global.config.json), в разделе `dht.nodes`. Например:

```json
{
  "@type": "dht.node",
  "id": {
    "@type": "pub.ed25519",
    "key": "fZnkoIAxrTd4xeBgVpZFRm5SvVvSx7eN3Vbe8c83YMk="
  },
  "addr_list": {
    "@type": "adnl.addressList",
    "addrs": [
      {
        "@type": "adnl.address.udp",
        "ip": 1091897261,
        "port": 15813
      }
    ],
    "version": 0,
    "reinit_date": 0,
    "priority": 0,
    "expire_at": 0
  },
  "version": -1,
  "signature": "cmaMrV/9wuaHOOyXYjoxBnckJktJqrQZ2i+YaY3ehIyiL3LkW81OQ91vm8zzsx1kwwadGZNzgq4hI4PCB/U5Dw=="
}
```

1. Возьмем его ключ ED25519, `fZnkoIAxrTd4xeBgVpZFRm5SvVvSx7eN3Vbe8c83YMk`, и декодируем его из base64
2. Возьмем его IP-адрес `1091897261` и переведем его в понятный формат с помощью [сервиса](https://www.browserling.com/tools/dec-to-ip) или с помощью преобразования в little endian байтов, получим `65.21.7.173`
3. Объединим с портом, получим `65.21.7.173:15813` и установим UDP-соединение.

Мы хотим открыть канал для связи с узлом и получить некоторую информацию, а как основная задача - получить от него список подписанных адресов. Для этого мы сгенерируем 2 сообщения, первое - [создать канал](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L129):

```tlb
adnl.message.createChannel key:int256 date:int = adnl.Message
```

Здесь у нас есть 2 параметра - ключ и дата. В качестве даты мы укажем текущую временную метку unix. А для ключа - нам нужно сгенерировать новую пару закрытый+открытый ключ ED25519 специально для канала, они будут использоваться для инициализации [открытого ключа шифрования](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-a-shared-key-using-ecdh). Мы будем использовать наш сгенерированный открытый ключ в параметре `key` сообщения, а закрытый пока просто сохраним.

Сериализуем заполненную структуру TL и получаем:

```
bbc373e6                                                         -- TL ID adnl.message.createChannel 
d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7 -- key
555c8763                                                         -- date
```

Далее перейдем к нашему основному запросу - [получить список адресов](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L198).
Чтобы выполнить его, нам сначала нужно сериализовать его структуру TL:

```tlb
dht.getSignedAddressList = dht.Node
```

У него нет параметров, поэтому мы просто сериализуем его. Это будет просто его идентификатор - `ed4879a9`.

Далее, поскольку это запрос более высокого уровня протокола DHT, нам нужно сначала обернуть его в структуру TL `adnl.message.query`:

```tlb
adnl.message.query query_id:int256 query:bytes = adnl.Message
```

В качестве `query_id` мы генерируем случайные 32 байта, в качестве `query` мы используем наш основной запрос, [обернутый в массив байтов](/v3/documentation/data-formats/tl#encoding-bytes-array).
Мы получим:

```
7af98bb4                                                         -- TL ID adnl.message.query
d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875 -- query_id
04 ed4879a9 000000                                               -- query
```

### Построение пакета

Вся коммуникация осуществляется с помощью пакетов, содержимое которых представляет собой [структуру TL](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L81):

```tlb
adnl.packetContents 
  rand1:bytes                                     -- random 7 or 15 bytes
  flags:#                                         -- bit flags, used to determine the presence of fields further
  from:flags.0?PublicKey                          -- sender's public key
  from_short:flags.1?adnl.id.short                -- sender's ID
  message:flags.2?adnl.Message                    -- message (used if there is only one message)
  messages:flags.3?(vector adnl.Message)          -- messages (if there are > 1)
  address:flags.4?adnl.addressList                -- list of our addresses
  priority_address:flags.5?adnl.addressList       -- priority list of our addresses
  seqno:flags.6?long                              -- packet sequence number
  confirm_seqno:flags.7?long                      -- sequence number of the last packet received
  recv_addr_list_version:flags.8?int              -- address version 
  recv_priority_addr_list_version:flags.9?int     -- priority address version
  reinit_date:flags.10?int                        -- connection reinitialization date (counter reset)
  dst_reinit_date:flags.10?int                    -- connection reinitialization date from the last received packet
  signature:flags.11?bytes                        -- signature
  rand2:bytes                                     -- random 7 or 15 bytes
        = adnl.PacketContents
        
```

После того, как мы сериализовали все сообщения, которые хотим отправить, мы можем начать создание пакета.
Пакеты, которые должны быть отправлены в канал, отличаются по содержимому от пакетов, которые отправляются до инициализации канала.
Сначала проанализируем основной пакет, который используется для инициализации.

Во время начального обмена данными, за пределами канала, сериализованная структура содержимого пакета префиксируется открытым ключом одноранговой стороны - 32 байта.
Наш открытый ключ - 32 байта, хэш sha256 сериализованного TL структуры содержимого пакета - 32 байта.
Содержимое пакета зашифровано с помощью [общего ключа](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-a-shared-key-using-ecdh), полученного из нашего закрытого ключа и открытого ключа сервера.

Сериализуем структуру содержимого нашего пакета и разберем ее побайтно:

```
89cd42d1                                                               -- TL ID adnl.packetContents
0f 4e0e7dd6d0c5646c204573bc47e567                                      -- rand1, 15 (0f) random bytes
d9050000                                                               -- flags (0x05d9) -> 0b0000010111011001
                                                                       -- from (present because flag's zero bit = 1)
c6b41348                                                                  -- TL ID pub.ed25519
   afc46336dd352049b366c7fd3fc1b143a518f0d02d9faef896cb0155488915d6       -- key:int256
                                                                       -- messages (present because flag's third bit = 1)
02000000                                                                  -- vector adnl.Message, size = 2 messages   
   bbc373e6                                                                  -- TL ID adnl.message.createChannel
   d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7          -- key
   555c8763                                                                  -- date (date of creation)
   
   7af98bb4                                                                  -- TL ID [adnl.message.query](/)
   d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875          -- query_id
   04 ed4879a9 000000                                                        -- query (bytes size 4, padding 3)
                                                                       -- address (present because flag's fourth bit = 1), without TL ID since it is specified explicitly
00000000                                                                  -- addrs (empty vector, because we are in client mode and do not have an address on wiretap)
555c8763                                                                  -- version (usually initialization date)
555c8763                                                                  -- reinit_date (usually initialization date)
00000000                                                                  -- priority
00000000                                                                  -- expire_at

0100000000000000                                                       -- seqno (present because flag's sixth bit = 1)
0000000000000000                                                       -- confirm_seqno (present because flag's seventh bit = 1)
555c8763                                                               -- recv_addr_list_version (present because flag's eighth bit = 1, usually initialization date)
555c8763                                                               -- reinit_date (present because flag's tenth bit = 1, usually initialization date)
00000000                                                               -- dst_reinit_date (present because flag's tenth bit = 1)
0f 2b6a8c0509f85da9f3c7e11c86ba22                                      -- rand2, 15 (0f) random bytes
```

После сериализации - нам нужно подписать полученный массив байтов ключом ED25519 нашего частного клиента (не канала), который мы сгенерировали и сохранили ранее.
После того, как мы сгенерировали подпись (размером 64 байта), нам нужно добавить ее в пакет, снова сериализовать, но теперь добавить 11-й бит к флагу, который означает наличие подписи:

```
89cd42d1                                                               -- TL ID adnl.packetContents
0f 4e0e7dd6d0c5646c204573bc47e567                                      -- rand1, 15 (0f) random bytes
d90d0000                                                               -- flags (0x0dd9) -> 0b0000110111011001
                                                                       -- from (present because flag's zero bit = 1)
c6b41348                                                                  -- TL ID pub.ed25519
   afc46336dd352049b366c7fd3fc1b143a518f0d02d9faef896cb0155488915d6       -- key:int256
                                                                       -- messages (present because flag's third bit = 1)
02000000                                                                  -- vector adnl.Message, size = 2 message   
   bbc373e6                                                                  -- TL ID adnl.message.createChannel
   d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7          -- key
   555c8763                                                                  -- date (date of creation)
   
   7af98bb4                                                                  -- TL ID adnl.message.query
   d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875          -- query_id
   04 ed4879a9 000000                                                        -- query (bytes size 4, padding 3)
                                                                       -- address (present because flag's fourth bit = 1), without TL ID since it is specified explicitly
00000000                                                                  -- addrs (empty vector, because we are in client mode and do not have an address on wiretap)
555c8763                                                                  -- version (usually initialization date)
555c8763                                                                  -- reinit_date (usually initialization date)
00000000                                                                  -- priority
00000000                                                                  -- expire_at

0100000000000000                                                       -- seqno (present because flag's sixth bit = 1)
0000000000000000                                                       -- confirm_seqno (present because flag's seventh bit = 1)
555c8763                                                               -- recv_addr_list_version (present because flag's eighth bit = 1, usually initialization date)
555c8763                                                               -- reinit_date (present because flag's tenth bit = 1, usually initialization date)
00000000                                                               -- dst_reinit_date (present because flag's tenth bit = 1)
40 b453fbcbd8e884586b464290fe07475ee0da9df0b8d191e41e44f8f42a63a710    -- signature (present because flag's eleventh bit = 1), (bytes size 64, padding 3)
   341eefe8ffdc56de73db50a25989816dda17a4ac6c2f72f49804a97ff41df502    --
   000000                                                              --
0f 2b6a8c0509f85da9f3c7e11c86ba22                                      -- rand2, 15 (0f) random bytes
```

Теперь у нас есть собранный, подписанный и сериализованный пакет, представляющий собой массив байтов.
Для последующей проверки его целостности получателем нам нужно вычислить хэш sha256 пакета. Например, пусть это будет `408a2a4ed623b25a2e2ba8bbe92d01a3b5dbd22c97525092ac3203ce4044dcd2`.

Теперь давайте зашифруем содержимое нашего пакета с помощью шифра AES-CTR, используя [общий ключ](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-a-shared-key-using-ecdh), полученный из нашего закрытого ключа и открытого ключа одноранговой сети (не ключа канала).

Мы почти готовы к отправке, осталось только [вычислить ID](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-key-id) ключа одноранговой сети ED25519 и объединить все вместе:

```
daa76538d99c79ea097a67086ec05acca12d1fefdbc9c96a76ab5a12e66c7ebb  -- server Key ID
afc46336dd352049b366c7fd3fc1b143a518f0d02d9faef896cb0155488915d6  -- our public key
408a2a4ed623b25a2e2ba8bbe92d01a3b5dbd22c97525092ac3203ce4044dcd2  -- sha256 content hash (before encryption)
...                                                               -- encrypted content of the packet
```

Теперь мы можем отправить наш собранный пакет одноранговой сети по UDP и ждать ответа.

В ответ мы получим пакет с похожей структурой, но с другими сообщениями. Он будет состоять из:

```
68426d4906bafbd5fe25baf9e0608cf24fffa7eca0aece70765d64f61f82f005  -- ID of our key
2d11e4a08031ad3778c5e060569645466e52bd1bd2c7b78ddd56def1cf3760c9  -- server public key, for shared key
f32fa6286d8ae61c0588b5a03873a220a3163cad2293a5dace5f03f06681e88a  -- sha256 content hash (before encryption)
...                                                               -- the encrypted content of the packet
```

Десериализация пакета с сервера выглядит следующим образом:

1. Проверяем идентификатор ключа из пакета, чтобы понять, что пакет для нас.
2. Используя открытый ключ сервера из пакета и наш закрытый ключ, вычисляем общий ключ и расшифровываем содержимое пакета
3. Сравниваем отправленный нам хеш sha256 с полученным хешем из расшифрованных данных, они должны совпадать
4. Начинаем десериализацию содержимого пакета с помощью схемы TL `adnl.packetContents`

Содержимое пакета будет выглядеть так:

```
89cd42d1                                                               -- TL ID adnl.packetContents
0f 985558683d58c9847b4013ec93ea28                                      -- rand1, 15 (0f) random bytes
ca0d0000                                                               -- flags (0x0dca) -> 0b0000110111001010
daa76538d99c79ea097a67086ec05acca12d1fefdbc9c96a76ab5a12e66c7ebb       -- from_short (because flag's first bit = 1)
02000000                                                               -- messages (present because flag's third bit = 1)
   691ddd60                                                               -- TL ID adnl.message.confirmChannel 
   db19d5f297b2b0d76ef79be91ad3ae01d8d9f80fab8981d8ed0c9d67b92be4e3       -- key (server channel public key)
   d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7       -- peer_key (our public channel key)
   94848863                                                               -- date
   
   1684ac0f                                                               -- TL ID adnl.message.answer 
   d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875       -- query_id
   90 48325384c6b413487d99e4a08031ad3778c5e060569645466e52bd5bd2c7b       -- answer (the answer to our request, we will analyze its content in an article about DHT)
      78ddd56def1cf3760c901000000e7a60d67ad071541c53d0000ee354563ee       --
      35456300000000000000009484886340d46cc50450661a205ad47bacd318c       --
      65c8fd8e8f797a87884c1bad09a11c36669babb88f75eb83781c6957bc976       --
      6a234f65b9f6e7cc9b53500fbe2c44f3b3790f000000                        --
      000000                                                              --
0100000000000000                                                       -- seqno (present because flag's sixth bit = 1)
0100000000000000                                                       -- confirm_seqno (present because flag's seventh bit = 1)
94848863                                                               -- recv_addr_list_version (present because flag's eighth bit = 1, usually initialization date)
ee354563                                                               -- reinit_date (present because flag's tenth bit = 1, usually initialization date)
94848863                                                               -- dst_reinit_date (present because flag's tenth bit = 1)
40 5c26a2a05e584e9d20d11fb17538692137d1f7c0a1a3c97e609ee853ea9360ab6   -- signature (present because flag's eleventh bit = 1), (bytes size 64, padding 3)
   d84263630fe02dfd41efb5cd965ce6496ac57f0e51281ab0fdce06e809c7901     --
   000000                                                              --
0f c3354d35749ffd088411599101deb2                                      -- rand2, 15 (0f) random bytes
```

Сервер ответил нам двумя сообщениями: `adnl.message.confirmChannel` и `adnl.message.answer`.
С `adnl.message.answer` все просто, это ответ на наш запрос `dht.getSignedAddressList`, мы разберем его в статье про DHT.

Давайте сосредоточимся на `adnl.message.confirmChannel`, что означает, что пир подтвердил создание канала и отправил нам свой открытый ключ канала. Теперь, имея наш закрытый ключ канала и открытый ключ канала пира, мы можем вычислить [общий ключ](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-a-shared-key-using-ecdh).

Теперь, когда мы вычислили общий ключ канала, нам нужно сделать из него 2 ключа — один для шифрования исходящих сообщений, другой для расшифровки входящих сообщений.
Сделать из него 2 ключа довольно просто, второй ключ равен общему ключу, записанному в обратном порядке. Пример:

```
Shared key : AABB2233

First key: AABB2233
Second key: 3322BBAA
```

Осталось определить, какой ключ для чего использовать, мы можем сделать это, сравнив идентификатор нашего открытого ключа канала с идентификатором открытого ключа канала сервера, преобразовав их в числовой вид — uint256. Этот подход используется для того, чтобы и сервер, и клиент определяли, какой ключ для чего использовать. Если сервер использует первый ключ для шифрования, то при таком подходе клиент всегда будет использовать его для расшифровки.

Условия использования:

```
The server id is smaller than our id:
Encryption: First Key
Decryption: Second Key

The server id is larger than our id:
Encryption: Second Key
Decryption: First Key

If the ids are equal (nearly impossible):
Encryption: First Key
Decryption: First Key
```

[[Пример реализации]](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/adnl.go#L502)

### Обмен данными в канале

Весь последующий обмен пакетами будет происходить внутри канала, а ключи канала будут использоваться для шифрования.
Давайте отправим тот же запрос `dht.getSignedAddressList` внутри только что созданного канала, чтобы увидеть разницу.

Давайте создадим пакет для канала, используя ту же структуру `adnl.packetContents`:

```
89cd42d1                                                               -- TL ID adnl.packetContents
0f c1fbe8c4ab8f8e733de83abac17915                                      -- rand1, 15 (0f) random bytes
c4000000                                                               -- flags (0x00c4) -> 0b0000000011000100
                                                                       -- message (because second bit = 1)
7af98bb4                                                                  -- TL ID adnl.message.query
fe3c0f39a89917b7f393533d1d06b605b673ffae8bbfab210150fe9d29083c35          -- query_id
04 ed4879a9 000000                                                        -- query (our dht.getSignedAddressList packed in bytes with padding 3)
0200000000000000                                                       -- seqno (because flag's sixth bit = 1), 2 because it is our second message
0100000000000000                                                       -- confirm_seqno (flag's seventh bit = 1), 1 because it is the last seqno received from the server
07 e4092842a8ae18                                                      -- rand2, 7 (07) random bytes
```

Пакеты в канале довольно просты и по сути состоят из последовательностей (seqno) и самих сообщений.

После сериализации, как и в прошлый раз, мы вычисляем хэш sha256 пакета. Затем мы шифруем пакет, используя ключ, предназначенный для исходящих пакетов канала.
[Вычисляем](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-key-id) `pub.aes` идентификатор ключа шифрования наших исходящих сообщений, и создаем наш пакет:

```
bcd1cf47b9e657200ba21d94b822052cf553a548f51f539423c8139a83162180 -- ID of encryption key of our outgoing messages 
6185385aeee5faae7992eb350f26ba253e8c7c5fa1e3e1879d9a0666b9bd6080 -- sha256 content hash (before encryption)
...                                                              -- the encrypted content of the packet
```

Мы отправляем пакет по UDP и ждем ответа. В ответ мы получим пакет того же типа, что и отправили (те же поля), но с ответом на наш запрос `dht.getSignedAddressList`.

## Другие типы сообщений

Для базовой коммуникации используются сообщения типа `adnl.message.query` и `adnl.message.answer`, которые мы обсуждали выше, но для некоторых ситуаций используются и другие типы сообщений, которые мы обсудим в этом разделе.

### adnl.message.part

Этот тип сообщения является частью одного из других возможных типов сообщений, например `adnl.message.answer`. Этот метод передачи данных используется, когда сообщение слишком велико для передачи в одной UDP-датаграмме.

```tlb
adnl.message.part 
hash:int256            -- sha256 hash of the original message
total_size:int         -- original message size
offset:int             -- offset according to the beginning of the original message
data:bytes             -- piece of data of the original message
   = adnl.Message;
```

Таким образом, чтобы собрать исходное сообщение, нам нужно получить несколько частей и, в соответствии со смещениями, объединить их в один массив байтов.
А затем обработать его как сообщение (в соответствии с префиксом ID в этом массиве байтов).

### adnl.message.custom

```tlb
adnl.message.custom data:bytes = adnl.Message;
```

Такие сообщения используются, когда логика на более высоком уровне не соответствует формату запрос-ответ, сообщения такого типа позволяют полностью перенести обработку на более высокий уровень, так как сообщение несет в себе только массив байт, без query_id и других полей.
Сообщения такого типа используются, например, в RLDP, так как на множество запросов может быть только один ответ, эта логика контролируется самим RLDP.

### Заключение

Дальнейший обмен данными осуществляется на основе логики, описанной в этой статье, но содержимое пакетов зависит от протоколов более высокого уровня, таких как DHT и RLDP.

## Ссылки

*Вот [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/ADNL-UDP-Internal.md) [Олега Баранова](https://github.com/xssnick).*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/low-level-adnl.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/low-level-adnl.md
================================================
# Низкоуровневый ADNL

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Сетевой уровень абстрактных датаграмм (Abstract Datagram Network Layer - ADNL) — это основной протокол TON, который помогает сетевым одноранговым узлам взаимодействовать друг с другом.

## Идентификация одноранговых узлов

Каждый одноранговый узел должен иметь по крайней мере один идентификатор, возможно, но необязательно использовать несколько. Каждая идентификация — это пара ключей, которая используется для выполнения алгоритма Диффи-Хеллмана между одноранговыми узлами. Абстрактный сетевой адрес выводится из открытого ключа следующим образом: `address = SHA-256(type_id || public_key)`. Обратите внимание, что type_id должен быть сериализован как little-endian uint32.

## Список криптосистем с открытым ключом

| type_id | cryptosystem        |
| ---------------------------- | ------------------- |
| 0x4813b4c6                   | ed25519<sup>1</sup> |

*1. Для выполнения x25519 пара ключей должна быть сгенерирована в формате x25519. Однако открытый ключ передается по сети в формате ed25519, поэтому вам придется преобразовать открытый ключ из x25519 в ed25519, примеры таких преобразований можно найти [здесь](https://github.com/andreypfau/curve25519-kotlin/blob/f008dbc2c0ebc3ed6ca5d3251ffb7cf48edc91e2/src/commonMain/kotlin/curve25519/MontgomeryPoint.kt#L39) для Kotlin.*

## Клиент-серверный протокол (ADNL через TCP)

Клиент подключается к серверу по протоколу TCP и отправляет пакет подтверждения ADNL, содержащий абстрактный адрес сервера, открытый ключ клиента и зашифрованные параметры сеанса AES-CTR, которые определяются клиентом.

### Подтверждение

Сначала клиент должен выполнить протокол согласования ключей (например, x25519), используя свой закрытый ключ и открытый ключ сервера, принимая во внимание `type_id` ключа сервера. В результате клиент получит `secret`, который используется для шифрования ключей сеанса на последующих этапах.

Затем клиент должен сгенерировать параметры сеанса AES-CTR, 16-байтовый nonce и 32-байтовый ключ, как для направления TX (клиент->сервер), так и для направления RX (сервер->клиент) и сериализовать их в 160-байтовый буфер следующим образом:

| Параметр                      | Размер   |
| ----------------------------- | -------- |
| rx_key   | 32 байта |
| tx_key   | 32 байта |
| rx_nonce | 16 байт  |
| tx_nonce | 16 байт  |
| padding                       | 64 байта |

Цель padding неизвестна, он не используется реализациями сервера. Рекомендуется заполнять весь 160-байтовый буфер случайными байтами, в противном случае злоумышленник может провести активную MitM-атаку, используя скомпрометированные параметры сеанса AES-CTR.

Следующий шаг — зашифровать параметры сеанса с помощью `secret` через протокол согласования ключей выше. Для этого AES-256 должен быть инициализирован в режиме CTR с 128-битным счетчиком big-endian с использованием пары (key, nonce), которая вычисляется следующим образом (`aes_params` — это 160-байтовый буфер, который был построен выше):

```cpp
hash = SHA-256(aes_params)
key = secret[0..16] || hash[16..32]
nonce = hash[0..4] || secret[20..32]
```

После шифрования `aes_params`, которое отмечено как `E(aes_params)`, AES следует удалить, поскольку он больше не нужен.

Теперь мы готовы преобразовать всю эту информацию в 256-байтный пакет подтверждения связи и отправить его на сервер:

| Параметр                                                    | Размер   | Примечания                                                                 |
| ----------------------------------------------------------- | -------- | -------------------------------------------------------------------------- |
| receiver_address                       | 32 байта | Идентификация однорангового сервера, как описано в соответствующем разделе |
| sender_public                          | 32 байта | Открытый ключ клиента                                                      |
| SHA-256(aes_params) | 32 байта | Подтверждение целостности параметров сеанса                                |
| E(aes_params)       | 160 байт | Зашифрованные параметры сеанса                                             |

Сервер должен расшифровать параметры сеанса с помощью секрета, полученного из протокола согласования ключей, тем же способом, что и клиент. Затем сервер должен выполнить следующие проверки для подтверждения свойств безопасности протокола:

1. Сервер должен иметь соответствующий закрытый ключ для `receiver_address`, в противном случае невозможно выполнить протокол согласования ключей.
2. `SHA-256(aes_params) == SHA-256(D(E(aes_params)))`, в противном случае протокол согласования ключей не выполнен, и `secret` не одинаков на обеих сторонах.

Если любая из этих проверок не пройдена, сервер немедленно разорвет соединение, не отвечая клиенту. Если все проверки пройдены, сервер должен выдать пустую датаграмму (см. раздел Датаграммы) клиенту, чтобы доказать, что он владеет закрытым ключом для указанного `receiver_address`.

### Датаграмма

Как клиент, так и сервер должны инициализировать по два экземпляра AES-CTR для обоих направлений: TX и RX. AES-256 должен использоваться в режиме CTR с 128-битным счетчиком big-endian. Каждый экземпляр AES инициализируется с использованием пары (key, nonce), принадлежащей ему, которую можно взять из `aes_params` при обмене данными.

Чтобы отправить датаграмму, одноранговый узел (клиент или сервер) должен построить следующую структуру, зашифровать ее и отправить другому одноранговому узлу:

| Параметр | Размер                          | Примечания                                        |
| -------- | ------------------------------- | ------------------------------------------------- |
| length   | 4 байта (LE) | Длина всей датаграммы, исключая поле `length`     |
| nonce    | 32 байта                        | Случайное значение                                |
| buffer   | `length - 64` байта             | Фактические данные для отправки на другую сторону |
| hash     | 32 байта                        | \`SHA-256(nonce \\           |

Вся структура должна быть зашифрована с использованием соответствующего экземпляра AES (TX для клиента -> сервера, RX для сервера -> клиента).

Принимающий узел должен извлечь первые 4 байта, расшифровать их в поле `length` и прочитать ровно `length` байтов, чтобы получить полную датаграмму. Принимающий узел может начать расшифровку и обработку `buffer` раньше, но он должен учитывать, что он может быть поврежден, намеренно или случайно. `Hash` датаграммы должен быть проверен, чтобы гарантировать целостность `buffer`. В случае сбоя новые датаграммы не могут быть выданы, и соединение должно быть разорвано.

Первая датаграмма в сеансе всегда отправляется от сервера клиенту после того, как сервер успешно принял пакет подтверждения связи, и его фактический буфер пуст. Клиент должен расшифровать ее и отключиться от сервера в случае сбоя, поскольку это означает, что сервер не следовал протоколу должным образом, и фактические ключи сеанса различаются на стороне сервера и клиента.

### Подробности связи

Если вы хотите углубиться в подробности связи, вы можете ознакомиться со статьей [ADNL TCP - Liteserver](/v3/documentation/network/protocols/adnl/adnl-tcp), чтобы увидеть несколько примеров.

### Вопросы безопасности

#### Дополнение к подключению

Неизвестно, почему первоначальная команда TON решила включить это поле в подключение. Целостность `aes_params` защищена хэшем SHA-256, а конфиденциальность защищена ключом, полученным из параметра `secret`. Вероятно, в какой-то момент планировалось перейти от AES-CTR. Для этого спецификация может быть расширена за счет включения специального магического значения в `aes_params`, которое будет сигнализировать о том, что одноранговый узел готов использовать обновленные примитивы. Ответ на такое подключение может быть расшифрован дважды, с новой и старой схемами, чтобы уточнить, какую схему фактически использует другой одноранговый узел.

#### Процесс получения ключа шифрования параметров сеанса

Если ключ шифрования получен только из параметра `secret`, он будет статическим, поскольку секрет является статическим. Для получения нового ключа шифрования для каждого сеанса разработчики также используют `SHA-256(aes_params)`, который является случайным, если `aes_params` является случайным. Однако фактический алгоритм получения ключа с конкатенацией различных подмассивов считается вредоносным.

#### Nonce датаграммы

Неочевидно, почему поле `nonce` присутствует в датаграмме, потому что даже без него любые два шифротекста будут отличаться из-за сеансовых ключей для AES и шифрования в режиме CTR. Однако в случае отсутствующего или предсказуемого nonce можно выполнить следующую атаку. Режим шифрования CTR превращает блочные шифры, такие как AES, в потоковые шифры, что позволяет выполнять атаку с инвертированием битов. Если злоумышленник знает открытый текст, который принадлежит зашифрованной датаграмме, он может получить чистый поток ключей, выполнить XOR его со своим собственным открытым текстом и эффективно заменить сообщение, которое было отправлено одноранговым узлом. Целостность буфера защищена хешем SHA-256, но злоумышленник может подменить и его, поскольку знание полного открытого текста означает знание его хеша. Поле nonce присутствует для предотвращения такой атаки, поэтому ни один злоумышленник не может подменить SHA-256, не зная nonce.

## Протокол P2P (ADNL через UDP)

Подробное описание можно найти в статье [ADNL UDP - Internode](/v3/documentation/network/protocols/adnl/adnl-udp).

## Ссылки

- [The Open Network, стр. 80](https://ton.org/ton.pdf)
- [Реализация ADNL в TON](https://github.com/ton-blockchain/ton/tree/master/adnl)

*Спасибо [hacker-volodya](https://github.com/hacker-volodya) за вклад в сообщество!*
*Вот [ссылка на оригинальную статью](https://github.com/tonstack/ton-docs/tree/main/ADNL) на GitHub.*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/overview.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/adnl/overview.md
================================================
# Протокол ADNL

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Реализация:

- https://github.com/ton-blockchain/ton/tree/master/adnl

## Общие сведения

Краеугольным камнем TON является абстрактный сетевой уровень датаграмм (ADNL - Abstract Datagram Network Layer).

Это оверлейный, одноранговый, недоверенный (небольшого размера) протокол датаграмм, работающий поверх **UDP** в **IPv4** (в будущем IPv6), с дополнительным **резервным протоколом TCP**, если UDP недоступен.

## Адрес ADNL

Каждый участник имеет 256-битный адрес ADNL.

Протокол ADNL позволяет отправлять (недоверенные) и получать датаграммы, используя только адреса ADNL. IP-адреса и порты скрыты протоколом ADNL.

Адрес ADNL по сути равен 256-битному открытому ключу ECC. Этот открытый ключ может быть сгенерирован произвольно, тем самым создавая столько различных сетевых идентификаторов, сколько нужно узлу.
Однако необходимо знать соответствующий закрытый ключ, чтобы получать (и расшифровывать) сообщения, предназначенные для адреса получателя.

На самом деле, адрес ADNL не является самим открытым ключом; вместо этого это 256-битный хэш SHA256 сериализованного TL-объекта, который может описывать несколько типов открытых ключей и адресов в зависимости от его конструктора.

## Шифрование и безопасность

Обычно каждая отправленная датаграмма подписывается отправителем и шифруется, так что только получатель может расшифровать сообщение и проверить его целостность с помощью подписи.

## Таблицы соседей

Обычно узел TON ADNL будет имеет некоторую "таблицу соседей", которая содержит информацию о других известных узлах, такую ​​как их абстрактные адреса, открытые ключи, IP-адреса и порты UDP. Со временем он постепенно
расширит эту таблицу, используя информацию, собранную с этих известных узлов. Эта новая информация может быть в форме ответов на специальные запросы или иногда удаления устаревших записей.

ADNL позволяет вам настраивать каналы и туннели точка-точка (цепочку прокси).

Поверх ADNL можно построить потоковый протокол, подобный TCP.

## Что дальше?

- Подробнее об ADNL читайте в [статье о низкоуровневом ADNL](/v3/documentation/network/protocols/adnl/low-level-adnl)
- Глава 3.1 [TON Whitepaper] (https://docs.ton.org/ton.pdf).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/dht/dht-deep-dive.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/dht/dht-deep-dive.md
================================================
# DHT

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Распределенная хеш-таблица (DHT - Distributed Hash Table) по сути является распределенной базой данных "ключ-значение",
где каждый участник сети может хранить что-то, например, информацию о себе.

Реализация DHT в TON по своей сути похожа на реализацию [Kademlia](https://codethechange.stanford.edu/guides/guide_kademlia.html), которая используется в IPFS.
Любой участник сети может запустить узел DHT, сгенерировать ключи и хранить данные.
Для этого ему нужно сгенерировать случайный идентификатор и сообщить другим узлам о себе.

Чтобы определить, на каком узле хранить данные, используется алгоритм, определяющий "расстояние" между узлом и ключом.
Алгоритм прост: берем идентификатор узла и идентификатор ключа, выполняем операцию XOR. Чем меньше значение, тем ближе узел.
Задача — хранить ключ на узлах, максимально приближенных к ключу, чтобы другие участники сети могли, используя тот же алгоритм, найти узел, который может предоставить данные по этому ключу.

## Поиск значения по ключу

Рассмотрим пример с поиском ключа, [подключаемся к любому узлу DHT и устанавливаем соединение по ADNL UDP](/v3/documentation/network/protocols/adnl/adnl-udp#packet-structure-and-communication).

Например, мы хотим найти адрес и открытый ключ для подключения к узлу, на котором размещен сайт foundation.ton.
Допустим, мы уже получили адрес ADNL этого сайта, выполнив Get метод контракта DNS.
Адрес ADNL в шестнадцатеричном представлении - `516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174`.
Теперь наша цель - найти ip, порт и открытый ключ узла, имеющего этот адрес.

Для этого нам нужно получить идентификатор ключа DHT, для начала заполним схему ключа DHT:

```tlb
dht.key id:int256 name:bytes idx:int = dht.Key
```

`name` - это тип ключа, для адресов ADNL используется слово `address`, а, например, для поиска узлов шардчейна - `nodes`. Но типом ключа может быть любой массив байт, в зависимости от значения, которое вы ищете.

Заполнив эту схему, получаем:

```
8fde67f6                                                           -- TL ID dht.key
516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174   -- our searched ADNL address
07 61646472657373                                                  -- key type, the word "address" as an TL array of bytes
00000000                                                           -- index 0 because there is only 1 key
```

Далее - получаем идентификатор ключа, хэш sha256 из байтов, сериализованных выше. Это будет `b30af0538916421b46df4ce580bf3a29316831e0c3323a7f156df0236c5b2f75`

Теперь мы можем начать поиск. Для этого нам нужно выполнить запрос, который имеет [схему](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L197):

```tlb
dht.findValue key:int256 k:int = dht.ValueResult
```

`key` — это идентификатор нашего ключа DHT, а `k` — это "ширина" поиска, чем он меньше, тем точнее, но меньше потенциальных узлов для запроса. Максимальное k для узлов в TON — 10, обычно используется 6.

Давайте заполним эту структуру, сериализуем и отправим запрос с помощью схемы `adnl.message.query`. [Подробнее об этом можно прочитать в другой статье](/v3/documentation/network/protocols/adnl/adnl-udp#packet-structure-and-communication).

В ответ мы можем получить:

- `dht.valueNotFound` - если значение не найдено.
- `dht.valueFound` - если значение найдено на этом узле.

##### dht.valueNotFound

Если мы получим `dht.valueNotFound`, то ответ будет содержать список узлов, которые известны запрошенному нами узлу и максимально приближены к запрошенному нами ключу из списка известных ему узлов. В этом случае нам нужно подключиться и добавить полученные узлы в список известных нам.
После этого из списка всех известных нам узлов выбираем ближайший, доступный и еще не запрошенный и делаем к нему такой же запрос. И так до тех пор, пока не перепробуем все узлы в выбранном нами диапазоне или пока не перестанем получать новые узлы.

Давайте подробнее разберем поля ответа, используемые схемы:

```tlb
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.node id:PublicKey addr_list:adnl.addressList version:int signature:bytes = dht.Node;
dht.nodes nodes:(vector dht.node) = dht.Nodes;

dht.valueNotFound nodes:dht.nodes = dht.ValueResult;
```

`dht.nodes -> nodes` - список узлов DHT (массив).

У каждого узла есть `id`, который является его открытым ключом, обычно [pub.ed25519](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L47), используемым как ключ сервера для подключения к узлу через ADNL. Также у каждого узла есть список адресов `addr_list:adnl.addressList`, версия и подпись.

Нам нужно проверить подпись каждого узла, для этого мы считываем значение `signature` и устанавливаем поле в ноль (делаем его пустым массивом байтов). После - сериализуем структуру TL `dht.node` с пустой подписью и проверяем поле `signature`, которое было до опустошения.
Проверяем полученные сериализованные байты, используя открытый ключ из поля `id`. [Пример реализации](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/dht/client.go#L91)

Из списка `addrs:(vector adnl.Address)` берем адрес и пытаемся установить соединение ADNL UDP, в качестве ключа сервера используем `id`, который является открытым ключом.

Чтобы узнать "расстояние" до этого узла - нам нужно взять [идентификатор ключа](/v3/documentation/network/protocols/adnl/adnl-tcp#getting-key-id) из ключа из поля `id` и проверить расстояние операцией XOR из идентификатора ключа узла и нужного ключа.
Если расстояние достаточно мало, мы можем сделать тот же запрос к этому узлу. И так далее, пока не найдем значение или не останется новых узлов.

##### dht.valueFound

Ответ будет содержать само значение, полную информацию о ключе и, возможно, подпись (зависит от типа значения).

Давайте подробнее проанализируем поля ответа, используемые схемы:

```tlb
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.key id:int256 name:bytes idx:int = dht.Key;

dht.updateRule.signature = dht.UpdateRule;
dht.updateRule.anybody = dht.UpdateRule;
dht.updateRule.overlayNodes = dht.UpdateRule;

dht.keyDescription key:dht.key id:PublicKey update_rule:dht.UpdateRule signature:bytes = dht.KeyDescription;

dht.value key:dht.keyDescription value:bytes ttl:int signature:bytes = dht.Value; 

dht.valueFound value:dht.Value = dht.ValueResult;
```

Сначала проанализируем `key:dht.keyDescription`, это полное описание ключа, сам ключ и информация о том, кто и как может обновить значение.

- `key:dht.key` - ключ должен совпадать с тем, из которого мы взяли идентификатор ключа для поиска.
- `id:PublicKey` - открытый ключ владельца записи.
- `update_rule:dht.UpdateRule` - правило обновления записи.
- - `dht.updateRule.signature` - только владелец закрытого ключа может обновить запись, `signature` как ключа, так и значения должны быть действительными
- - `dht.updateRule.anybody` - все могут обновить запись, `signature` пустое и не проверяется
- - `dht.updateRule.overlayNodes` - узлы из одного и того же оверлея могут обновить ключ, используется для поиска узлов того же оверлея и добавления себя

###### dht.updateRule.signature

После прочтения описания ключа действуем в зависимости от `updateRule`, для случая поиска адреса ADNL тип всегда `dht.updateRule.signature`.
Проверяем подпись ключа так же, как и в прошлый раз, делаем подпись пустым массивом байтов, сериализуем и проверяем. После - повторяем то же самое для значения, т.е. для всего объекта `dht.value` (при этом возвращая ключевую подпись на место).

[Пример реализации](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/dht/client.go#L331)

###### dht.updateRule.overlayNodes

Используется для ключей, содержащих информацию о других узлах-шардах воркчейна в сети, значение всегда имеет структуру TL `overlay.nodes`.
Поле value должно быть пустым.

```tlb
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;
```

Для проверки на валидность мы должны проверить все `nodes` и для каждого проверить `signature` по его `id`, сериализовав структуру TL:

```tlb
overlay.node.toSign id:adnl.id.short overlay:int256 version:int = overlay.node.ToSign;
```

Как видим, id следует заменить на adnl.id.short, что является идентификатором ключа (хешем) поля `id` из исходной структуры. После сериализации - сверяем подпись с данными.

В результате получаем валидный список узлов, которые могут предоставить нам информацию о нужном нам шарде воркчейна.

###### dht.updateRule.anybody

Подписей нет, обновлять может кто угодно.

#### Использование значения

Когда все проверено и значение `ttl:int` не истекло, мы можем начать работать с самим значением, т. е. `value:bytes`. Для адреса ADNL внутри должна быть структура `adnl.addressList`.
В ней будут находиться ip-адреса и порты серверов, соответствующие запрашиваемому адресу ADNL. В нашем случае, скорее всего, будет 1 адрес RLDP-HTTP сервиса `foundation.ton`.
В качестве ключа сервера мы будем использовать открытый ключ `id:PublicKey` из информации о ключе DHT.

После установки соединения мы можем запрашивать страницы сайта по протоколу RLDP. Задача со стороны DHT на этом этапе выполнена.

### Поиск узлов, хранящих состояние блокчейна

DHT также используется для поиска информации об узлах, хранящих данные воркчейнов и их шардов. Процесс такой же, как и при поиске любого ключа, разница только в сериализации самого ключа и валидации ответа, эти моменты мы разберем в этом разделе.

Чтобы получить данные, например, мастерчейна и его шардов, нам нужно заполнить структуру TL:

```
tonNode.shardPublicOverlayId workchain:int shard:long zero_state_file_hash:int256 = tonNode.ShardPublicOverlayId;
```

Где `workchain` в случае мастерчейна будет равен -1, его шард будет равен -922337203685477580 (0xFFFFFFFFFFFFFFFF), а `zero_state_file_hash` - это хэш нулевого состояния цепочки (file_hash), как и другие данные, его можно взять из глобальной конфигурации сети, в поле `"validator"`

```json
"zero_state": {
  "workchain": -1,
  "shard": -9223372036854775808, 
  "seqno": 0,
  "root_hash": "F6OpKZKqvqeFp6CQmFomXNMfMj2EnaUSOXN+Mh+wVWk=",
  "file_hash": "XplPz01CXAps5qeSWUtxcyBfdAo5zVb1N979KLSKD24="
}
```

После того, как мы заполнили `tonNode.shardPublicOverlayId`, мы сериализуем его и получаем из него идентификатор ключа путем хэширования (как всегда).

Нам нужно использовать полученный идентификатор ключа как `name` для заполнения структуры `pub.overlay name:bytes = PublicKey`, обернув ее в массив байтов TL. Затем мы сериализуем его и получаем из него идентификатор ключа.

Полученный идентификатор будет ключом для использования в

```bash
dht.findValue
```

, а значение поля `name` будет словом `nodes`. Мы повторяем процесс из предыдущего раздела, все то же самое, что и в прошлый раз, но `updateRule` будет [dht.updateRule.overlayNodes](#dhtupdateruleoverlaynodes).

После проверки мы получим открытые ключи (`id`) узлов, которые содержат информацию о нашем воркчейне и шарде. Чтобы получить адреса ADNL узлов, нам нужно создать идентификаторы из ключей (используя метод хеширования) и повторить процедуру, описанную выше, для каждого из адресов ADNL, как и для адреса ADNL домена `foundation.ton`.

В результате мы получим адреса узлов, из которых, при желании, можно узнать адреса других узлов этой цепочки с помощью [overlay.getRandomPeers](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L237).
Также мы сможем получать всю информацию о блоках с этих узлов.

## Ссылки

*Вот [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/DHT.md) [Олега Баранова](https://github.com/xssnick).*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/dht/ton-dht.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/dht/ton-dht.md
================================================
# Сервис TON DHT

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Реализация:

- https://github.com/ton-blockchain/ton/tree/master/dht
- https://github.com/ton-blockchain/ton/tree/master/dht-server

## Общие сведения

Распределенная хэш-таблица (DHT - Distributed Hash Table), подобная Kademlia, играет важную роль в сетевой части проекта TON и используется для поиска других узлов в сети.

Ключи TON DHT — это просто 256-битные целые числа. В большинстве случаев они вычисляются как SHA256 TL-сериализованного объекта.

Значения, присвоенные этим 256-битным ключам, по сути, являются произвольными строками байтов ограниченной длины. Интерпретация
таких строк байтов определяется прообразом соответствующего ключа; обычно она известна как узлу, который ищет ключ, так и узлу,
который хранит ключ.

В простейшем случае ключ представляет собой адрес ADNL некоторого узла, а значение может быть его IP-адресом и портом.

Сопоставление ключ-значение TON DHT хранится на узлах DHT.

## Узлы DHT

Каждый узел DHT имеет 256-битный адрес DHT. В отличие от адреса ADNL, адрес DHT не должен меняться слишком часто, иначе другие узлы не смогут найти искомые ими ключи.

Ожидается, что значение ключа `K` будет храниться на `S` узлах Kademlia-ближайших к `K`.

Расстояние Kademlia = 256-битный ключ `XOR` 256-битный адрес узла DHT (это не имеет ничего общего с географическим положением).

`S` — небольшой параметр, например `S = 7`, который необходим для повышения надежности
DHT (если мы будем хранить ключ только на одном узле, ближайшем к `K`,
значение этого ключа будет потеряно, если этот узел выйдет из сети).

## Таблица маршрутизации Kademlia

Любой узел, участвующий в DHT, обычно поддерживает таблицу маршрутизации Kademlia.

Она состоит из 256 сегментов, пронумерованных от 0 до 255. `i`-тый
сегмент будет содержать информацию о некоторых известных узлах (фиксированное количество
"лучших" узлов и, возможно, несколько дополнительных кандидатов), которые находятся на расстоянии Kademlia от `2^i` до `2^(i+1) − 1` от адреса узла `a`.

Эта информация включает их адреса DHT, IP-адреса и порты UDP, а также некоторую информацию о доступности, такую ​​как время и задержка последнего пинга.

Когда узел Kademlia узнает о любом другом узле Kademlia в результате
какого-либо запроса, он помещает его в подходящую корзину своей таблицы маршрутизации,
сначала
как кандидата. Затем, если некоторые из "лучших" узлов в этой корзине выходят из строя (например,
не отвечают на ping запросы в течение длительного времени), их можно заменить некоторыми
из этих кандидатов. Таким образом, таблица маршрутизации Kademlia остается заполненной.

## Пары ключ-значение

Пары ключ-значение можно добавлять и обновлять в TON DHT.

"Правила обновления" могут различаться. В некоторых случаях они просто
разрешают замену старого значения новым значением, при условии, что новое значение
подписано владельцем/создателем (подпись должна храниться как часть значения, чтобы быть проверенной позже любыми другими узлами после того, как они получат значение этого ключа).
В других случаях старое значение каким-то образом влияет на новое значение. Например, он
может содержать порядковый номер, и старое значение перезаписывается только в том случае, если
новый порядковый номер больше (для предотвращения атак повторного использования).

TON DHT используется не только для хранения IP-адресов узлов ADNL, но также для других целей — он может хранить список адресов узлов, которые хранят определенный торрент в хранилище TON Storage, список адресов узлов, входящих в оверлейную подсеть, ADNL-адреса сервисов TON или ADNL-адреса аккаунтов блокчейна TON и т. д.

:::info
Узнайте больше о TON DHT в статье [DHT](/v3/documentation/network/protocols/dht/dht-deep-dive) или в главе 3.2. документа [TON Whitepaper](https://docs.ton.org/ton.pdf).
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/overlay.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/overlay.md
================================================
# Оверлейные подсети

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Реализация:

- https://github.com/ton-blockchain/ton/tree/master/overlay

## Общие сведения

Архитектура TON построена таким образом, что в ней одновременно и независимо может существовать множество цепочек — они могут быть как частными, так и общедоступными.
Узлы имеют возможность выбирать, какие шарды и цепочки они хранят и обрабатывают.
При этом протокол связи остается неизменным из-за своей универсальности. Такие протоколы, как DHT, RLDP и Оверлеи, позволяют этого добиться.
С первыми двумя мы уже знакомы, в этом разделе мы узнаем, что такое Оверлеи.

Оверлеи отвечают за разделение единой сети на дополнительные подсети. Оверлеи могут быть как общедоступными, к которым может подключиться любой желающий, так и частными, где для входа требуются дополнительные учетные данные, известные только определенному кругу лиц.

Все чейны в TON, включая мастерчейн, общаются с помощью собственного оверлея.
Чтобы присоединиться к нему, нужно найти узлы, которые уже состоят в нем, и начать обмениваться с ними данными.
Для общедоступных оверлеев вы можете найти узлы с помощью DHT.

## ADNL против оверлейных сетей

В отличие от ADNL, оверлейные сети TON обычно не поддерживают
отправка датаграмм на другие произвольные узлы. Вместо этого между определенными узлами устанавливаются некоторые “полупостоянные
соединения” (называемые “соседними” по отношению к
рассматриваемой оверлейной сети), и сообщения обычно пересылаются
по этим соединениям (т.е. от узла к одному из его соседей).

Каждая оверлейная подсеть имеет 256-разрядный сетевой идентификатор, обычно равный SHA256 описания оверлейной сети — TL-сериализованного объекта.

Оверлейные подсети могут быть общедоступными или частными.

Оверлейные подсети работают по специальному протоколу [gossip](https://ru.wikipedia.org/wiki/Gossip_\\(%D0%Bf%D1%80%D0%Be%D1%82%D0%Be%D0%Ba%D0%Be%D0%Bb\\)).

## Взаимодействие с оверлейными узлами

Мы уже разбирали пример с поиском оверлейных узлов в статье о DHT,
в разделе [Поиск узлов, хранящих состояние блокчейна](/v3/documentation/network/protocols/dht/dht-deep-dive#search-for-nodes-that-store-the-state-of-the-blockchain).
В этом разделе мы сосредоточимся на взаимодействии с ними.

При запросе DHT мы получим адреса оверлейных узлов, из которых мы можем узнать адреса других узлов этого оверлея с помощью запроса [overlay.getRandomPeers](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L237).
Как только мы подключимся к достаточному количеству узлов, мы сможем получать от них всю информацию о блоках и другие события чейна, а также отправлять им наши транзакции для обработки.

### Найдите больше соседей

Давайте рассмотрим пример получения узлов в оверлее.

Для этого отправьте запрос `overlay.getRandomPeers` на любой известный узел оверлея, сериализуйте схему TL:

```tlb
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;

overlay.getRandomPeers peers:overlay.nodes = overlay.Nodes;
```

`peers` - должен содержать известные нам пиры, поэтому мы не получаем их обратно, но поскольку мы пока не знаем ни одного, `peers.nodes` будет пустым массивом.

В случае, если мы хотим не просто получить какую-то информацию, а участвовать в оверлее и получать трансляции, мы также должны добавить в `peers` информацию о нашем узле, с которого мы делаем запрос.
Когда пиры получат информацию о нас - они начнут отправлять нам широковещательные сообщения с помощью ADNL или RLDP.

Каждый запрос внутри оверлея должен иметь префикс TL-схемы:

```tlb
overlay.query overlay:int256 = True;
```

`overlay` должен быть идентификатором оверлея - идентификатором ключа схемы `tonNode.ShardPublicOverlayId` - тем же, который мы использовали для поиска в DHT.

Нам нужно объединить 2 сериализованные схемы, просто объединив 2 сериализованных байтовых массива, `overlay.query` будет первым, `overlay.getRandomPeers` - вторым.

Мы оборачиваем полученный массив в схему `adnl.message.query` и отправляем ее через ADNL. В ответе ждем `overlay.nodes` - это будет список узлов оверлея, к которым мы можем подключиться и, при необходимости, повторить тот же запрос к новым из них, пока не получим достаточное количество подключений.

### Функциональные запросы

После того, как соединение установлено, мы можем получить доступ к оверлейным узлам с помощью [запросов](https://github.com/ton-blockchain/ton/blob/ad736c6bc3c06ad54dc6e40d62acbaf5dae41584/tl/generate/scheme/ton_api.tl#L413) `tonNode.*`.

Для запросов такого рода используется протокол RLDP. И важно не забыть префикс `overlay.query` - он должен использоваться для каждого запроса в оверлее.

В самих запросах нет ничего необычного, они очень похожи на то, что мы [делали в статье про ADNL TCP](/v3/documentation/network/protocols/adnl/adnl-tcp#getmasterchaininfo).

Например, запрос `downloadBlockFull` использует уже знакомую схему идентификатора блока:

```tlb
tonNode.downloadBlockFull block:tonNode.blockIdExt = tonNode.DataFull;
```

Передав его, мы сможем загрузить полную информацию о блоке, в ответ получим:

```tlb
tonNode.dataFull id:tonNode.blockIdExt proof:bytes block:bytes is_link:Bool = tonNode.DataFull;
  or
tonNode.dataFullEmpty = tonNode.DataFull;
```

Если присутствует, поле `block` будет содержать данные в формате TL-B.

Таким образом, мы можем получать информацию напрямую с узлов.

## Ссылки

*Вот [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/Overlay-Network.md) [Олега Баранова](https://github.com/xssnick).*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/rldp.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/network/protocols/rldp.md
================================================
# RLDP

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Реализация:

- https://github.com/ton-blockchain/ton/tree/master/rldp
- https://github.com/ton-blockchain/ton/tree/master/rldp2
- https://github.com/ton-blockchain/ton/tree/master/rldp-http-proxy

## Общие сведения

Надежный протокол передачи больших датаграмм (RLDP - Reliable Large Datagram Protocol) — это протокол, работающий поверх ADNL UDP, который используется для передачи больших блоков данных и
включает алгоритмы прямой коррекции ошибок (FEC - Forward Error Correction) в качестве замены пакетов подтверждения на другой стороне.
Это позволяет передавать данные между сетевыми компонентами более эффективно, но с большим потреблением трафика.

RLDP используется везде в инфраструктуре TON, например, для загрузки блоков с других узлов и передачи им данных,
для доступа к сайтам TON и хранилищу TON.

## Протокол

RLDP использует следующие структуры TL для обмена данными:

```tlb
fec.raptorQ data_size:int symbol_size:int symbols_count:int = fec.Type;
fec.roundRobin data_size:int symbol_size:int symbols_count:int = fec.Type;
fec.online data_size:int symbol_size:int symbols_count:int = fec.Type;

rldp.messagePart transfer_id:int256 fec_type:fec.Type part:int total_size:long seqno:int data:bytes = rldp.MessagePart;
rldp.confirm transfer_id:int256 part:int seqno:int = rldp.MessagePart;
rldp.complete transfer_id:int256 part:int = rldp.MessagePart;

rldp.message id:int256 data:bytes = rldp.Message;
rldp.query query_id:int256 max_answer_size:long timeout:int data:bytes = rldp.Message;
rldp.answer query_id:int256 data:bytes = rldp.Message;
```

Сериализованная структура оборачивается в схему TL `adnl.message.custom` и отправляется по ADNL UDP.
Передачи RLDP используются для передачи больших данных, генерируется случайный `transfer_id`, а сами данные обрабатываются алгоритмом FEC.
Результирующие фрагменты оборачиваются в структуру `rldp.messagePart` и отправляются одноранговому узлу до тех пор, пока одноранговый узел не отправит нам `rldp.complete` или пока не истечет время ожидания.

Когда получатель собрал фрагменты `rldp.messagePart`, необходимые для сборки полного сообщения, он объединяет их все вместе, декодирует с помощью FEC и
десериализует полученный массив байтов в одну из структур `rldp.query` или `rldp.answer` в зависимости от типа (идентификатор префикса tl).

### FEC

Допустимыми алгоритмами прямой коррекции ошибок для использования с RLDP являются RoundRobin, Online и RaptorQ.
В настоящее время для кодирования данных используется [RaptorQ](https://www.qualcomm.com/media/documents/files/raptorq-technical-overview.pdf).

#### RaptorQ

Суть RaptorQ заключается в том, что данные разделяются на так называемые символы — блоки одинакового, заранее определенного размера.

Из блоков создаются матрицы, и к ним применяются дискретные математические операции. Это позволяет нам создавать практически бесконечное количество символов
из одних и тех же данных. Все символы перемешиваются, и можно восстанавливать потерянные пакеты, не запрашивая дополнительных данных с сервера, при этом используя меньше пакетов, чем если бы мы отправляли те же самые фрагменты в цикле.

Сгенерированные символы отправляются одноранговому узлу до тех пор, пока он не сообщит, что все данные получены и восстановлены (декодированы) путем применения тех же дискретных операций.

[Пример реализации RaptorQ в Golang](https://github.com/xssnick/tonutils-go/tree/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/rldp/raptorq)

## RLDP-HTTP

Для взаимодействия с сайтами TON используется HTTP, обернутый в RLDP. Хостер запускает свой сайт на любом HTTP-сервере и запускает rldp-http-proxy рядом с ним.
Все запросы из сети TON поступают по протоколу RLDP на прокси, а прокси пересобирает запрос в простой HTTP и локально вызывает исходный веб-сервер.

Пользователь на своей стороне запускает прокси, например, [Tonutils Proxy](https://github.com/xssnick/TonUtils-Proxy), и использует сайты `.ton`, весь трафик оборачивается в обратном порядке, запросы идут на локальный HTTP-прокси, а он отправляет их через RLDP на удаленный сайт TON.

HTTP внутри RLDP реализован с использованием структур TL:

```tlb
http.header name:string value:string = http.Header;
http.payloadPart data:bytes trailer:(vector http.header) last:Bool = http.PayloadPart;
http.response http_version:string status_code:int reason:string headers:(vector http.header) no_payload:Bool = http.Response;

http.request id:int256 method:string url:string http_version:string headers:(vector http.header) = http.Response;
http.getNextPayloadPart id:int256 seqno:int max_chunk_size:int = http.PayloadPart;
```

Это не чистый HTTP в текстовом виде, все обернуто в двоичный TL и развернуто обратно для отправки на веб-сервер или браузер самим прокси.

Схема работы следующая:

- Клиент отправляет `http.request`.
- Сервер проверяет заголовок `Content-Length` при получении запроса
- - Если не 0, то отправляет клиенту запрос `http.getNextPayloadPart`
- - При получении запроса клиент отправляет `http.payloadPart` - запрашиваемый кусок тела в зависимости от `seqno` и `max_chunk_size`.
- - Сервер повторяет запросы, увеличивая `seqno`, пока не получит все куски от клиента, т. е. пока поле `last:Bool` последнего полученного куска не станет истинным.
- После обработки запроса сервер отправляет `http.response`, клиент проверяет заголовок `Content-Length`
- - Если он не 0, то отправляет серверу запрос `http.getNextPayloadPart`, и операции повторяются, как и в случае с клиентом, но наоборот.

## Запрос TON сайта

Чтобы понять, как работает RLDP, давайте рассмотрим пример получения данных с сайта TON `foundation.ton`.
Допустим, мы уже получили его адрес ADNL, вызвав метод Get контракта NFT-DNS, [определили адрес и порт службы RLDP с помощью DHT](https://github.com/xssnick/ton-deep-doc/blob/master/DHT.md) и [подключились к ней по ADNL UDP](https://github.com/xssnick/ton-deep-doc/blob/master/ADNL-UDP-Internal.md).

### Отправьте запрос GET на `foundation.ton`

Для этого заполните структуру:

```tlb
http.request id:int256 method:string url:string http_version:string headers:(vector http.header) = http.Response;
```

Сериализуйте "http.request", заполнив соответствующие поля:

```
e191b161                                                           -- TL ID http.request      
116505dac8a9a3cdb464f9b5dd9af78594f23f1c295099a9b50c8245de471194   -- id           = {random}
03 474554                                                          -- method       = string `GET`
16 687474703a2f2f666f756e646174696f6e2e746f6e2f 00                 -- url          = string `http://foundation.ton/`
08 485454502f312e31 000000                                         -- http_version = string `HTTP/1.1`
01000000                                                           -- headers (1)
   04 486f7374 000000                                              -- name         = Host
   0e 666f756e646174696f6e2e746f6e 00                              -- value        = foundation.ton
```

Теперь обернем наш сериализованный `http.request` в `rldp.query` и также сериализуем его:

```
694d798a                                                              -- TL ID rldp.query
184c01cb1a1e4dc9322e5cabe8aa2d2a0a4dd82011edaf59eb66f3d4d15b1c5c      -- query_id        = {random}
0004040000000000                                                      -- max_answer_size = 257 KB, can be any sufficient size that we accept as headers
258f9063                                                              -- timeout (unix)  = 1670418213
34 e191b161116505dac8a9a3cdb464f9b5dd9af78594f23f1c295099a9b50c8245   -- data (http.request)
   de4711940347455416687474703a2f2f666f756e646174696f6e2e746f6e2f00
   08485454502f312e310000000100000004486f73740000000e666f756e646174
   696f6e2e746f6e00 000000
```

### Кодирование и отправка пакетов

Теперь нам нужно применить алгоритм FEC RaptorQ к этим данным.

Создадим кодировщик, для этого нам нужно превратить полученный массив байтов в символы фиксированного размера. В TON размер символа составляет 768 байт.
Для этого разобьем массив на части по 768 байт. В последней части, если она получится меньше 768, ее нужно будет дополнить нулевыми байтами до нужного размера.

Наш массив размером 156 байт, значит будет всего 1 фрагмент, и нам нужно дополнить его 612 нулевыми байтами до размера 768.

Также для кодировщика подбираются константы в зависимости от размера данных и символа, подробнее об этом можно узнать в документации самого RaptorQ, но чтобы не лезть в математические дебри, рекомендую использовать готовую библиотеку, реализующую такое кодирование.
[Пример создания кодировщика](https://github.com/xssnick/tonutils-go/blob/46dbf5f820af066ab10c5639a508b4295e5aa0fb/adnl/rldp/raptorq/encoder.go#L15) и [Пример кодировки символа](https://github.com/xssnick/tonutils-go/blob/be3411cf412f23e6889bf0b648904306a15936e7/adnl/rldp/raptorq/solver.go#L26).

Символы кодируются и отправляются в циклическом режиме: изначально мы определяем `seqno`, который равен 0, и увеличиваем его на 1 для каждого последующего кодированного пакета. Например, если у нас есть 2 символа, то мы кодируем и отправляем первый, увеличиваем seqno на 1, затем второй и увеличиваем seqno на 1, затем снова первый и увеличиваем seqno, который в этот момент уже равен 2, еще на 1.
И так до тех пор, пока не получим сообщение о том, что пир принял данные.

Теперь, когда мы создали кодировщик, мы готовы отправлять данные, для этого заполним схему TL:

```tlb
fec.raptorQ data_size:int symbol_size:int symbols_count:int = fec.Type;

rldp.messagePart transfer_id:int256 fec_type:fec.Type part:int total_size:long seqno:int data:bytes = rldp.MessagePart;
```

- `transfer_id` - случайное int256, одинаковое для всех messageParts в рамках одной передачи данных.
- `fec_type` - это `fec.raptorQ`.
- - `data_size` = 156
- - `symbol_size` = 768
- - `symbols_count` = 1
- `part` в нашем случае всегда 0, может использоваться для передач, которые достигли ограничения по размеру.
- `total_size` = 156. Размер наших передаваемых данных.
- `seqno` - для первого пакета будет равен 0, а для каждого последующего пакета он будет увеличиваться на 1, будет использоваться как параметр для декодирования и кодирования символа.
- `data` - наш закодированный символ, размером 768 байт.

После сериализации `rldp.messagePart`, оберните его в `adnl.message.custom` и отправьте по ADNL UDP.

Мы отправляем пакеты в цикле, все время увеличивая seqno, пока не дождемся сообщения `rldp.complete` от пира или не остановимся по таймауту. После того, как мы отправили количество пакетов, равное количеству наших символов, мы можем замедлиться и отправить дополнительный пакет, например, раз в 10 миллисекунд или меньше.
Дополнительные пакеты используются для восстановления в случае потери данных, так как UDP - быстрый, но ненадежный протокол.

[Пример реализации](https://github.com/xssnick/tonutils-go/blob/be3411cf412f23e6889bf0b648904306a15936e7/adnl/rldp/rldp.go#L249)

### Обработка ответа от `foundation.ton`.

Во время отправки мы уже можем ожидать ответа от сервера, в нашем случае мы ждем `rldp.answer` с `http.response` внутри.
Он придет к нам таким же образом, в виде RLDP-передачи, как и был отправлен во время запроса, но `transfer_id` будет инвертирован (каждый байт XOR 0xFF).
Мы получим сообщения `adnl.message.custom`, содержащие `rldp.messagePart`.

Сначала нам нужно получить информацию FEC из первого полученного сообщения передачи, а именно параметры `data_size`, `symbol_size` и `symbols_count` из структуры messagePart `fec.raptorQ`.
Они нам нужны для инициализации декодера RaptorQ. [Пример](https://github.com/xssnick/tonutils-go/blob/be3411cf412f23e6889bf0b648904306a15936e7/adnl/rldp/rldp.go#L137)

После инициализации мы добавляем полученные символы с их `seqno` в наш декодер, и как только мы накопим минимально необходимое число, равное `symbols_count`, мы можем попытаться декодировать полное сообщение. В случае успеха мы отправим `rldp.complete`. [Пример](https://github.com/xssnick/tonutils-go/blob/be3411cf412f23e6889bf0b648904306a15936e7/adnl/rldp/rldp.go#L168)

Результатом будет сообщение `rldp.answer` с тем же query_id, что и в отправленном нами `rldp.query`. Данные должны содержать `http.response`.

```tlb
http.response http_version:string status_code:int reason:string headers:(vector http.header) no_payload:Bool = http.Response;
```

С основными полями, я думаю, все понятно, суть та же, что и в HTTP.
Интересный флаг здесь - `no_payload`, если он равен true, то тела в ответе нет, (`Content-Length` = 0).
Ответ от сервера можно считать полученным.

Если `no_payload` = false, то в ответе есть контент, и нам нужно его получить.
Для этого нам нужно отправить запрос со схемой TL `http.getNextPayloadPart`, обернутой в `rldp.query`.

```tlb
http.getNextPayloadPart id:int256 seqno:int max_chunk_size:int = http.PayloadPart;
```

`id` должен быть таким же, как мы отправили в `http.request`, `seqno` - 0 и +1 для каждой следующей части. `max_chunk_size` - максимальный размер фрагмента, который мы готовы принять, обычно используется 128 КБ (131072 байта).

В ответ мы получим:

```tlb
http.payloadPart data:bytes trailer:(vector http.header) last:Bool = http.PayloadPart;
```

Если `last` = true, то мы достигли конца, мы можем собрать все части вместе и получить полное тело ответа, например, html.

## Ссылки

*Вот [ссылка на оригинальную статью](https://github.com/xssnick/ton-deep-doc/blob/master/RLDP.md) [Олега Баранова](https://github.com/xssnick).*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/addresses.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/addresses.md
================================================
# Документация по адресам смарт-контрактов

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В этом разделе описываются особенности адресов смарт-контрактов в блокчейне TON. Он также объясняет, как акторы являются синонимами смарт-контрактов в TON.

## Всё является смарт-контрактом

В TON смарт-контракты создаются с использованием [акторной модели](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#single-actor). Фактически, акторы в TON технически представлены как смарт-контракты. Это означает, что даже ваш кошелек является простым актором (и смарт-контрактом).

Обычно акторы обрабатывают входящие сообщения, изменяют свои внутренние состояния и в результате генерируют исходящие сообщения. Вот почему каждый субъект (т. е. актор-контракт) в блокчейне TON должен иметь адрес, чтобы он мог получать сообщения от других акторов.

:::info ОПЫТ EVM
В виртуальной машине Ethereum (EVM) адреса полностью отделены от смарт-контрактов. Не стесняйтесь узнать больше о различиях, прочитав нашу статью ["Шесть уникальных аспектов блокчейна TON, которые удивят разработчиков Solidity"](https://blog.ton.org/six-unique-aspects-of-ton-blockchain-that-will-surprise-solidity-developers) от Тала Кола.
:::

## Адрес смарт-контракта

Адреса смарт-контрактов в TON обычно состоят из двух основных компонентов:

- **(workchain_id)**: Обозначает идентификатор воркчейна (подписанное 32-битное целое число)

- **(account_id)** Обозначает адрес аккаунта (64-512 бит, в зависимости от воркчейна)

В разделе обзора необработанных адресов этой документации мы обсудим, как представлены пары **(workchain_id, account_id)**.

### Идентификатор воркчейна и идентификатор аккаунта

#### Идентификатор воркчейна

[Как мы уже видели ранее](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains#workchain-blockchain-with-your-own-rules), можно создать до `2^32` воркчейнов, работающих на блокчейне TON. Мы также отметили, как 32-битные префиксные адреса смарт-контрактов идентифицируют и связываются с адресами смарт-контрактов в разных воркчейнов. Это позволяет смарт-контрактам отправлять и получать сообщения в разные воркчейны на блокчейне TON и из них.

В настоящее время в блокчейне TON работают только Мастерчейн (workchain_id=-1) и иногда базовый воркчейн (workchain_id=0).

Оба имеют 256-битные адреса, поэтому мы предполагаем, что workchain_id равен 0 или -1, а адрес внутри воркчейна равен ровно 256 битам.

#### Идентификатор аккаунта

Все идентификаторы аккаунтов в TON используют 256-битные адреса в мастерчейне и бейстчейне (также называемым базовым воркчейном).

Фактически, идентификатор учетной записи (**account_id**) определяется как результат применения хэш-функции (в частности, SHA-256) к объекту смарт-контракта. Каждый смарт-контракт, работающий на блокчейне TON, хранит два основных компонента:

1. *Скомпилированный код*. Логика смарт-контракта, скомпилированная в байт-код.
2. *Начальное состояние*. Значения контракта на момент его развертывания в цепочке.

Чтобы получить адрес контракта, вы вычисляете хэш пары **(Начальный код, Начальное состояние)**. Мы не будем сейчас изучать, как работает [TVM](/v3/documentation/tvm/tvm-overview), но важно понимать, что идентификаторы аккаунтов в TON следуют этой формуле:

**account_id = хэш(начальный код, начальное состояние)**

Далее в этой документации мы более подробно рассмотрим технические характеристики схемы TVM и TL-B. Теперь, когда мы знакомы с тем, как генерируется **account_id** и как он взаимодействует с адресами смарт-контрактов в TON, давайте обсудим необработанные и удобные для пользователя адреса.

## Состояние адресов

Каждый адрес может находиться в одном из возможных состояний:

- `nonexist` - по этому адресу не было принятых транзакций, поэтому на нем нет никаких данных (или контракт был удален). Можно сказать, что изначально все 2<sup>256</sup> адреса находятся в этом состоянии.
- `uninit` - адрес имеет некоторые данные, которые содержат баланс и метаданные. В этом состоянии адрес еще не имеет кода смарт-контракта/постоянных данных. Адрес переходит в это состояние, например, когда он был в несуществующем состоянии, а другой адрес отправлял ему токены.
- `active` - адрес имеет код смарт-контракта, постоянные данные и баланс. В этом состоянии он может выполнять некоторую логику во время транзакции и изменять свои постоянные данные. Адрес переходит в это состояние, когда он был `uninit` и было входящее сообщение с параметром state_init (обратите внимание, что для возможности развертывания этого адреса хэш `state_init` и `code` должен быть равен адресу).
- `frozen` - адрес не может выполнять никаких операций, это состояние содержит только два хеша предыдущего состояния (ячейки кода и состояния соответственно). Когда стоимость хранения адреса превышает его баланс, он переходит в это состояние. Чтобы разморозить его, вы можете отправить внутреннее сообщение с `state_init` и `code`, в которых хранятся хэши, описанные ранее, и немного Toncoin. Восстановить его может быть сложно, поэтому вы не должны допускать такой ситуации. Существует проект по разморозке адреса, который вы можете найти [здесь](https://unfreezer.ton.org/).

## Необработанные и удобные для пользователя адреса

После краткого обзора того, как адреса смарт-контрактов в TON используют воркчейны и идентификаторы аккаунтов (в частности, для мастерчейна и бейсчейна), важно понимать, что эти адреса выражаются в двух основных форматах:

- **Необработанные адреса**: Исходное полное представление адресов смарт-контрактов.
- **Удобные для пользователя адреса**: Удобные для пользователя адреса — это расширенный формат необработанных адресов, которые обеспечивают лучшую безопасность и простоту использования.

Ниже мы подробнее объясним различия между этими двумя типами адресов и подробнее рассмотрим, почему удобные для пользователя адреса используются в TON.

### Необработанные адреса

Исходные адреса смарт-контрактов состоят из идентификатора воркчейна и идентификатора аккаунта *(workchain_id, account_id)* и отображаются в следующем формате:

- [десятичный workchain_id\]:[64 шестнадцатеричных цифры с account_id\]

Ниже представлен пример необработанного адреса смарт-контракта, использующего идентификатор воркчейна и идентификатор аккаунта вместе (выраженный как **workchain_id** и **account_id**):

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

Обратите внимание на `-1` в начале строки адреса, который обозначает *workchain_id*, принадлежащий мастерчейну.

:::note
В строках адресов можно использовать заглавные буквы (такие как 'A', 'B', 'C', 'D' и т. д.) вместо строчных букв (например, 'a', 'b', 'c', 'd' и т. д.).
:::

#### Проблемы с необработанными адресами

Использование формы необработанного адреса создает две основные проблемы:

1. При использовании формата необработанного адреса невозможно проверить адреса для устранения ошибок перед отправкой транзакции.
   Это означает, что если вы случайно добавите или удалите символы в адресной строке до отправки транзакции, ваша транзакция будет отправлена ​​по неправильному адресу, что приведет к потере средств.
2. При использовании формата необработанного адреса невозможно добавлять специальные флаги, подобные тем, которые используются при отправке транзакций с использованием удобных для пользователя адресов.
   Чтобы помочь вам лучше понять эту концепцию, мы объясним ниже, какие флаги можно использовать.

### Удобные для пользователя адреса

Удобные для пользователя адреса были разработаны для защиты и упрощения опыта для пользователей TON, которые делятся адресами в Интернете (например, на публичных платформах обмена сообщениями или через своих поставщиков услуг электронной почты), а также в реальном мире.

#### Удобная для пользователя структура адресов

Удобные для пользователя адреса состоят из 36 байтов в общей сложности и получаются путем генерации следующих компонентов в следующем порядке:

1. *[флаги - 1 байт]* — Флаги, закрепленные за адресами, изменяют способ реакции смарт-контрактов на полученное сообщение.
   Типы флагов, которые используют удобный для пользователя формат адреса, включают:

   - isBounceable. Обозначает тип адреса, допускающий или не допускающий отклонений. (*0x11* для "отклоняемого", *0x51* для "не отклоняемого")
   - isTestnetOnly. Обозначает тип адреса, используемый только для целей тестовой сети. Адреса, начинающиеся с *0x80*, не должны приниматься программным обеспечением, работающим в рабочей сети
   - isUrlSafe. Обозначает устаревший флаг, который определен как безопасный для URL для адреса. Все адреса затем считаются безопасными для URL.
2. *\[workchain_id - 1 байт]* — идентификатор воркчейна (*workchain_id*) определяется 8-битным целым числом со знаком *workchain_id*.
   (*0x00* для Бейсчейна, *0xff* для Мастерчейна)
3. *\[account_id - 32 байта]* — идентификатор аккаунта состоит ([от большего к меньшему](https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/)) 256-битного адреса в воркчейне.
4. *\[проверка адреса - 2 байта]* — В удобных для пользователя адресах проверка адреса состоит из подписи CRC16-CCITT из предыдущих 34 байтов. ([Пример](https://github.com/andreypfau/ton-kotlin/blob/ce9595ec9e2ad0eb311351c8a270ef1bd2f4363e/ton-kotlin-crypto/common/src/crc32.kt))
   Фактически, идея, касающаяся проверки удобных для пользователя адресов, очень похожа на [алгоритм Луна](https://en.wikipedia.org/wiki/Luhn_algorithm), который используется на всех кредитных картах, чтобы пользователи не вводили по ошибке несуществующие номера карт.

Добавление этих 4 основных компонентов означает, что: `1 + 1 + 32 + 2 = 36` байтов в общей сложности (на удобный для пользователя адрес).

Чтобы сгенерировать удобный для пользователя адрес, разработчик должен закодировать все 36 байтов, используя либо:

- *base64* (т. е. с цифрами, заглавными и строчными латинскими буквами, '/' и '+')
- *base64url* (с '_' и '-' вместо '/' и '+')

После завершения этого процесса завершается генерация удобного для пользователя адреса длиной 48 неразделенных символов.

:::info ФЛАГИ DNS-АДРЕСОВ
В TON DNS-адреса, такие как mywallet.ton, иногда используются вместо необработанных и удобных для пользователя адресов. DNS-адреса состоят из удобных для пользователя адресов и включают все необходимые флаги, которые позволяют разработчикам получать доступ ко всем флагам из записи DNS в домене TON.
:::

#### Примеры кодировки адресов, удобных для пользователя

Например, смарт-контракт "test giver" (специальный смарт-контракт, находящийся в тестовой сети мастерчейна, который отправляет 2 тестовых токена всем, кто их запрашивает) использует следующий необработанный адрес:

`-1:fcb91a3a3816d0f7b8c2c76108b8a9bc5a6b7a55bd79f8ab101c52db29232260`

Вышеуказанный необработанный адрес "test giver" необходимо преобразовать в удобную для пользователя форму адреса. Это достигается с помощью форм base64 или base64url (которые мы представили ранее) следующим образом:

- `kf/8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15+KsQHFLbKSMiYIny` (base64)
- `kf_8uRo6OBbQ97jCx2EIuKm8Wmt6Vb15-KsQHFLbKSMiYIny` (base64url)

:::info
Обратите внимание, что обе формы (*base64* и *base64url*) являются допустимыми и должны быть приняты!
:::

#### Адреса с возможностью отклонения и без него

Основная идея флага адреса с возможностью отклонений — безопасность средств отправителя.

Например, если целевой смарт-контракт не существует или если во время транзакции возникнет проблема, сообщение будет"отклонено" обратно отправителю и составит остаток от исходной стоимости транзакции (за вычетом всех комиссий за перевод и газ).
Что касается адресов с возможностью отклонений, в частности:

1. Флаг **bounceable=false** обычно означает, что получатель — это кошелек.
2. Флаг **bounceable=true** обычно обозначает пользовательский смарт-контракт с собственной логикой приложения (например, DEX). В этом примере невозвратные сообщения не должны отправляться из соображений безопасности.

Не стесняйтесь читать больше по этой теме в нашей документации, чтобы лучше понять [невозвратные сообщения](/v3/documentation/smart-contracts/message-management/non-bounceable-messages).

#### Представления бронированного base64

Дополнительные двоичные данные, связанные с блокчейном TON, используют похожие "бронированные" удобные для пользователя представления адресов base64. Они отличаются друг от друга в зависимости от первых 4 символов их байтового тега. Например, 256-битные открытые ключи Ed25519 представляются путем создания сначала 36-байтовой последовательности с использованием следующего процесса в следующем порядке:

- Однобайтовый тег с использованием формата *0x3E* обозначает открытый ключ
- Однобайтовый тег с использованием формата *0xE6* обозначает открытый ключ Ed25519
- 32 байта, содержащих стандартное двоичное представление открытого ключа Ed25519
- 2 байта, содержащих от большего к меньшему представление CRC16-CCITT предыдущих 34 байтов

Полученная 36-байтовая последовательность преобразуется в 48-символьную строку base64 или base64url стандартным способом. Например, открытый ключ Ed25519 `E39ECDA0A7B0C60A7107EC43967829DBE8BC356A49B9DFC6186B3EAC74B5477D` (обычно представленный последовательностью из 32 байтов, например: `0xE3, 0x9E, ..., 0x7D`) представляется через "бронированное" представление следующим образом:

`Pubjns2gp7DGCnEH7EOWeCnb6Lw1akm538YYaz6sdLVHfRB2`

### Преобразование удобных для пользователя адресов и необработанных адресов

Самый простой способ преобразования удобных для пользователя и необработанных адресов — это использование одного из нескольких API TON и других инструментов, включая:

- [ton.org/address](https://ton.org/address)
- [Метод dton.io API](https://dton.io/api/address/0:867ac2b47d1955de6c8e23f57994fad507ea3bcfe2a7d76ff38f29ec46729627)
- [Методы API toncenter в основной сети](https://toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)
- [методы API toncenter в тестовой сети](https://testnet.toncenter.com/api/v2/#/accounts/pack_address_packAddress_get)

Кроме того, существует два способа преобразования удобных для пользователя и необработанных адресов для кошельков с помощью JavaScript:

- [Преобразование адреса из/в удобную для пользователя или необработанную форму с помощью ton.js](https://github.com/ton-org/ton-core/blob/main/src/address/Address.spec.ts)
- [Преобразование адреса из/в удобную для пользователя или необработанную форму с помощью tonweb](https://github.com/toncenter/tonweb/tree/master/src/utils#address-class)

Также возможно использовать аналогичные механизмы с помощью [SDK](/v3/guidelines/dapps/apis-sdks/sdk).

### Примеры адресов

Узнайте больше примеров адресов TON в [Кулинарной книге TON](/v3/guidelines/dapps/cookbook#working-with-contracts-addresses).

## Возможные проблемы

При взаимодействии с блокчейном TON важно понимать последствия перевода монет TON на адреса кошельков `uninit`. В этом разделе описываются различные сценарии и их результаты, чтобы прояснить, как обрабатываются такие транзакции.

### Что происходит, когда вы переводите Toncoin на адрес uninit?

#### Транзакция с включенным `state_init`

Если вы включаете `state_init` (состоящий из кода и данных кошелька или смарт-контракта) в свою транзакцию. Смарт-контракт сначала развертывается с использованием предоставленного `state_init`. После развертывания входящее сообщение обрабатывается аналогично отправке на уже инициализированный аккаунт.

#### Транзакция без установленных флагов `state_init` и `bounce`

Сообщение не может быть доставлено на смарт-контракт `uninit`, и оно будет возвращено отправителю. После вычета потребленных сборов за газ оставшаяся сумма возвращается на адрес отправителя.

#### Транзакция без флагов `state_init` и `bounce`

Сообщение не может быть доставлено, но оно не вернется обратно к отправителю. Вместо этого отправленная сумма будет зачислена на адрес получателя, увеличивая его баланс, даже если кошелек еще не инициализирован. Они будут храниться там до тех пор, пока владелец адреса не развернет контракт смарт-кошелька, после чего он сможет получить доступ к балансу.

#### Как это сделать правильно

Лучший способ развернуть кошелек — отправить немного TON на его адрес (который еще не инициализирован) со снятым флагом `bounce`. После этого шага владелец может развернуть и инициализировать кошелек, используя средства на текущем неинициализированном адресе. Этот шаг обычно выполняется при первой операции с кошельком.

### Блокчейн TON реализует защиту от ошибочных транзакций

ВВ блокчейне TON стандартные кошельки и приложения автоматически управляют сложностями транзакций по неинициализированным адресам, используя доступные и недоступные адреса, которые описаны [здесь](#bounceable-vs-non-bounceable-addresses). Обычной практикой для кошельков при отправке монет на неинициализированные адреса является отправка монет как на адреса с возможностью возврата, так и на адреса, не подлежащие возврату, без возврата.

Если вам нужно быстро получить адрес в форме с возможностью возврата/без возможности возврата, это можно сделать [здесь](https://ton.org/address/).

### Ответственность за пользовательские продукты

Если вы разрабатываете пользовательский продукт на блокчейне TON, важно реализовать аналогичные проверки и логику:

Убедитесь, что ваше приложение проверяет, инициализирован ли адрес получателя перед отправкой средств.
На основе состояния адреса используйте адреса с возможностью возврата для пользовательских смарт-контрактов с пользовательской логикой приложения, чтобы гарантировать возврат средств. Используйте невозвратные адреса для кошельков.




================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/examples.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/examples.md
================================================
# Примеры смарт-контрактов

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

На этой странице вы можете найти ссылки на смарт-контракты TON, реализованные для различного программного обеспечения.

:::info
Убедитесь, что вы тщательно протестировали контракты перед их использованием в производственной среде. Это критически важный шаг для обеспечения надлежащего функционирования и безопасности вашего программного обеспечения.
:::

## Смарт-контракты FunC

### Контракты, используемые в продакшене

| Контракты                                                                                                                                                                                                                                                                                                             | Описание                                                                                                                                                                                                                    |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [wallet-contract](https://github.com/ton-blockchain/wallet-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/wallet-contract\\&name=wallet-contract)</small>                                                                                         | Wallet v4 — это предлагаемая версия кошелька для замены v3 или более старых кошельков                                                                                                                                       |
| [liquid-staking-contract](https://github.com/ton-blockchain/liquid-staking-contract/) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/liquid-staking-contract/\\&name=liquid-staking-contract)</small>                                                       | Liquid Staking (LSt) — это протокол, который связывает держателей TON всех уровней с операторами аппаратных узлов для участия в валидации блокчейна TON посредством объединения активов. |
| [modern_jetton](https://github.com/EmelyanenkoK/modern_jetton) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/EmelyanenkoK/modern_jetton\\&name=modern_jetton)</small>                                                                                | Реализация стандартного жетона с дополнительными withdraw_tons и withdraw_jettons.                                                                                |
| [highloadwallet-v3](https://github.com/ton-blockchain/highload-wallet-contract-v3)                                                                                                                                                                                                                                    | Этот кошелек предназначен для тех, кому необходимо отправлять транзакции на очень высоких скоростях, например, на криптовалютных биржах.                                                                    |
| [stablecoin-contract](https://github.com/ton-blockchain/stablecoin-contract)                                                                                                                                                                                                                                          | Смарт-контракты жетона с функцией управления, используемые для стейблкоинов, таких как USDt.                                                                                                                |
| [governance-contract](https://github.com/ton-blockchain/governance-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/governance-contract\\&name=governance-contract)</small>                                                                         | Основные контракты блокчейна TON `elector-code.fc` и `config-code.fc`.                                                                                                                                      |
| [bridge-func](https://github.com/ton-blockchain/bridge-func) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/bridge-func\\&name=bridge-func)</small>                                                                                                         | Мост Toncoin TON-EVM.                                                                                                                                                                                       |
| [token-bridge-func](https://github.com/ton-blockchain/token-bridge-func) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/token-bridge-func\\&name=token-bridge-func)</small>                                                                                 | Мост токена TON-EVM - смарт-контракты FunC.                                                                                                                                                                 |
| [lockup-wallet-contract/universal](https://github.com/ton-blockchain/lockup-wallet-contract/tree/main/universal) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/lockup-wallet-contract/tree/main/universal\\&name=lockup-wallet-contract/universal)</small> | Универсальный кошелек с блокировкой - это контракт, который может хранить монеты с блокировкой и ограничениями.                                                                                             |
| [lockup-wallet-contract/vesting](https://github.com/ton-blockchain/lockup-wallet-contract/tree/main/vesting) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/lockup-wallet-contract/tree/main/vesting\\&name=lockup-wallet-contract/vesting)</small>         | Смарт-контракт кошелька для вестинга                                                                                                                                                                                        |
| [multisig-contract](https://github.com/ton-blockchain/multisig-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/multisig-contract\\&name=multisig-contract)</small>                                                                                 | `(n, k)`-мультиподписной кошелек - это кошелек с `n` держателями закрытых ключей, который принимает запросы на отправку сообщений, если запрос собирает не менее `k` подписей держателей.                   |
| [token-contract](https://github.com/ton-blockchain/token-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/token-contract\\&name=token-contract)</small>                                                                                             | Смарт-контракты взаимозаменяемых, невзаимозаменяемых и полувзаимозаменяемых токенов                                                                                                                                         |
| [dns-contract](https://github.com/ton-blockchain/dns-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/dns-contract\\&name=dns-contract)</small>                                                                                                     | Смарт-контракты доменной зоны `.ton`.                                                                                                                                                                       |
| [nominator-pool](https://github.com/ton-blockchain/nominator-pool) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/nominator-pool\\&name=nominator-pool)</small>                                                                                             | Смарт-контракт пула номинаторов                                                                                                                                                                                             |
| [single-nominator-pool](https://github.com/orbs-network/single-nominator) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/nominator-pool\\&name=nominator-pool)</small>                                                                                      | Смарт-контракт Единый пул номинаторов                                                                                                                                                                                       |
| [vesting-contract](https://github.com/ton-blockchain/vesting-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/vesting-contract\\&name=vesting-contract)</small>                                                                                     | Контракт Вестинга позволяет вам заблокировать определенное количество Toncoin на указанное время и постепенно разблокировать их.                                                                            |
| [storage](https://github.com/ton-blockchain/ton/tree/master/storage/storage-daemon/smartcont) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-blockchain/ton/tree/master/storage/storage-daemon/smartcont\\&name=storage)</small>                                       | Поставщик услуг хранения данных TON и контракты структуры                                                                                                                                                                   |

### Экосистемные контракты

| Контракты                                                                                                                                                                                                                                                                                                                           | Описание                                                                                                                                                                                   |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [telemint](https://github.com/TelegramMessenger/telemint) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/TelegramMessenger/telemint\\&name=telemint)</small>                                                                                                                             | Контракты на имена пользователей Telegram (`nft-item.fc`) и номера Telegram (`nft-item-no-dns.fc`).                                  |
| [capped-fungible-token](https://github.com/TonoxDeFi/capped-fungible-token) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/TonoxDeFi/capped-fungible-token\\&name=capped-fungible-token)</small>                                                                                         | Базовая реализация смарт-контрактов для кошелька жетонов и минтера жетонов                                                                                                                 |
| [gusarich-airdrop](https://github.com/Gusarich/airdrop/tree/main/contracts)                                                                                                                                                                                                                                                         | Реализация масштабируемой системы эирдропов для блокчейна TON. Она может использоваться для распределения жетонов в цепочке на любое количество кошельков. |
| [getgems-io/nft-contracts](https://github.com/getgems-io/nft-contracts/tree/main/packages/contracts/sources) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/getgems-io/nft-contracts/tree/main/packages/contracts/sources\\&name=getgems-io/nft-contracts)</small>                       | Контракты Getgems NFT                                                                                                                                                                      |
| [lockup-wallet-deployment](https://github.com/ton-defi-org/lockup-wallet-deployment) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-defi-org/lockup-wallet-deployment\\&name=lockup-wallet-deployment)</small>                                                                       | Развертывание и выполнение контракта блокировки от начала до конца                                                                                                                         |
| [WTON](https://github.com/TonoxDeFi/WTON) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/TonoxDeFi/WTON\\&name=WTON)</small>                                                                                                                                                             | Этот смарт-контракт обеспечивает реализацию обернутого Toncoin, называемого WTON.                                                                                          |
| [wton-contract](https://github.com/ton-community/wton-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-community/wton-contract\\&name=wton-contract)</small>                                                                                                                 | контракты wTON                                                                                                                                                                             |
| [contract-verifier-contracts](https://github.com/ton-community/contract-verifier-contracts) <br /> <small>🪄 [Run in WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-community/contract-verifier-contracts\\&name=contract-verifier-contracts)</small>                                                              | Контракты реестра источников, в которых хранится доказательство on-chain для каждого хэша ячейки кода.                                                                     |
| [vanity-contract](https://github.com/ton-community/vanity-contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-community/vanity-contract\\&name=vanity-contract)</small>                                                                                                         | Смарт-контракт, который позволяет "майнить" любой подходящий адрес для любого контракта.                                                                                   |
| [ton-config-smc](https://github.com/ton-foundation/ton-config-smc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-foundation/ton-config-smc\\&name=ton-config-smc)</small>                                                                                                           | Простой контракт для хранения версионных данных в блокчейне TON.                                                                                                           |
| [ratelance](https://github.com/ProgramCrafter/ratelance/tree/main/contracts/func) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ProgramCrafter/ratelance/tree/main/contracts/func\\&name=ratelance)</small>                                                                             | Ratelance — это фриланс-платформа, которая стремится устранить барьеры между потенциальными работодателями и работниками.                                                  |
| [logger.fc](https://github.com/tonwhales/ton-contracts/blob/master/contracts/logger.fc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/tonwhales/ton-contracts/blob/master/contracts/logger.fc\\&name=logger.fc)</small>                                                 | Контракт, сохраняющий данные в локальном хранилище.                                                                                                                        |
| [ton-nominators](https://github.com/tonwhales/ton-nominators) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/tonwhales/ton-nominators\\&name=ton-nominators)</small>                                                                                                                     | Исходный код пула номинаторов Ton Whales.                                                                                                                                  |
| [ton-link-contract-v3](https://github.com/ton-link/ton-link-contract-v3) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-link/ton-link-contract-v3\\&name=ton-link-contract-v3)</small>                                                                                               | Ton-link позволяет смарт-контрактам получать доступ к данным за пределами блокчейна, сохраняя при этом безопасность данных.                                                |
| [delab-team/fungible-token](https://github.com/delab-team/contracts/tree/main/fungible-token) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/delab-team/contracts/tree/main/fungible-token\\&name=delab-team/fungible-token)</small>                                                     | Реализация взаимозаменяемого токена DeLab TON                                                                                                                                              |
| [whitelisted-wallet.fc](https://github.com/tonwhales/ton-contracts/blob/master/contracts/whitelisted-wallet.fc) <br /> 🪄 <small>[Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/tonwhales/ton-contracts/blob/master/contracts/whitelisted-wallet.fc\\&name=whitelisted-wallet.fc)</small> | Простой контракт с белым списком кошельков                                                                                                                                                 |
| [delab-team/jetton-pool](https://github.com/delab-team/contracts/tree/main/jetton-pool) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/delab-team/contracts/tree/main/jetton-pool\\&name=delab-team/jetton-pool)</small>                                                                 | Смарт-контракт жетона PoolTON предназначен для создания фагминг пулов.                                                                                                     |
| [ston-fi/contracts](https://github.com/ston-fi/dex-core/tree/main/contracts) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ston-fi/dex-core/tree/main/contracts\\&name=ston-fi/contracts)</small>                                                                                       | Основные контракты Stonfi DEX                                                                                                                                                              |
| [onda-ton](https://github.com/0xknstntn/onda-ton) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/0xknstntn/onda-ton\\&name=onda-ton)</small>                                                                                                                                             | Onda Lending Pool — основные смарт-контракты первого кредитного протокола на TON                                                                                                           |
| [ton-stable-timer](https://github.com/ProgramCrafter/ton-stable-timer) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ProgramCrafter/ton-stable-timer\\&name=ton-stable-timer)</small>                                                                                                   | Контракт TON Стабильный таймер                                                                                                                                                             |
| [HipoFinance/contract](https://github.com/HipoFinance/contract) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/HipoFinance/contract\\&name=HipoFinance)</small>                                                                                                                          | hTON — это децентрализованный, не требующий разрешений, открытый протокол ликвидного стейкинга на блокчейне TON                                                                            |

### Контракты для обучения

| Контракты                                                                                                                                                                                                                                                                                                                                                                    | Описание                                                                                |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| [counter.fc](https://github.com/ton-community/blueprint/blob/main/example/contracts/counter.fc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-community/blueprint/blob/main/example/contracts/counter.fc\\&name=counter.fc)</small>                                                                          | Смарт-контракт счетчика с комментариями.                                |
| [simple-distributor](https://github.com/ton-community/simple-distributor) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/ton-community/simple-distributor\\&name=simple-distributor)</small>                                                                                                                                      | Простое распределение TON.                                              |
| [ping-pong.fc](https://github.com/tonwhales/ton-nft/blob/main/packages/nft/ping-pong/ping-pong.fc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/tonwhales/ton-nft/blob/main/packages/nft/ping-pong/ping-pong.fc\\&name=ping-pong.fc)</small>                                                                    | Простой контракт для тестирования отправки Toncoin в разных режимах.    |
| [ton-random](https://github.com/puppycats/ton-random) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/puppycats/ton-random\\&name=ton-random)</small>                                                                                                                                                                              | Два контракта, которые помогут вам генерировать случайные числа в сети. |
| [Blueprint simple contract](https://github.com/liminalAngel/1-func-project/blob/master/contracts/main.fc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/liminalAngel/1-func-project/blob/master/contracts/main.fc\\&name=simple_contract)</small>                                                                                | Пример смарт-контракта                                                                  |
| [Blueprint jetton_minter.fc](https://github.com/liminalAngel/func-blueprint-tutorial/blob/master/6/contracts/jetton_minter.fc) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/liminalAngel/func-blueprint-tutorial/blob/master/6/contracts/jetton_minter.fc\\&name=jetton_minter.fc)</small> | Пример смарт-контракта для выпуска жетонов в сети.                      |
| [Simple TON DNS Subdomain manager](https://github.com/Gusarich/simple-subdomain) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/Gusarich/simple-subdomain\\&name=Simple_TON_DNS_Subdomain_manager)</small>                                                                                                                        | Менеджер поддоменов DNS TON.                                            |
| [disintar/sale-dapp](https://github.com/disintar/sale-dapp/tree/master/func) <br /> <small>🪄 [Запустить в WebIDE](https://ide.nujan.io/?importURL=https://github.com/disintar/sale-dapp/tree/master/func\\&name=disintar/sale-dapp)</small>                                                                                                                                | DApp приложение React + NFT для продажи с FunC                                          |

### Умные задачи TON

#### Умные задачи TON 1

- https://github.com/nns2009/TON-FunC-contest-1/tree/main
- https://github.com/pyAndr3w/func-contest1-solutions
- https://github.com/crazyministr/TonContest-FunC/tree/master/func-contest1

#### Умные задачи TON 2

- https://github.com/ton-blockchain/func-contest2-solutions
- https://github.com/nns2009/TON-FunC-contest-2
- https://github.com/crazyministr/TonContest-FunC/tree/master/func-contest2

#### Умные задачи TON 3

- https://github.com/nns2009/TON-FunC-contest-3
- https://github.com/shuva10v/func-contest3-solutions
- https://github.com/crazyministr/TonContest-FunC/tree/master/func-contest3

#### Умные задачи TON 4

- https://github.com/akifoq/tsc4 (TOP оптимизирован)
- https://github.com/Gusarich/tsc4
- https://github.com/Skydev0h/tsc4
- https://github.com/aSpite/tsc4-contracts (решение FunC)
- [https://github.com/ProgramCrafter/tsc4](https://github.com/ProgramCrafter/tsc4/tree/c1616e12d1b449b01fdcb787a3aa8442e671371e/contracts) (решение FunC)

## Смарт-контракты Fift

- [CreateState.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/CreateState.fif)
- [asm-to-cpp.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/asm-to-cpp.fif)
- [auto-dns.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/auto-dns.fif)
- [complaint-vote-req.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/complaint-vote-req.fif)
- [complaint-vote-signed.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/complaint-vote-signed.fif)
- [config-proposal-vote-req.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/config-proposal-vote-req.fif)
- [config-proposal-vote-signed.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/config-proposal-vote-signed.fif)
- [create-config-proposal.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/create-config-proposal.fif)
- [create-config-upgrade-proposal.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/create-config-upgrade-proposal.fif)
- [create-elector-upgrade-proposal.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/create-elector-upgrade-proposal.fif)
- [envelope-complaint.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/envelope-complaint.fif)
- [gen-zerostate-test.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/gen-zerostate-test.fif)
- [gen-zerostate.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/gen-zerostate.fif)
- [highload-wallet-v2-one.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2-one.fif)
- [highload-wallet-v2.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2.fif)
- [highload-wallet.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet.fif)
- [manual-dns-manage.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/manual-dns-manage.fif)
- [new-auto-dns.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-auto-dns.fif)
- [new-highload-wallet-v2.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-highload-wallet-v2.fif)
- [new-highload-wallet.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-highload-wallet.fif)
- [new-manual-dns.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-manual-dns.fif)
- [new-pinger.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-pinger.fif)
- [new-pow-testgiver.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-pow-testgiver.fif)
- [new-restricted-wallet.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-restricted-wallet.fif)
- [new-restricted-wallet2.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-restricted-wallet2.fif)
- [new-restricted-wallet3.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-restricted-wallet3.fif)
- [new-testgiver.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-testgiver.fif)
- [new-wallet-v2.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-wallet-v2.fif)
- [new-wallet-v3.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-wallet-v3.fif)
- [new-wallet.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-wallet.fif)
- [show-addr.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/show-addr.fif)
- [testgiver.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/testgiver.fif)
- [update-config-smc.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/update-config-smc.fif)
- [update-config.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/update-config.fif)
- [update-elector-smc.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/update-elector-smc.fif)
- [validator-elect-req.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/validator-elect-req.fif)
- [validator-elect-signed.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/validator-elect-signed.fif)
- [wallet-v2.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet-v2.fif)
- [wallet-v3.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet-v3.fif)
- [wallet.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet.fif)
- [wallet-v3-code.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet-v3-code.fif)

## Библиотеки и справочники FunC

- https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/crypto/elliptic-curves
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/math
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/messages
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/slices
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/strings
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/tuples
- https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/utils
- https://github.com/disintar/sale-dapp/tree/master/func

## Добавить ссылку

Если вы хотите поделиться новым примером смарт-контракта, создайте PR для этой [страницы](https://github.com/ton-community/ton-docs/tree/main/docs/v3/documentation/smart-contracts/contracts-specs/examples.md).

## См. также

- [Введение в разработку смарт-контрактов](/v3/documentation/smart-contracts/overview)
- [Как работать со смарт-контрактами кошелька](/v3/guidelines/smart-contracts/howto/wallet)
- [[You Tube] Ton Dev Study FunC и уроки BluePrint](https://www.youtube.com/watch?v=7omBDfSqGfA\\&list=PLtUBO1QNEKwtO_zSyLj-axPzc9O9rkmYa)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/governance.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/governance.md
================================================
# Контракты управления

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В TON параметры консенсуса работы узла, связанные с TVM, catchain, комиссиями и топологией цепи (а также то, как эти параметры хранятся и обновляются), контролируются набором специальных смарт-контрактов – в отличие от устаревших и негибких способов хардкода этих параметров, принятых в блокчейнах предыдущих поколений. Таким образом, TON реализует всеобъемлющее и прозрачное on-chain управление. Сам набор специальных смарт-контрактов регулируется параметрами,  и в настоящее время включает в себя контракты [*Избирателя*](https://docs.ton.org/v3/documentation/smart-contracts/contracts-specs/governance#elector "Elector"), [*Конфигурации*](https://docs.ton.org/v3/documentation/smart-contracts/contracts-specs/governance#config "Config"), и *DNS*, а в будущем будет расширен за счет *extra-currency Minter* и др.

## Избиратель

Смарт-контракт Elector (Избиратель) управляет тем, как раунды валидации сменяют друг друга, кто получает обязанность валидировать блокчейн и как будет распределяться вознаграждение за валидацию. Если вы хотите стать валидатором и взаимодействовать с избирателем, ознакомьтесь с [инструкциями валидатора](https://ton.org/validator).

Избиратель хранит данные о невыведенных Toncoin в хешмапе `credits`, новые заявки – в хешмапе `elect`, а информацию о предыдущих выборах – в хешмапе *past\*elections*, последняя хранится внутри *complaints* (жалоб на неправильную работу валидатора) и *frozen*-stakes\* (замороженных ставок валидатора за уже завершенные раунды, которые удерживаются `stake_held_for`(ConfigParam 15)). Контракт Избирателя выполняет следующие задачи:

- Обработка заявок для проведения выборов валидаторов
- Проведение выборов
- Обработка отчетов о неправильной работе валидатора
- Распределение вознаграждений за валидацию

### Обработка заявок

Чтобы создать заявку, будущий валидатор должен сформировать специальное сообщение, содержащее соответствующие параметры (адрес ADNL, публичный ключ, `max_factor` и т.д.), прикрепить его к некоторой сумме TON (называемой ставкой) и отправить Избирателю. Избиратель, в свою очередь, проверяет эти параметры и либо регистрирует заявку, либо сразу же возвращает ставку обратно отправителю. Обратите внимание, что заявки принимаются только с адресов на мастерчейне.

### Проведение выборов

Избиратель – это специальный смарт-контракт, который имеет возможность принудительно вызываться в начале и в конце каждого блока (так называемые Tick и Tock транзакции). Избиратель, действительно, вызывается на каждом блоке и проверяет, не пора ли провести новые выборы.

Общая концепция процесса выборов состоит в том, чтобы рассмотреть все заявки, в частности, их сумму TON и `max_factor` (максимальное соотношение работы по проверке, которую этот заявитель согласен выполнить, по сравнению с самым слабым валидатором), и установить веса для каждого валидатора пропорционально сумме TON, но таким образом, чтобы все условия `max_factor` были выполнены.

Технически это реализовано следующим образом:

1. Избиратель принимает все заявки с суммой ставки, превышающей текущий сетевой минимум `min_stake` (ConfigParam 17).
2. Происходит сортировка заявок по ставке в порядке убывания.
3. Если участников больше, чем максимальное количество валидаторов (`max_validators` ConfigParam 16), список сокращается с конца.
4. Выполняется цикл `i` от `1` до `N` (среди оставшихся участников):

- Берется первый `i`-элемент из списка (отсортированного в порядке убывания),
- Исходя из того, что *i*-ый кандидат будет принят последним (и, следовательно, имеет наименьший вес), рассчитывается эффективная ставка (`true_stake`) относительно `max_factor`. Другими словами, эффективная ставка *j*-го заявителя (`j<i`) рассчитывается как `min(stake[i]*max_factor[j], stake[j])`,
- Вычисляется общая эффективная ставка (TES – total effective stake) участников с 1-го по *i*-й. Если данная TES выше, чем предыдущая известная максимальная TES, то она считается наилучшей текущей весовой конфигурацией.

5. Получение текущей наилучшей конфигурации, т.е. весовой конфигурации, которая использует максимальную ставку, и ее отправка в контракт конфигурации ([Config contract](https://docs.ton.org/v3/documentation/smart-contracts/contracts-specs/governance#config)), чтобы она стала новым набором валидаторов.
6. Внесение всех неиспользованных ставок, например, ставок от заявителей, которые не стали валидаторами, и излишков, если таковые имеются `stake[j]-min(stake[i]*max_factor[j], stake[j])` в таблицу `credits`, откуда они могут быть запрошены заявителями.

Таким образом, если у нас есть девять кандидатов со 100 000 TON и коэффициентом 2,7 и один участник с 10 000 TON, то последний участник не будет избран: без него эффективная ставка составит 900 000 TON, а с ним – только 9 \* 27 000 + 10 000 = 253 000 TON. Напротив, если у нас есть один кандидат со 100 000 TON и коэффициентом 2,7 и девять участников с 10 000 TON, все они станут валидаторами. Однако первый кандидат может поставить только 10 000 \*2,7 = 27 000 TON, а излишек в 73 000 TON пойдет в `credits`.

Обратите внимание, что существуют некоторые ограничения (очевидно, контролируемые параметрами конфигурации TON) на результирующий набор валидации, в частности, `min_validators`, `max_validators` (ConfigParam 16), `min_stake`, `max_stake`, `min_total_stake`, `max_stake_factor` (ConfigParam 17). Если выполнить эти условия с помощью текущих заявок нет возможности, проведение выборов будет отложено.

### Обработка отчетов о неправильной работе валидатора

Каждый валидатор время от времени случайным образом получает задание создать новый блок (если через несколько секунд валидатор не справляется, эта обязанность переходит к следующему валидатору). Частота таких назначений определяется весом валидатора. Таким образом, любой желающий может получить блоки из предыдущего раунда валидации и проверить, близко ли ожидаемое количество сгенерированных блоков к реальному количеству блоков. Статистически значимое отклонение (когда количество сгенерированных блоков меньше ожидаемого) означает, что валидатор ведет себя неправильно. В блокчейне TON относительно легко доказать неправильное поведение с помощью Merkle proofs (Меркл пруф). Контракт избирателя принимает такое доказательство с предложенным штрафом от любого, кто готов заплатить за его хранение, и регистрирует жалобу. Затем каждый валидатор текущего раунда проверяет жалобу, и если она верна и предложенный штраф соответствует серьезности ошибки, валидаторы голосует за нее. Получив более 2/3 голосов, жалоба принимается, а штраф удерживается из хешмап `frozen` соответствующего элемента `past_elections`.

### Распределение вознаграждений за валидацию

Точно так же как и при проверке того, не пора ли проводить новые выборы, Избиратель в каждом блоке проверяет, не пора ли освободить средства из `frozen` за сохранённые `past_elections`. В соответствующем блоке Избиратель распределяет накопленный доход (сборы за газ и вознаграждения за создание блока) от соответствующих раундов валидации между валидаторами этого раунда пропорционально весам валидаторов. После этого ставки с вознаграждениями добавляются в таблицу `credits`, а информация о предыдущих выборах удаляется из таблицы `past_elections`.

### Текущее состояние избирателя

Вы можете проверить текущее состояние в [DApp](https://1ixi1.github.io/elector/), которое позволяет увидеть участников выборов, заблокированные ставки, готовность к выводу средств, жалобы и т. д.

## Смарт-контракт Конфигурации

Смарт-контракт Config (Конфигурации) контролирует параметры конфигурации TON. Его логика определяет, кто и при каких условиях имеет право изменять некоторые из этих параметров. Он также реализует механизм предложения/голосования и регулярное обновление набора валидаторов.

### Регулярное обновление набора валидаторов

Как только контракт конфигурации получает специальное сообщение от контракта избирателя, уведомляющее о выборе нового набора валидаторов, контракт конфигурации помещает новый набор валидаторов в ConfigParam 36 (следующие валидаторы). Затем в каждом блоке во время TickTock-транзакций контракт проверяет пришло ли время применить новый набор валидаторов (время `utime_since` заложено в самом наборе валидаторов) и перемещает предыдущий набор из ConfigParam 34 (текущие валидаторы) в ConfigParam32 (предыдущие валидаторы), а наборы из ConfigParam 36 в ConfigParam 34.

### Механизм предложения/голосования

Любой, кто готов заплатить за хранение *предложения*, может предложить изменить один или несколько параметров конфигурации, отправив соответствующие сообщения смарт-контракту конфигурации. В свою очередь, любой валидатор из текущего набора может проголосовать за это предложение, подписав сообщение об одобрении своим приватным ключом (обратите внимание, что соответствующий публичный ключ хранится в ConfigParam 34). Набрав или не набрав 3/4 голосов (с учетом веса валидаторов), предложение выигрывает или проигрывает раунд. При выигрыше критического количества раундов (`min_wins` ConfigParam 11) предложение принимается, при проигрыше критического количества раундов (`max_losses` ConfigParam 11) оно отклоняется.
Обратите внимание, что некоторые параметры считаются критическими (набор критических параметров сам является параметром конфигурации ConfigParam 10) и, таким образом, требуют большего количества раундов для принятия.

Индексы параметров конфигурации `-999`, `-1000`, `-1001` зарезервированы для голосования за механизм экстренного обновления и обновления кода контрактов конфигурации и избирателя. Когда предложение с соответствующими индексами набирает достаточное количество голосов в достаточном количестве раундов, соответствующих аварийному ключу, код контракта конфигурации или код контракта избирателя обновляется.

#### Экстренное обновление

Валидаторы могут проголосовать за назначение специального публичного ключа (ключ конфигурации), чтобы иметь возможность обновлять параметры конфигурации, когда это невозможно сделать с помощью механизма голосования. Это временная мера, необходимая в период активного развития сети. Ожидается, что по мере развития сети эта мера будет постепенно отменена. После разработки и тестирования, ключ будет переведен на решение с мультиподписью, и когда сеть докажет свою стабильность, от аварийного механизма можно будет полностью отказаться.

Валидаторы действительно проголосовали за назначение этого ключа TON Foundation в июле 2021 года (блок мастерчейна `12958364`). Обратите внимание, что такой ключ может быть использован только для ускорения обновления конфигурации. Он не может вмешиваться в код, хранение и баланс любого контракта на любой цепочке.

История экстренных обновлений:

- 17 апреля 2022 г. количество заявок на участие в выборах выросло настолько, что в тот момент выборы не могли быть проведены в соответствии с ограничениями на газ. В частности, для проведения выборов требовалось более 10 миллионов газа, в то время как блоки `soft_limit` и `hard_limit` были установлены на `10m` и `20m` (ConfigParam 22), `special_gas_limit` и `block_gas_limit` были установлены на `10m` и `10m`, соответственно (ConfigParam 20). Таким образом, новые валидаторы не могут сформироваться, т.к. из-за достижения лимита газа в блоке транзакции, обрабатывающей внутренние сообщения на мастерчейне, не могут быть включены в блок. В свою очередь, это привело к невозможности голосования за обновление конфигурации (невозможно было выиграть необходимое количество раундов, так как текущий раунд не мог завершиться). Аварийный ключ был использован для обновления ConfigParam 22 `soft_limit` до `22m` и `hard_limit` до `25m` (в блоке `19880281`), а ConfigParam 20 `special_gas_limit` до `20m` и `block_gas_limit` до `22m` (в блоке `19880300`). В результате выборы были успешно проведены, а следующий блок израсходовал `10 001 444` газа. Общая задержка выборов составила около 6 часов, при этом функциональность бейсчейн не пострадала.
- 2 марта 2023 г. количество заявок на участие в выборах выросло настолько, что даже `20m` не хватало для проведения выборов. Однако на этот раз мастерчейн продолжал обрабатывать внешние сообщения благодаря повышенному `hard_limit`. Аварийный ключ был использован для обновления ConfigParam 20 `special_gas_limit` до `25m` и `block_gas_limit` до `27m` (в блоке `27747086`). В результате выборы были успешно проведены в следующем блоке. Общая задержка выборов составила около 6 часов, функциональность как мастерчейна, так и бейсчейна не пострадала (за исключением выборов).
- 22 ноября 2023 г. ключ был использован для [самоотзыва](https://t.me/tonblockchain/221) (в блоке `34312810`). В результате открытый ключ был заменен на 32 нулевых байта.
- В связи с переходом на OpenSSL-реализацию верификации подписи Ed25519, проверка на особый случай [(*все байты публичного ключа одинаковы*)](https://github.com/ton-blockchain/ton/blob/7fcf26771748338038aec4e9ec543dc69afeb1fa/crypto/ellcurve/Ed25519.cpp#L57C1-L57C1) была отключена. В результате чего проверка на нулевой публичный ключ перестала работать так, как было задумано. Используя эту проблему, аварийный ключ был [обновлен 9 декабря](https://t.me/tonstatus/80) еще раз (в блоке `34665437`, [транзакция](https://tonscan.org/tx/MU%2FNmSFkC0pJiCi730Fmt6PszBooRZkzgiQMv0sExfY=)) до [проверяемо случайной кривой](https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number) `82b17caadb303d53c3286c06a6e1affc517d1bc1d3ef2e4489d18b873f5d7cd1` – sha256 (не является допустимой точкой кривой). Теперь единственный способ обновить параметры конфигурации сети – это механизм консенсуса валидатора.

## См. также

- [Предварительно скомпилированные контракты](/v3/documentation/smart-contracts/contracts-specs/precompiled-contracts)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/highload-wallet.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/highload-wallet.md
================================================
# Highload Wallet

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

При работе с большим количеством сообщений за короткий период времени необходим специальный кошелек под названием Highload Wallet. Highload Wallet V2 долгое время был основным кошельком на TON, но с ним нужно было быть очень осторожным. В противном случае можно было [заблокировать все средства](https://t.me/tonstatus/88).

[С появлением Highload Wallet V3](https://github.com/ton-blockchain/Highload-wallet-contract-v3) эта проблема была решена на уровне архитектуры контракта и потребляет меньше газа. В этой главе будут рассмотрены основы Highload Wallet V3 и важные нюансы, которые следует помнить.

## Highload Wallet v3

Этот кошелек создан для тех, кому необходимо отправлять транзакции с очень высокой скоростью. Например, для криптобирж.

- [Исходный код](https://github.com/ton-blockchain/Highload-wallet-contract-v3)

Любое внешнее сообщение (запрос на перевод) для Highload v3 содержит:

- подпись (512 бит) в ячейке верхнего уровня - другие параметры находятся в ссылке этой ячейки
- ID субкошелька (32 бита)
- сообщение для отправки в качестве ссылки (сериализованное внутреннее сообщение, которое будет отправлено)
- режим отправки сообщения (8 бит)
- составной идентификатор запроса - 13 бит "сдвига" и 10 бит "номера бита", однако 10 бит номера бита могут доходить только до 1022, а не до 1023, а также последний такой используемый query ID (8388605) зарезервирован для экстренных случаев и не должен использоваться
- дата создания или временная метка сообщения
- время ожидания

Время ожидания сохраняется в Highload в качестве параметра и проверяется на время ожидания во всех запросах - таким образом, время ожидания для всех запросов одинаково. Сообщение не должно быть старше времени ожидания на момент поступления в кошелек Highload, или в коде требуется, чтобы `created_at > now() - timeout`. Query ID хранятся в целях защиты от повторного воспроизведения в течение как минимум времени ожидания и, возможно, до 2 \* время ожидания, однако не следует ожидать, что они будут храниться дольше, чем истечение этого времени. Идентификатор суб-кошелька сверяется с идентификатором, сохраненным в кошельке. Хэш внутренней ссылки проверяется вместе с подписью на соответствие открытому ключу кошелька.

Highload v3 может отправлять только 1 сообщение из любого заданного внешнего сообщения, однако он может отправлять это сообщение себе с помощью специального op code, что позволяет устанавливать любую ячейку действия для этого вызова внутреннего сообщения, что фактически позволяет отправлять до 254 сообщений на 1 внешнее сообщение (возможно, больше, если другое сообщение снова отправляется в кошелек Highload среди этих 254).

Highload v3 всегда будет сохранять query ID (защита от повторного воспроизведения) после прохождения всех проверок, однако сообщение может быть не отправлено из-за некоторых условий, включая, но не ограничиваясь ими:

- **содержащее состояние init** (такие сообщения, если требуется, могут быть отправлены с использованием специального op code для установки ячейки действия после внутреннего сообщения из кошелька Highload на себя)
- недостаточный баланс
- недопустимая структура сообщения (которая включает внешние исходящие сообщения - только внутренние сообщения могут быть отправлены напрямую из внешнего сообщения)

Highload v3 никогда не будет выполнять несколько внешних сообщений, содержащих один и тот же `query_id` **и** `created_at` - к тому времени, когда он забудет любой заданный `query_id`, условие `created_at` предотвратит выполнение такого сообщения. Это фактически делает `query_id` **и** `created_at` вместе "первичным ключом" запроса на перевод для Highload v3.

При итерации (увеличении) query ID дешевле (с точки зрения TON, потраченного на сборы) сначала перебрать номер бита, а затем сдвиг, как при увеличении обычного числа. После того, как вы достигли последнего query ID (помните об аварийном query ID- см. выше), вы можете сбросить query ID на 0, но если период ожидания Highload еще не прошел, то словарь защиты от повторного воспроизведения будет заполнен, и вам придется ждать, пока пройдет период ожидания.

## Highload wallet v2

:::danger
Устаревший контракт, рекомендуется использовать Highload wallet v3.
:::

Этот кошелек создан для тех, кому нужно отправлять сотни транзакций за короткий промежуток времени. Например, криптобиржи.

Он позволяет отправлять до `254` транзакций за один вызов смарт-контракта. Он также использует немного другой подход для решения проблемы атак повторного воспроизведения вместо seqno, поэтому вы можете вызывать этот кошелек несколько раз одновременно, чтобы отправлять даже тысячи транзакций в секунду.

:::caution Ограничения
Обратите внимание, что при работе с Highload wallet необходимо проверить и принять во внимание следующие ограничения.
:::

1. **Ограничение размера хранилища.** В настоящее время размер хранилища контракта должен быть меньше 65535 ячеек. Если размер
 old_queries превысит этот предел, будет выдано исключение в ActionPhase, и транзакция завершится ошибкой.
 Неудачная транзакция может быть воспроизведена.
2. **Лимит газа.** В настоящее время лимит газа составляет 1 000 000 единиц газа, что означает, что существует ограничение на то, сколько старых запросов может быть очищено за одну транзакцию. Если количество истекших запросов будет больше, контракт зависнет.

Это означает, что не рекомендуется устанавливать слишком большую дату истечения срока:
количество запросов в течение периода истечения срока не должно превышать 1000.

Кроме того, количество истекших запросов, очищенных за одну транзакцию, должно быть меньше 100.

## Как это сделать

Вы также можете прочитать статью [Руководство по Highload Wallet](/v3/guidelines/smart-contracts/howto/wallet#-high-load-wallet-v3).

Исходный код кошелька:

- [ton/crypto/smartcont/Highload-wallet-v2-code.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-highload-wallet-v2.fif)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/nominator-pool.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/nominator-pool.mdx
================================================
# Пул номинаторов

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Смарт-контракт _Пул номинаторов_, предоставляет возможность одному или нескольким номинаторам одолжить Toncoin для ставки валидатору и гарантирует, что валидатор может использовать эти Toncoin только для валидации. Кроме того, смарт-контракт гарантирует распределение вознаграждения.

## Архитектура

![image](/img/nominator-pool/nominator-pool.png)

## Ограничения

Этот пул предназначен для большого объема монет.

Во время разработки главным критерием была безопасность и простота кода.

Пул не поддерживает малые депозиты или большое количество номинаторов в одном пуле.

Целевая тестируемая конфигурация: минимальная ставка номинатора – 10 000 TON, максимальное количество номинаторов в пуле – 40.

Количество номинаторов выше 40 не тестировалось, и мы настоятельно не рекомендуем устанавливать число выше 40 до тех пор, пока такие тесты не будут проведены.

## Комиссии

Так как пул расположен в мастерчейне, где плата за услуги высока, для работы пула потребуется около **5 TON** за раунд валидации.

Операционные сборы оплачивает валидатор.

:::info
Обратите внимание, что на балансе пула всегда должно быть **10 TON** – это минимальный баланс для оплаты сетевого хранилища. 10 TON не могут быть выведены.
:::

## Распределение вознаграждений

Для каждого раунда валидации пул отправляет ставку смарт-контракту Избирателя.

После завершения раунда проверки пул возвращает свои средства Избирателю.

Обычно полученная сумма больше, чем отправленная, а разница является вознаграждением за валидацию.

Валидатор получает часть вознаграждения в соответствии с неизменяемым параметром пула `validator_reward_share`.

```
validator_reward = (reward * validator_reward_share) / 10000;
nominators_reward = reward - validator_reward;
```

Номинаторы делят оставшееся вознаграждение в соответствии с размером своих ставок.

Например, если в пуле есть два номинатора со ставками 100 000 и 300 000 TON, то первый из них получит 25%, а второй – 75% от `nominators_reward`.

### Сокращение пула номинаторов

В случае большого штрафа за валидацию, когда полученная сумма меньше отправленной, убыток списывается из средств валидатора.

Если средств валидатора недостаточно, то недостающая сумма будет вычтена у номинаторов пропорционально их ставкам.

Обратите внимание, что смарт-контракт пула номинаторов разработан таким образом, чтобы средств валидатора всегда было достаточно для покрытия максимального штрафа.

## Ответственность валидатора

Пул может принимать участие в валидации только в том случае, если средства валидатора превышают неизменяемый параметр пула `min_validator_stake`.

Кроме того, средства валидатора должны превышать максимально возможный штраф за плохую валидацию. Рекомендуемый штраф рассчитывается в зависимости от конфигурации сети.

В противном случае пул не будет отправлять запросы на участие в раунде валидации.

## Сообщения номинаторов

Чтобы взаимодействовать с пулом номинаторов, номинаторы отправляют простые сообщения с текстовым комментарием (можно отправить из любого приложения кошелька) смарт-контракту пула номинаторов.

**Сообщения должны отправляться в режиме возврата!**

В случае опечатки или недействительного сообщения, оно вернется к отправителю.

Если вы отправите сообщение с опечаткой или недействительное сообщение в невозвратном режиме, то потеряете монеты.

## Депозит номинатора

Для того чтобы номинатор смог внести депозит, ему нужно отправить сообщение смарт-контракту пул номинатора, содержащее TON и текстовый комментарий "`d`".

Номинатор может отправить сообщение только с кошелька, расположенного в basechain (с необработанным адресом `0:...`).

Количество TON должно быть больше или равно `min_nominator_stake + 1 TON`.

При внесении депозита 1 TON вычитается в качестве комиссии за обработку депозита.

Если пул в данный момент не участвует в валидации (`state == 0`), то депозит будет зачислен немедленно.

Если же пул в данный момент участвует в валидации (`state != 0`), то сумма депозита будет добавлена к `pending_deposit_amount` номинатора и будет зачислена после завершения текущего раунда валидации.

Впоследствии номинатор может отправить больше TON, чтобы увеличить свой депозит.

Обратите внимание, если пул номинаторов уже достиг количества, равного `max_nominators_count`, то депозиты от новых номинаторов будут отклонены (вернутся обратно к отправителю).

## Вывод средств номинатора

Для вывода средств номинатор должен отправить смарт-контракту пул номинатора сообщение, содержащее текстовый комментарий "w" и некоторое количество Toncoin для оплаты комиссии сети (достаточно 1 TON). Неизрасходованные TON, прикрепленные к сообщению, будут возвращены, за исключением очень редких случаев.

Если на балансе пула номинаторов достаточно TON, вывод средств будет произведен немедленно. Все средства будут на балансе пула номинаторов, если он завершил участие в раунде валидации, но еще не подал заявку на участие в новом раунде.

Если на балансе пула номинаторов недостаточно Toncoin, то для номинатора будет выполнен запрос `withdraw_request` и Toncoin будут выведены после окончания текущего раунда валидации.

Номинатор может вывести все свои средства только за один раз. Частичный вывод не поддерживается.

## Вывод средств валидатора

Валидатор может вывести из пула все Toncoin, которые не принадлежат номинаторам.

## Участники должны хранить свои закрытые ключи

Если номинатор потеряет доступ к своему кошельку, с которого он вносил депозит, то не сможет вывести свои средства из пула.

Если валидатор потеряет доступ к своему кошельку, то не сможет вывести свои средства (валидатора) из пула.

Потеря закрытого ключа кошелька одного участника пула не влияет на других участников.

## Экстренный вывод средств

При нормальной работе валидатор должен периодически отправлять в пул номинаторов операционные сообщения, такие как: `process withdraw requests`, `update current validator set`, `new_stake`, `recover_stake`.

Программа-валидатор MyTonCtrl делает это автоматически.

В экстренной ситуации, например, если валидатор пропадает и перестает выполнять свои обязанности, операционные сообщения может отправить любой участник и, таким образом, номинаторы смогут вывести свои средства.

## Голосование за предложения по конфигурации сети

В TON изменение конфигурации сети происходит путем [голосования валидаторов] (/v3/documentation/smart-contracts/contracts-specs/governance#proposalvoting-mechanism).

В случае с пулом номинаторов имеет смысл, чтобы все участники могли голосовать, а окончательный результат был бы отправлен от имени пула.

Таким образом, смарт-контракт пула номинаторов имеет встроенную функциональность, где валидатор и номинаторы могут оставить свой голос за/против конкретного предложения.

В рамках такого голосования валидатор отправляет финальный голос смарт-контракту конфигурации сети через программное обеспечение валидатора.

Если валидатор отправил финальный голос смарт-контракту конфигурации сети, и голос не совпал с мнением большинства в пуле, то в таком случае номинаторы могут покинуть (и покинут) этот пул и перейти в другой.

Поскольку все происходит через транзакции on-chain, такое несоответствие будет храниться в блокчейне и будет доступно всем для обзора.

## Голосование номинатора

Каждое новое предложение по изменению конфигурации сети изначально публикуется на каналах TON Foundation [@tonblockchain](https://t.me/tonblockchain) или [@tonstatus](https://t.me/tonstatus).

В этом сообщении, помимо описания предложения, будет указан его хэш в HEX-формате, например, `D855FFBCF813E50E10BEAB902D1177529CE79785CAE913EB96A72AE8EFBCBF47`.

Для того чтобы номинатор проголосовал за предложение, ему нужно отправить сообщение смарт-контракту пула номинаторов с текстовым комментарием `y<HASH>`.

Для того чтобы номинатор проголосовал против предложения, ему нужно отправить сообщение смарт-контракту пула номинаторов с текстовым комментарием `n<HASH>`.

К этому сообщению должно быть прикреплено некоторое количество Toncoin для оплаты комиссии сети (достаточно 1 TON). Неизрасходованные TON, прикрепленные к сообщению, будут возвращены.

Голоса хранятся в контракте пула в течение 30 дней.

Голосовать могут только валидатор и текущие номинаторы, имеющие активную ставку в пуле.

## GET-метод `get_pool_data`

Возвращается:

1. state – uint – текущее состояние пула номинаторов. 0 – не участвует в валидации, 1 – отправил запрос `new_stake` на участие в раунде валидации, 2 – получил успешное подтверждение об участии в раунде валидации.
2. nominators_count – uint – текущее количество номинаторов в пуле.
3. stake_amount_sent – nanotons – сумма ставки, с которой пул участвует в текущем раунде проверки.
4. validator_amount – nanotons – количество монет, принадлежащих валидатору.
5. validator_address – immutable – uint – адрес кошелька валидатора. Чтобы получить адрес, выполните `"-1:" + dec_to_hex(validator_address)`.
6. validator_reward_share – immutable – uint – доля вознаграждения валидатора от валидации. `validator_reward = (reward * validator_reward_share) / 10000`.  Например, установите 4000, чтобы получить 40%.
7. max_nominators_count – immutable – uint – максимальное количество номинаторов в этом пуле.
8. min_validator_stake – immutable – nanotons – минимальная ставка валидатора в этом пуле.
9. min_nominator_stake – immutable – nanotons – минимальная ставка для номинатора в этом пуле.
10. nominators – cell – необработанный словарь с номинаторами.
11. withdraw_requests – cell – необработанный словарь с запросами на вывод средств от номинаторов.
12. stake_at – uint – ID раунда валидации, в котором мы участвуем/собираемся участвовать. Предполагается, что валидация начнется в следующем раунде (`utime_since`).
13. saved_validator_set_hash - uint - техническая информация.
14. validator_set_changes_count - uint - техническая информация.
15. validator_set_change_time - uint - техническая информация.
16. stake_held_for - uint - техническая информация.
17. config_proposal_votings – cell – необработанный справочник, содержащий конфигурации предложений голосования.

## GET-метод `list_nominators`

Возвращает список номинаторов текущего пула.

Каждая запись содержит:

1. address – uint – адрес кошелька номинатора. Чтобы получить адрес, выполните `"0:" + dec_to_hex(address)`.
2. количество – nanotons – текущая активная ставка номинатора.
3. pending_deposit_amount – nanotons – сумма депозита, которая будет добавлена к активной ставке номинатора в следующем раунде валидации.
4. withdraw_request – int – если `-1`, то этот номинатор отправил запрос на вывод всех своих средств.

## GET-метод `get_nominator_data`

Метод принимает в качестве аргумента адрес номинатора и возвращает следующие параметры:

1. количество – nanotons – текущая активная ставка номинатора.
2. pending_deposit_amount – nanotons – сумма депозита, которая будет добавлена к активной ставке номинатора в следующем раунде валидации.
3. withdraw_request – int – если `-1`, то этот номинатор отправил запрос на вывод всех своих средств.

Если в пуле нет такого номинатора, то метод выдаст ошибку `86`.

Чтобы получить номинатора, например, с адресом `EQA0i8-CdGnF_DhUHHf92R1ONH6sIA9vLZ_WLcCIhfBBXwtG`,  нужно преобразовать адрес в raw-формат `0:348bcf827469c5fc38541c77fdd91d4e347eac200f6f2d9fd62dc08885f0415f`, отбросить `0:` и вызвать `get_nominator_data 0x348bcf827469c5fc38541c77fdd91d4e347eac200f6f2d9fd62dc08885f0415f`.

## GET-метод `list_votes`

Возвращает список голосов.

Каждая запись содержит:

1. proposal_hash – uint – хэш предложения. Используйте `dec_to_hex(proposal_hash)` для преобразования хэша в HEX-форму.
2. votes_create_time - uint - время создания этого голосования.

## GET-метод `list_voters`

Метод принимает в качестве аргумента хэш предложения и возвращает список проголосовавших.

Каждая запись содержит:

1. адрес – адрес избирателя. Чтобы получить адрес номинатора, выполните `"0:" + dec_to_hex(address)`, если `address = validator_address`, сделайте `"-1:" + dec_to_hex(address)`.
2. поддержка – int – если `-1`, то это "голосование за", в противном случае это "голосование против".
3. vote_time – uint – единичное время, когда он проголосовал.

Результаты голосования подсчитываются off-chain.

## Интеграция в приложения для кошельков

Для депозитов, снятия денег и голосования отправьте пулу простые сообщения с нужными текстовыми комментариями, как описано выше.

При отправке депозита вы можете сохранить сумму, которая была отправлена, в локальном хранилище.

При отправке повторного депозита также добавьте его к этой сумме.

Чтобы узнать текущую прибыль, вызовите метод `get_nominator_data(your_address)`. Прибыль будет равна (`amount + pending_deposit_amount – sent_amount_stored_in_local_storage`).

Чтобы получить информацию о пуле, вызовите get-методы `get_pool_data` и `list_nominators`.

## См. также

- [Контракт с пулом номинаторов](https://github.com/ton-blockchain/nominator-pool)
- [Как использовать пул номинаторов](/v3/guidelines/smart-contracts/howto/nominator-pool)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/precompiled-contracts.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/precompiled-contracts.md
================================================
# Предварительно скомпилированные контракты

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

*Предварительно скомпилированный смарт-контракт* — это контракт с реализацией C++ в узле.
Когда валидатор запускает транзакцию по такому смарт-контракту, он может выполнить эту реализацию вместо TVM.
Это повышает производительность и позволяет снизить затраты на вычисления.

## Конфигурация

Список предварительно скомпилированных контрактов хранится в конфигурации мастерчейна:

```
precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
_ PrecompiledContractsConfig = ConfigParam 45;
```

`list:(HashmapE 256 PrecompiledSmc)` — это карта `(code_hash -> precomplied_smc)`.
Если хэш кода контракта найден в этой карте, то контракт считается *предварительно скомпилированным*.

## Выполнение контракта

Любая транзакция по *предварительно скомпилированному смарт-контракту* (т. е. любому контракту с хэшем кода, найденным в `ConfigParam 45`) выполняется следующим образом:

1. Получите `gas_usage` из конфигурации мастерчейна.
2. Если баланса недостаточно для оплаты газа `gas_usage`, то фаза вычислений завершается неудачей с причиной пропуска `cskip_no_gas`.
3. Код может быть выполнен двумя способами:
4. Если предварительно скомпилированное выполнение отключено или реализация C++ недоступна в текущей версии узла, то TVM работает как обычно. Лимит газа для TVM устанавливается rкак лимит газа транзакции (1M газа).
5. Если предварительно скомпилированная реализация включена и доступна, то выполняется реализация C++.
6. Переопределите [значения фазы вычисления](https://github.com/ton-blockchain/ton/blob/dd5540d69e25f08a1c63760d3afb033208d9c99b/crypto/block/block.tlb#L308): установите `gas_used` на `gas_usage`; установите `vm_steps`, `vm_init_state_hash`, `vm_final_state_hash` на ноль.
7. Плата за вычисления основана на `gas_usage`, а не на фактическом использовании газа TVM.

Когда предварительно скомпилированный контракт выполняется в TVM, 17-й элемент `c7` устанавливается на `gas_usage` и может быть извлечен с помощью инструкции `GETPRECOMPILEDGAS`. Для не предварительно скомпилированных контрактов это значение равно `null`.

Выполнение предварительно скомпилированных контрактов по умолчанию отключено. Запустите `validator-engine` с флагом `--enable-precompiled-smc`, чтобы включить его.

Обратите внимание, что оба способа выполнения предварительно скомпилированного контракта приводят к одной и той же транзакции.
Таким образом, валидаторы с реализацией C++ и без нее могут безопасно сосуществовать в сети.
Это позволяет добавлять новые записи в `ConfigParam 45`, не требуя от всех валидаторов немедленного обновления программного обеспечения узла.

## Доступные реализации

Hic sunt dracones.

## См. также

- [Контракты управления](/v3/documentation/smart-contracts/contracts-specs/governance)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/single-nominator-pool.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/single-nominator-pool.md
================================================
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Single Nominator Pool

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

[Single Nominator](https://github.com/ton-blockchain/single-nominator) – это простой брандмауэрный смарт-контракт TON, который обеспечивает безопасную валидацию блокчейна TON через холодный кошелек. Контракт предназначен для валидаторов TON, которые имеют достаточный объем средств для стейкинга и проведения самостоятельной валидации, не полагаясь на ставки сторонних номинаторов. Контракт предоставляет альтернативную упрощенную реализацию смарт-контракта [Nominator Pool](/v3/documentation/smart-contracts/contracts-specs/nominator-pool), который поддерживает только одного номинатора. Преимущество этой реализации в том, что она более безопасна, поскольку поверхность атаки значительно меньше. Это происходит благодаря значительному снижению сложности смарт-контракта пула номинаторов, который обычно поддерживает несколько сторонних номинаторов.

## Подходящее решение для валидаторов

Этот смарт-контракт предназначен для валидаторов TON, которые имеют достаточный объем средств для стейкинга и самостоятельной валидации. Другими доступными альтернативами являются:

- использование [горячего кошелька](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc) (небезопасно, поскольку холодный кошелек необходим для предотвращения кражи в случае взлома узла валидатора)
- использование [restricted-кошелька](https://github.com/EmelyanenkoK/nomination-contract/blob/master/restricted-wallet/wallet.fc) (который не поддерживается и имеет нерешенные векторы атак, например, атаки на слив газа)
- использование [Пула номинаторов](https://github.com/ton-blockchain/nominator-pool) с max_nominators_count = 1 (излишне сложно при большой площади атаки)

Смотрите более подробное [сравнение существующих альтернатив](#сравнение-существующих-альтернатив).

## Официальный хэш-код

Проверьте смарт-контракт на сайте https://verifier.ton.org, прежде чем отправлять средства на реальный контракт.

Single nominator v1.0:

```
pCrmnqx2/+DkUtPU8T04ehTkbAGlqtul/B2JPmxx9bo=
```

Single nominator v1.1 (с выводом средств через комментарий):

```
zA05WJ6ywM/g/eKEVmV6O909lTlVrj+Y8lZkqzyQT70=
```

## Архитектура

Архитектура практически идентична смарт-контракту [Nominator Pool](https://github.com/ton-blockchain/nominator-pool):

![image](/img/nominator-pool/single-nominator-architecture.png)

### Разделение на две роли

- *Владелец* – холодный кошелек (приватный ключ, не подключенный к интернету), который владеет средствами, используемыми для стейкинга, и выступает в качестве single nominator
- *Валидатор* – кошелек, чей приватный ключ находится на узле валидатора (может подписывать блоки, но не может украсть средства, используемые для ставки)

### Рабочий процесс

1. *Владелец* хранит средства для стейкинга (\$$$) в своем защищенном холодном кошельке.
2. *Владелец* вносит депозит (\$$$) в контракт *Single Nominator* (этот контракт).
3. *MyTonCtrl* запускается на узле валидатора, подключенном к интернету.
4. *MyTonCtrl* использует кошелек *Валидатора*, чтобы дать указание *Single Nominator* восстановить ставку в следующем избирательном цикле.
5. *Single Nominator* отправляет ставку (\$$$) *Избирателю* на один цикл.
6. Избирательный цикл закончился, ставка может быть восстановлена.
7. *MyTonCtrl* использует кошелек *Валидатора*, чтобы дать указание *Single Nominator* восстановить ставку в следующем избирательном цикле.
8. *Single Nominator* восстанавливает ставку (\$$$) из предыдущего цикла у *Избирателя*.
9. Шаги 4-8 повторяются до тех пор, пока *Владелец* будет готов продолжать валидацию.
10. *Владелец* выводит средства (\$$$) из контракта *Single Nominator* и забирает их.

## Ослабление векторов атак

- Для подписи новых блоков узлу-валидатору требуется горячий кошелек. Данный кошелек небезопасен по своей сути, поскольку его приватный ключ имеет доступ к интернету. Если этот ключ будет скомпрометирован, *Валидатор* не сможет извлечь средства, используемые для валидации. Только *Владелец* может вывести эти средства.

- Даже если кошелек *Валидатора* скомпрометирован, *Владелец* может попросить *Single Nominator* изменить адрес валидатора. Это не позволит злоумышленнику в дальнейшем взаимодействовать с *Single Nominator*. Здесь нет состояния гонки, *Владелец* всегда будет иметь приоритет.

- На балансе *Single Nominator* хранятся только основные средства для стейкинга – этот баланс не используется для затрат газа. Деньги на газ для начала избирательного цикла хранятся в кошельке *Валидатора*. Это решение не позволит злоумышленнику, скомпрометировавшему валидатора, слить средства для стейкинга с помощью атаки на трату газа.

- *Single Nominator* проверяет формат всех операций, выполняемых *Валидатором*, чтобы убедиться, что он не передает недействительные сообщения *Избирателю*.

- В случае необходимости, например, если контракт *Избирателя* был обновлен и изменил свой интерфейс, *Владелец* все еще может отправить любое необработанное сообщение как *Single Nominator*, чтобы вернуть ставку от *Избирателя*.

- В случае крайней необходимости, *Владелец* может установить код *Single Nominator* и переопределить его текущую логику работы для устранения непредвиденных обстоятельств.

Некоторые из этих векторов атак невозможно ослабить с помощью обычного контракта [Nominator Pool](https://github.com/ton-blockchain/nominator-pool), поскольку это позволит человеку, управляющему валидатором, красть средства у своих номинаторов. Это не проблема с *Single Nominator* потому, что *Владелец* и *Валидатор* принадлежат одной и той же стороне.

### Аудиты безопасности

Полный аудит безопасности, проведенный компанией Certik, доступен в репозитории: [Certik Audit](https://github.com/ton-blockchain/single-nominator/blob/main/certik-audit.pdf).

## Сравнение существующих альтернатив

Предполагая, что вы валидатор с достаточной ставкой для самостоятельной валидации, вот альтернативные настройки, которые вы можете использовать с MyTonCtrl:

---

### 1. Обычный горячий кошелек

Это простейшая настройка, при которой MyTonCtrl подключен к тому же [standard wallet](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc), на котором хранятся средства. Поскольку этот кошелек подключен к интернету, он считается горячим кошельком.

![image](/img/nominator-pool/hot-wallet.png)

Использование небезопасно, так как злоумышленник может получить приватный ключ, поскольку кошелек подключен к интернету. С помощью приватного ключа злоумышленник может отправить средства в стейкинг кому угодно.

---

### 2. Restricted-кошелек

Эта настройка заменяет стандартный кошелек на [restricted wallet](https://github.com/EmelyanenkoK/nomination-contract/blob/master/restricted-wallet/wallet.fc), который позволяет отправлять исходящие транзакции только заранее определенным адресам назначения, таким как *Избиратель* и *Владелец*.

![image](/img/nominator-pool/restricted-wallet.png)

Данный тип кошелька не обслуживается (заменен на Пул номинаторов) и имеет нерешенные векторы атак, например, атаки на трату газа. Поскольку в одном и том же кошельке на одном балансе хранятся и плата за газ и основная сумма ставки, злоумышленник, скомпрометировавший приватный ключ, может генерировать транзакции, что повлечет за собой значительные убытки. Кроме того, при попытке вывода средств злоумышленник и владелец могут столкнуться с состоянием гонки из-за коллизий seqno.

---

### 3. Пул номинаторов

[Пул номинаторов](https://github.com/ton-blockchain/nominator-pool) первым ввел четкое разграничение между владельцами ставок (номинаторами) и валидатором, подключенным к интернету. Пул номинаторов поддерживает до 40 номинаторов, делающих ставки вместе на одном валидаторе.

![image](/img/nominator-pool/nominator-pool.png)

Смарт-контракт пул номинаторов чрезмерно сложен из-за поддержки 40 одновременно работающих номинаторов. Также, контракт должен защищать номинаторов от диплоера контракта, поскольку это отдельные сущности. Такая схема считается нормальной, но ее очень сложно проверить полностью из-за размера поверхности атаки. Это решение имеет смысл в том случае, если валидатор не имеет достаточно средств на стейкинг для самостоятельной валидации или хочет разделить прибыль со сторонними стейкхолдерами.

---

### 4. Single nominator

Именно такая настройка реализована в этом репо. Это очень упрощенная версия пула номинаторов, которая поддерживает одного номинатора и не нуждается в защите этого номинатора от разработчика смарт-контракта, поскольку они являются одной и той же сущностью.

![image](/img/nominator-pool/single-nominator-architecture.png)

Если у вас есть single nominator, который располагает всеми ставками для валидации, это самая надежная схема, которую можно использовать. Помимо простоты, этот смарт-контракт позволяет использовать владельцу различные аварийные защитные функции, например, восстановление ставки при возможном сценарии обновления *Избирателя*, которое может разрушить интерфейс восстановления ставки.

### Сообщения владельца

Владелец номинатора может выполнить 4 операции:

#### 1. `withdraw`

Используется для вывода средств на кошелек владельца. Чтобы вывести средства, владелец должен отправить сообщение, содержащее: opcode=0x1000 (32 бита), query_id (64 бита) и сумму вывода (переменная coin). Смарт-контракт номинатора отправит средства с флагом BOUNCEABLE и mode=64. <br/><br/>
Если владелец использует **горячий кошелек** (не рекомендуется), [withdraw-deeplink.ts](https://github.com/ton-blockchain/single-nominator/blob/main/scripts/ts/withdraw-deeplink.ts) может использоваться для создания deeplink, чтобы инициировать вывод средств с кошелька tonkeeper. <br/>
Командная строка: `ts-node scripts/ts/withdraw-deeplink.ts single-nominator-addr withdraw-amount`, где:

- single-nominator-addr – адрес single nominator, с которого владелец хочет вывести средства.
- withdraw-amount – сумма вывода. Смарт-контракт номинатора оставит в контракте 1 TON, поэтому фактическая сумма, которая будет отправлена на адрес владельца, будет минимальной между запрошенной суммой и балансом контракта -1. <br/>
  Владелец должен запустить deeplink с телефона с кошельком tonkeeper. <br/>

Если владелец использует **холодный кошелек** (рекомендуется), [withdraw.fif](https://github.com/ton-blockchain/single-nominator/blob/main/scripts/fift/withdraw.fif) может использоваться для создания тела boc, содержащего опкод withdraw и сумму для вывода. <br/>
Командная строка: `fift -s scripts/fif/withdraw.fif withdraw-amount`, <br/> где withdraw-amount – сумма для вывода средств из контракта номинатора на кошелек владельца. Как указано выше, в контракте номинатора будет оставлено не менее 1 TON. <br/>
Этот скрипт сгенерирует тело boc (с именем withdraw.boc), которое должно быть подписано и отправлено с кошелька владельца. <br/>
С черного компьютера владелец должен запустить:

- создайте и подпишите tx: `fift -s wallet-v3.fif my-wallet single_nominator_address sub_wallet_id seqno amount -B withdraw.boc`, где my-wallet – это pk-файл владельца (без расширения). Суммы 1 TON должно быть достаточно, чтобы оплатить комиссию (оставшаяся сумма будет возвращена владельцу). Файл withdraw.boc – это boc, сгенерированный выше.
- с компьютера с доступом в интернет выполните следующие действия: `lite-client -C global.config.json -c 'sendfile wallet-query.boc'`, чтобы отправить boc-файл (wallet-query.boc), созданный на предыдущем шаге.

#### 2. `change-validator`

Используется для изменения адреса валидатора. Валидатор может отправить избирателю только NEW_STAKE и RECOVER_STAKE. Если приватный ключ валидатора был скомпрометирован, адрес валидатора может быть изменен. Обратите внимание, что в этом случае средства находятся в безопасности, так как только владелец может вывести средства.<br/>

Если владелец использует **горячий кошелек** (не рекомендуется), [change-validator-deeplink.ts](https://github.com/ton-blockchain/single-nominator/blob/main/scripts/ts/change-validator-deeplink.ts) может использоваться для создания deeplink, чтобы изменить адрес валидатора. <br/>
Командная строка: `ts-node scripts/ts/change-validator-deeplink.ts single-nominator-addr new-validator-address`, где:

- single-nominator-addr – адрес  single nominator.
- new-validator-address (по-умолчанию адрес ZERO) – это адрес нового валидатора. Если вы хотите сразу же отключить валидатора и установить нового позже, возможно, будет удобно установить в качестве адреса валидатора адрес ZERO. Владелец должен запустить deeplink с телефона с кошельком tonkeeper. <br/>

Если владелец использует **холодный кошелек** (рекомендуется), [change-validator.fif](https://github.com/ton-blockchain/single-nominator/blob/main/scripts/fift/change-validator.fif) может использоваться для создания тела boc, содержащего опкод change-validator и новый адрес валидатора. <br/>
Командная строка: `fift -s scripts/fif/change-validator.fif new-validator-address`.
Этот скрипт сгенерирует тело boc (с именем change-validator.boc), которое должно быть подписано и отправлено из кошелька владельца. <br/>
С черного компьютера владелец должен запустить:

- создайте и подпишите tx: `fift -s wallet-v3.fif my-wallet single_nominator_address sub_wallet_id seqno amount -B change-validator.boc`, где my-wallet – это pk-файл владельца (без расширения). Суммы 1 TON должно быть достаточно, чтобы оплатить комиссию (оставшаяся сумма будет возвращена владельцу). Файл change-validator.boc – это boc, сгенерированный выше.
- с компьютера с доступом в интернет выполните следующие действия: `lite-client -C global.config.json -c 'sendfile wallet-query.boc'`, чтобы отправить boc-файл (wallet-query.boc), созданный на предыдущем шаге.

#### 3. `send-raw-msg`

Этот опкод не предполагается для использования в обычных условиях. <br/>
Опкод предназначен для отправки **любого** сообщения из смарт-контракта номинатора (должно быть подписано и отправлено из кошелька владельца). <br/>
Вы можете использовать этот опкод, когда адрес смарт-контракта избирателя был неожиданно изменен, и средства все еще заблокированы у избирателя. В этом случае RECOVER_STAKE от валидатора не сработает, и владельцу придется создавать определенное сообщение. <br/>
Тело сообщения должно содержать: opcode=0x7702 (32 бита), query_id (64 бита), mode (8 бит), ссылку на ячейку msg, которая будет отправлена как необработанное сообщение. <br/>

#### 4. `upgrade`

Экстренный опкод, который, вероятно, никогда не должен быть использован.<br/>
Опкод предназначен для обновления смарт-контракта номинатора. <br/>
Тело сообщения должно содержать: opcode=0x9903 (32 бита), query_id (64 бита), ссылку на новую ячейку кода. <br/>

## См. также

- [Single Nominator Pool](https://github.com/ton-blockchain/single-nominator)
- [Как использовать Single Nominator Pool](/v3/guidelines/smart-contracts/howto/single-nominator-pool)
- [Orbs Single Nominator Pool (legacy)](https://github.com/orbs-network/single-nominator)








================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/vesting-contract.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/vesting-contract.mdx
================================================
# Контракт на вестинг

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Этот контракт позволяет вам заблокировать определенное количество Toncoin на определенное время и постепенно разблокировать их.

## Параметры вестинга

Параметры вестинга не изменяются и устанавливаются во время развертывания.

`vesting_total_amount` - в nanoton, общее количество заблокированных Toncoin.

`vesting_start_time` - unixtime, начальная точка периода вестинга, до этого момента `vesting_total_amount` заблокирован, после этого он начинает разблокироваться в соответствии с другими параметрами.

`vesting_total_duration` - общая продолжительность вестинга в секундах (например, `31104000` на один год).

`unlock_period` - период разблокировки в секундах (например, `2592000` один раз в месяц).

`cliff_duration` - начальный период без разблокировки в секундах (например, `5184000` на 2 месяца).

`vesting_sender_address` - адрес, на который вы можете вернуть Toncoin (даже если они заблокированы) в любое время; также этот адрес может добавить белый список.

`owner_address` - тот, кому был выдан вестинг, с этого адреса он может инициировать отправку Toncoin из контракта вестинга.

Вы можете получить эти параметры с помощью метода `get_vesting_data()` get-method.

Параметры должны удовлетворять следующим условиям:

```
vesting_total_duration > 0
vesting_total_duration <= 135 years (2^32 seconds)
unlock_period > 0
unlock_period <= vesting_total_duration
cliff_duration >= 0
cliff_duration < vesting_total_duration
vesting_total_duration mod unlock_period == 0
cliff_duration mod unlock_period == 0
```

Хотя смарт-контракт не проверяет соответствие этим условиям, после развертывания контракта и перед отправкой ему Toncoin пользователь может проверить, что все параметры в порядке, с помощью метода get-method.

## Блокировка

До `vesting_start_time` все `vesting_total_amount` заблокированы.

Начиная с `vesting_start_time` сумма начинает пропорционально разблокироваться.

Например, если `vesting_total_duration` составляет 10 месяцев, а `unlock_period` - 1 месяц, а `vesting_total_amount` - 500 TON, то каждый месяц будет разблокироваться 500\*(10/100)=50 TON, и через 10 месяцев будут разблокированы все 500 TON.

Если есть период без разблокировки, в течение этого периода ничего не разблокируется, а после его окончания сумма разблокируется в соответствии с приведенной выше формулой.

Например, если `cliff_period` составляет 3 месяца, а другие параметры такие же, как в предыдущем примере, то первые 3 месяца ничего не будет разблокировано, а через 3 месяца сразу будет разблокировано 150 TON (а затем по 50 TON каждый месяц).

Метод получения `get_locked_amount(int at_time)` позволяет рассчитать, сколько будет заблокировано в определенный момент времени.

Вы можете отправлять заблокированные Toncoin только на адреса из белого списка или `vesting_sender_address`.

Вы можете отправлять разблокированные Toncoin когда и куда захотите.

## Белый список

Белый список — это список адресов, на которые вы можете отправлять Toncoin, даже если монеты все еще заблокированы.

Метод получения `get_whitelist()` возвращает все адреса из белого списка в виде списка кортежей (wc, hash_part).

Метод получения `is_whitelisted(slice address)` проверяет, находится ли этот адрес в белом списке.

`vesting_sender_address` может добавлять новые адреса в белый список в любое время с помощью сообщения `op::add_whitelist`.

Невозможно удалить адрес из белого списка.

Кроме того, заблокированные монеты всегда можно отправлять на `vesting_sender_address` (их не нужно отдельно добавлять в белый список).

## Пополнение

Вы можете отправлять Toncoin в контракт вестинга с любого адреса.

## Смарт-контракт кошелька

Этот контракт разработан аналогично [стандартному смарт-контракту кошелька V3](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc).

В своих данных он хранит `seqno`, `subwallet_id`, `public_key` и принимает внешние сообщения того же формата.

Доступны методы получения `seqno()`, `get_subwallet_id()` и `get_public_key()`.

В отличие от стандартного кошелька, контракт вестинга позволяет отправлять только одно сообщение за раз.

## Отправка

Владелец открытого ключа может инициировать отправку Toncoin из контракта вестинга внешним сообщением, как в стандартных кошельках.

Отправка Toncoin также может быть инициирована внутренним сообщением `op::send`, отправленным с `owner_address`.

На практике и открытый ключ, и `owner_address` принадлежат одному и тому же пользователю.

## Ограничения в отношении белого списка

Сообщения, которые можно отправлять на `vesting_sender_address`, имеют следующие ограничения:

- разрешен только `send_mode == 3`;

В большинстве случаев адреса добавляются в белый список, чтобы позволить пользователю выполнять проверку с помощью заблокированных монет или закладывать заблокированные монеты в пулы.

Чтобы избежать кражи Toncoin, сообщения, которые можно отправлять в белый список, имеют следующие ограничения:

- разрешен только `send_mode == 3`;

- разрешены только сообщения с возможностью возврата;

- не разрешено вложение `state_init`;

Если пункт назначения — адрес системного избирателя:

- разрешены только операции `op::elector_new_stake`, `op::elector_recover_stake`, `op::vote_for_complaint`, `op::vote_for_proposal`;

Если пункт назначения — адрес системной конфигурации:

- разрешена только операция `op::vote_for_proposal`;

Для других пунктов назначения:

- разрешены пустые сообщения и пустые текстовые сообщения;
- разрешены текстовые сообщения, начинающиеся только с "d", "w", "D", "W";
- разрешены операции `op::single_nominator_pool_withdraw`, `op::single_nominator_pool_change_validator`, `op::ton_stakers_deposit`, `op::jetton_burn`, `op::ton_stakers_vote`, `op::vote_for_proposal`, `op::vote_for_complaint`;

Нет ограничений на адреса, не включенные в белый список.

Никаких ограничений не применяется при отправке разблокированных Toncoin, даже если мы отправляем в белый список или `vesting_sender_address`.

## Структура проекта

- `contracts` - исходный код всех смарт-контрактов проекта и их зависимостей.
- `wrappers` - классы-обертки (реализующие `Contract` из ton-core) для контрактов, включая любые примитивы [де]сериализации и функции компиляции.
- `tests` - тесты для контрактов.
- `scripts` - скрипты, используемые проектом, в основном скрипты развертывания.

## Как использовать

### Сборка

`npx blueprint build` или `yarn blueprint build`.

### Тестирование

`npx blueprint test` или `yarn blueprint test`.

### Развертывание или запуск другого скрипта

`npx blueprint run` или `yarn blueprint run`.

### Добавить новый контракт

`npx blueprint create ContractName` или `yarn blueprint create ContractName`.

## См. также

- [Единый номинатор](/v3/documentation/smart-contracts/contracts-specs/single-nominator-pool)
- [vesting-contract](https://github.com/ton-blockchain/vesting-contract)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/wallet-contracts.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/contracts-specs/wallet-contracts.md
================================================
import ConceptImage from '@site/src/components/conceptImage';
import ThemedImage from '@theme/ThemedImage';

# Типы контрактов кошелька

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Возможно, вы слышали о различных версиях кошельков на блокчейне TON. Но что на самом деле означают эти версии и чем отличаются?

В этой статье мы рассмотрим различные версии и модификации кошельков TON.

:::info
Before we start, there are some terms and concepts that you should be familiar with to fully understand the article:

- [Управление сообщениями](/v3/documentation/smart-contracts/message-management/messages-and-transactions) – поскольку это основная функциональность кошельков.
- [Язык FunC](/v3/documentation/smart-contracts/func/overview) – потому что мы будем в значительной степени полагаться на реализации, сделанные с его помощью.
  :::

## Общая концепция

Чтобы разрушить напряжение, для начала мы должны понять, что кошельки не являются особой сущностью в экосистеме TON. Они по-прежнему являются всего лишь смарт-контрактами, состоящими из кода и данных, и в этом смысле равны любому другому субъекту (т.е. смарт-контракту) в TON.

Как и ваш собственный или любой другой смарт-контракт, кошельки могут принимать внешние и внутренние сообщения, отправлять внутренние сообщения и логи, а также использовать GET-методы.
Поэтому возникает вопрос: какую функциональность предоставляют кошельки и чем она отличается в разных версиях?

Вы можете рассматривать каждую версию кошелька как реализацию смарт-контракта, предоставляющую стандартный внешний интерфейс, позволяющий различным внешним клиентам взаимодействовать с кошельками одинаковым образом. Вы можете найти эти реализации на языках FunC и Fift в основном репозитарии TON:

- [ton/crypto/smartcont/](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/)

## Базовые кошельки

### Кошелек V1

Это самый простой вариант кошелька. Он позволяет вам отправлять только четыре транзакции одновременно и не проверяет ничего, кроме вашей подписи и seqno.

Исходный код кошелька:

- [ton/crypto/smartcont/wallet-code.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/new-wallet.fif)

Эта версия кошелька даже не используется в обычных приложениях, потому что у нее есть серьезные проблемы:

- Нет простого способа получить seqno и публичный ключ из контракта.
- Нет проверки `valid_until`, поэтому вы не можете быть уверены, что транзакция не будет подтверждена слишком поздно.

Первая проблема была исправлена в `V1R2` и `V1R3`. Символ `R` означает "ревизия". Обычно ревизии – это небольшие обновления, которые добавляют только GET-методы (вы можете найти историю изменений в файле `new-wallet.fif`). Здесь и далее мы будем рассматривать только последние ревизии.

Тем не менее, поскольку каждая последующая версия наследует функциональность предыдущей, нам все равно следует придерживаться ее, поскольку это поможет нам в последующих версиях.

#### Расположение постоянной памяти

- <b>seqno</b>: 32-битный порядковый номер.
- <b>public-key</b>: 256-битный публичный ключ.

#### Оформление тела внешнего сообщения

1. Данные:
  - <b>подпись</b>: 512-битная подпись ed25519.
  - <b>msg-seqno</b>: 32-битный порядковый номер.
  - <b>(0-4)mode</b>: до четырех 8-битных целых чисел, определяющих режим отправки для каждого сообщения.
2. До 4 ссылок на ячейки, содержащие сообщения.

Как вы можете видеть, основная функциональность кошелька заключается в обеспечении безопасного способа связи с блокчейном TON из внешнего мира. Механизм `seqno` защищает от атак повторного воспроизведения, а подпись `Ed25519` обеспечивает авторизованный доступ к функционалу кошелька. Мы не будем подробно останавливаться на каждом из этих механизмов, поскольку они подробно описаны на странице документации [external message](/v3/documentation/smart-contracts/message-management/external-messages) и довольно часто встречаются среди смарт-контрактов, получающих внешние сообщения. Данные полезной нагрузки состоят из до 4 ссылок на ячейки и соответствующего количества режимов, которые будут непосредственно переданы в метод [send_raw_message(cell msg, int mode)](/v3/documentation/smart-contracts/func/docs/stdlib#send_raw_message).

:::caution
Обратите внимание, что кошелек не обеспечивает никакой проверки внутренних сообщений, которые вы отправляете через него. Ответственность за сериализацию данных в соответствии с [макетом внутреннего сообщения](http://localhost:3000/v3/documentation/smart-contracts/message-management/sending-messages#message-layout) лежит на программисте (т.е. внешнем клиенте).
:::

#### Коды завершения

| Код завершения | Описание                                               |
| -------------- | ------------------------------------------------------ |
| 0x21           | Проверка `seqno` не выполнена, сработала защита ответа |
| 0x22           | Проверка `Ed25519 signature` не выполнена              |
| 0x0            | Стандартный код завершения при успешном выполнении     |

:::info
Обратите внимание, что у [TVM](/v3/documentation/tvm/tvm-overview) есть [стандартные коды завершения](/v3/documentation/tvm/tvm-exit-codes) (`0x0` – один из них), поэтому вы также можете получить один из них, например, если у вас закончился [газ](https://docs.ton.org/develop/smart-contracts/fees), то вы получите код `0xD`.
:::

#### GET-методы

1. int `seqno()` – возвращает текущий сохраненный seqno.
2. int `get_public_key` – возвращает текущий сохраненный публичный ключ.

### Кошелек V2

Исходный код кошелька:

- [ton/crypto/smartcont/wallet-code.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet-code.fc)

В данной версии появился параметр `valid_until`, который используется для установки временного ограничения для транзакции, если вы не хотите, чтобы она была подтверждена слишком поздно. В этой версии также отсутствует get-метод для публичного ключа, который был добавлен в `V2R2`.

Все отличия по сравнению с предыдущей версией являются следствием добавления функциональности `valid_until`. Был добавлен новый код завершения: `0x23`, отмечающий неудачу при проверке `valid_until`. Кроме того, в макет тела внешнего сообщения было добавлено новое поле `Unix-time`, задающее временной лимит транзакции. Все GET-методы остаются прежними.

#### Содержимое тела внешнего сообщения

1. Данные:
  - <b>signature</b>: 512-битная подпись ed25519.
  - <b>msg-seqno</b>: 32-битный порядковый номер.
  - <b>valid-until</b>: 32-битное целое число Unix-time.
  - <b>(0-4)mode</b>: до четырех 8-битных целых чисел, определяющих режим отправки для каждого сообщения.
2. До 4 ссылок на ячейки, содержащие сообщения.

### Кошелек V3

В этой версии появился параметр `subwallet_id`, который позволяет вам создавать несколько кошельков, используя один и тот же публичный ключ (таким образом, у вас может быть только одна seed-фраза и несколько кошельков). Как и раньше, `V3R2` добавляет только метод get-метод для публичного ключа.

Исходный код кошелька:

- [ton/crypto/smartcont/wallet3-code.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/wallet3-code.fc)

По сути, `subwallet_id` – это просто число, добавляемое к состоянию контракта при его развертывании. Поскольку адрес контракта в TON представляет собой хэш его состояния и код, адрес кошелька изменится на другой `subwallet_id`. Эта версия наиболее широко используется в настоящее время. Она охватывает большинство случаев использования и остается универсальной, простой и в основном такой же, как и предыдущие версии. Все GET-методы остаются прежними.

#### Содержимое постоянной памяти

- <b>seqno</b>: 32-битный порядковый номер.
- <b>subwallet</b>: 32-битный идентификатор subwallet.
- <b>public-key</b>: 256-битный публичный ключ.

#### Содержимое внешнего сообщения

1. Данные:
  - <b>подпись</b>: 512-битная подпись ed25519.
  - <b>subwallet-id</b>: 32-битный идентификатор subwallet.
  - <b>msg-seqno</b>: 32-битный порядковый номер.
  - <b>valid-until</b>: 32-битное целое число Unix-time.
  - <b>(0-4)mode</b>: до четырех 8-битных целых чисел, определяющих режим отправки для каждого сообщения.
2. До 4 ссылок на ячейки, содержащие сообщения.

#### Коды завершения

| Код завершения | Описание                                                                                              |
| -------------- | ----------------------------------------------------------------------------------------------------- |
| 0x23           | Проверка `valid_until` не выполнена; попытка подтверждения транзакции была предпринята слишком поздно |
| 0x23           | Проверка `Ed25519 signature` не выполнена                                                             |
| 0x21           | Проверка `seqno` не выполнена, сработала защита ответа                                                |
| 0x22           | `subwallet-id` не совпадает с сохраненным                                                             |
| 0x0            | Стандартный код завершения при успешном выполнении                                                    |

### Кошелек V4

Эта версия сохраняет всю функциональность предыдущих версий, но также вводит нечто очень мощное: *плагины (plugins)*.

Исходный код кошелька:

- [ton-blockchain/wallet-contract](https://github.com/ton-blockchain/wallet-contract)

Эта функция позволяет разработчикам реализовать сложную логику, которая работает в тандеме с кошельком пользователя. Например, DApp может потребовать от пользователя платить небольшое количество монет каждый день, чтобы пользоваться определенными функциями. В этом случае пользователю нужно будет установить плагин на свой кошелек, подписав транзакцию. Затем плагин будет ежедневно отправлять монеты на адрес назначения по запросу из внешнего сообщения.

#### Плагины

Плагины – это, по сути, другие смарт-контракты на TON, которые разработчики могут реализовывать по своему усмотрению. По отношению к кошельку они представляют собой просто адреса смарт-контрактов, хранящиеся в [словаре](/v3/documentation/smart-contracts/func/docs/dictionaries) в постоянной памяти кошелька. Этим плагинам разрешено запрашивать средства и удалять себя из "разрешенного списка", отправляя внутренние сообщения кошельку.

#### Содержимое постоянной памяти

- <b>seqno</b>: 32-битный порядковый номер.
- <b>subwallet-id</b>: 32-битный идентификатор subwallet.
- <b>public-key</b>: 256-битный публичный ключ.
- <b>plugins</b>: словарь, содержащий плагины (может быть пустым).

#### Получение внутренних сообщений

Все предыдущие версии кошельков имели простую реализацию получения внутренних сообщений. Они просто принимали поступающие средства от любого отправителя, игнорируя тело внутреннего сообщения, если оно присутствовало, или, другими словами, у них был пустой метод `recv_internal`. Однако, как уже упоминалось ранее, в четвертой версии кошелька появились две дополнительные доступные операции. Давайте посмотрим на структуру тела внутреннего сообщения:

- <b>op-code</b>: 32-битный код операции. Это необязательное поле: любое сообщение, содержащее менее 32 бит в теле сообщения, либо неправильный oпкод или адрес отправителя, не зарегистрированный в качестве плагина, будет рассматриваться как простая отправка, аналогично предыдущим версиям кошелька.
- <b>query-id</b>: 64-битное целое число. Это поле не влияет на поведение смарт-контракта, оно используется для отслеживания цепочек сообщений между контрактами.

1. op-code = 0x706c7567, код операции запроса средств:
  - <b>toncoins</b>: VARUINT16 количество запрашиваемых toncoin.
  - <b>extra_currencies</b>: словарь, содержащий количество запрашиваемых дополнительных валют (может быть пустым).
2. op-code = 0x64737472, запрос на удаление плагина-отправителя из "разрешенного списка".

#### Содержимое тела внешнего сообщения

- <b>signature</b>: 512-битная подпись ed25519.
- <b>subwallet-id</b>: 32-битный идентификатор subwallet.
- <b>valid-until</b>: 32-битное целое число Unix-time.
- <b>msg-seqno</b>: 32-битное длинное целое число последовательности.
- <b>op-code</b>: 32-битный код операции.

1. op-code = 0x0, простая отправка:
  - <b>(0-4)mode</b>: до четырех 8-битных целых чисел, определяющих режим отправки для каждого сообщения.
  - <b>(0-4)сообщения</b>:До четырех ссылок на ячейки, содержащие сообщения.
2. op-code = 0x1, развертывание и установка плагина:
  - <b>workchain</b>: 8-битное целое число.
  - <b>balance</b>: VARUINT16 количество toncoin начального баланса.
  - <b>state-init</b>: ссылка на ячейку, содержащую начальное состояние плагина.
  - <b>body</b>: ссылка на ячейку, содержащую тело.
3. op-code = 0x2/0x3, установка плагина/удаление плагина:
  - <b>wc_n_address</b>: 8-битный workchain_id + 256-битный адрес плагина.
  - <b>balance</b>: VARUINT16 сумма toncoin начального баланса.
  - <b>query-id</b>: 64-битное целое число.

Как вы можете видеть, четвертая версия по-прежнему предоставляет стандартную функциональность через оп-код `0x0`, как и предыдущие версии. Оп-коды `0x2` и `0x3` позволяют производить манипуляции со словарем плагинов. Обратите внимание, что в случае с `0x2` вам необходимо самостоятельно развернуть плагин с этим адресом, в отличие от оп-кода `0x1`, который также управляет процессом развертывания, но с помощью поля `state_init`.

:::tip
If `state_init` doesn't make much sense from its name, take a look at the following references:

- [адреса-в-блокчейне-TON](/v3/documentation/smart-contracts/addresses#workchain-id-and-account-id)
- [отправка-сообщения-о-развертывании](/v3/documentation/smart-contracts/func/cookbook#how-to-send-a-deploy-message-with-stateinit-only-with-stateinit-and-body)
- [содержимое-внутреннего-сообщения](/v3/documentation/smart-contracts/message-management/sending-messages#message-layout)
  :::

#### Коды завершения

| Код завершения | Описание                                                                                                                       |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| 0x24           | Проверка `valid_until` не выполнена, попытка подтверждения транзакции была предпринята слишком поздно                          |
| 0x23           | Проверка `Ed25519 signature` не выполнена                                                                                      |
| 0x21           | Проверка `seqno` не выполнена, сработала защита ответа                                                                         |
| 0x22           | `subwallet-id` не совпадает с сохраненным                                                                                      |
| 0x27           | Не удалось выполнить манипуляции со словарем плагинов (0x1-0x3 recv_external op-codes) |
| 0x50           | Недостаточно средств для запроса средств                                                                                       |
| 0x0            | Стандартный код завершения при успешном выполнении                                                                             |

#### GET-методы

1. int `seqno()` – возвращает текущий сохраненный seqno.
2. int `get_public_key()` – возвращает текущий сохраненный публичный ключ.
3. int `get_subwallet_id()` – возвращает идентификатор текущего subwallet.
4. int `is_plugin_installed (int wc, int addr_hash)` – проверяет, установлен ли плагин с определенным воркчейн идентификатором и хэшем адреса.
5. Кортеж `get_plugin_list()` – возвращает список плагинов.

### Кошелек V5

На данный момент это самая современная версия кошелька, разработанная командой Tonkeeper, направленная на замену четвертой версии и допускающая произвольные расширения. <br></br>
<ThemedImage
alt=""
sources={{
light: '/img/docs/wallet-contracts/wallet-contract-V5.png?raw=true',
dark: '/img/docs/wallet-contracts/wallet-contract-V5_dark.png?raw=true',
}}
/> <br></br><br></br><br></br>
Стандарт пятой версии кошелька предлагает множество преимуществ, которые улучшают опыт как для пользователей, так и для продавцов. Данная версия поддерживает транзакции без газа, делегирование и восстановление аккаунта, оплату подписки с использованием токенов и toncoin, а также недорогие мультипереводы. Помимо сохранения предыдущей функциональности, новая версия контракта позволяет отправлять до 255 сообщений одновременно.

Исходный код кошелька:

- [ton-blockchain/wallet-contract-v5](https://github.com/ton-blockchain/wallet-contract-v5)

Схема TL-B:

- [ton-blockchain/wallet-contract-v5/types.tlb](https://github.com/ton-blockchain/wallet-contract-v5/blob/main/types.tlb)

:::caution
В отличие от предыдущих спецификаций версий кошельков, мы будем использовать схему [TL-B](/v3/documentation/data-formats/tlb/tl-b-language) из-за относительной сложности реализации интерфейса этой версии кошелька. Мы дадим некоторое описание каждого из них. Тем не менее, базовое понимание все равно необходимо, в сочетании с исходным кодом кошелька этого должно быть достаточно.
:::

#### Содержимое постоянной памяти

```
contract_state$_
    is_signature_allowed:(## 1)
    seqno:#
    wallet_id:(## 32)
    public_key:(## 256)
    extensions_dict:(HashmapE 256 int1) = ContractState;
```

Как вы видите, `contractState` по сравнению с предыдущими версиями, не претерпел серьезных изменений. Основным отличием является новый 1-битный флаг `is_signature_allowed`, который ограничивает или разрешает доступ через подпись и хранящийся публичный ключ. Мы опишем важность этого изменения в дальнейшем.

#### Процесс аутентификации

```
signed_request$_             // 32 (opcode from outer)
  wallet_id:    #            // 32
  valid_until:  #            // 32
  msg_seqno:    #            // 32
  inner:        InnerRequest //
  signature:    bits512      // 512
= SignedRequest;             // Total: 688 .. 976 + ^Cell

internal_signed#73696e74 signed:SignedRequest = InternalMsgBody;

internal_extension#6578746e
    query_id:(## 64)
    inner:InnerRequest = InternalMsgBody;

external_signed#7369676e signed:SignedRequest = ExternalMsgBody;
```

Прежде чем мы перейдем собственно к полезной нагрузке наших сообщений – `InnerRequest`, давайте сначала посмотрим, чем пятая версия отличается от предыдущих версий в части процесса аутентификации. Комбинатор `InternalMsgBody` описывает два варианта доступа к действиям кошелька через внутренние сообщения. Первый вариант нам уже знаком по версии 4: аутентификация в качестве ранее зарегистрированного расширения, адрес которого хранится в `extensions_dict`. Второй вариант – аутентификация с помощью хранящегося публичного ключа и подписи, аналогично внешним запросам.

Сначала это может показаться ненужной функцией, но на самом деле она позволяет обрабатывать запросы через внешние сервисы (смарт-контракты), которые не являются частью инфраструктуры расширения вашего кошелька – ключевая особенность пятой версии. Безгазовые транзакции полагаются на эту функциональность.

Обратите внимание, что простое получение средств по-прежнему является доступным. Практически же, любое полученное внутреннее сообщение, не прошедшее процесс аутентификации, будет считаться переводом.

#### Действия

Первое, на что следует обратить внимание, это `InnerRequest`, который мы уже видели в процессе аутентификации. В отличие от предыдущей версии, и внешние и внутренние сообщения имеют доступ к одной и той же функциональности, за исключением изменения режима подписи (т.е. флага `is_signature_allowed`).

```
out_list_empty$_ = OutList 0;
out_list$_ {n:#}
    prev:^(OutList n)
    action:OutAction = OutList (n + 1);

action_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction;

// Extended actions in V5:
action_list_basic$_ {n:#} actions:^(OutList n) = ActionList n 0;
action_list_extended$_ {m:#} {n:#} action:ExtendedAction prev:^(ActionList n m) = ActionList n (m+1);

action_add_ext#02 addr:MsgAddressInt = ExtendedAction;
action_delete_ext#03 addr:MsgAddressInt = ExtendedAction;
action_set_signature_auth_allowed#04 allowed:(## 1) = ExtendedAction;

actions$_ out_actions:(Maybe OutList) has_other_actions:(## 1) {m:#} {n:#} other_actions:(ActionList n m) = InnerRequest;
```

Мы можем рассматривать `InnerRequest` как два списка действий:`OutList` – представляет собой необязательную цепочку ссылок на ячейки, каждая из которых содержит запрос на отправку сообщения, инициируемый режимом сообщения.`ActionList` – инициируется однобитным флагом, `has_other_actions`, который отмечает наличие расширенных действий, начиная с первой ячейки и далее в виде цепочки ссылок на ячейки. Мы уже знакомы с первыми двумя расширенными действиями, `action_add_ext` и `action_delete_ext`, за которыми следует внутренний адрес, который мы хотим добавить или удалить из словаря расширений. Третье действие, `action_set_signature_auth_allowed`, ограничивает или разрешает аутентификацию через публичный ключ, оставляя единственный способ взаимодействия с кошельком через расширения. Эта функциональность может оказаться чрезвычайно важной в случае потери или компрометации приватного ключа.

:::info
Обратите внимание, что максимальное количество действий равно 255 – это следствие реализации через [c5 TVM-регистр](/v3/documentation/tvm/tvm-overview#result-of-tvm-execution). Технически, вы можете сделать запрос с пустыми `OutAction` и `ExtendedAction`, но в таком случае это будет похоже на простое получение средств.
:::

#### Коды завершения

| Код завершения | Описание                                                                                                                        |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 0x84           | Попытка аутентификации через подпись, когда она отключена                                                                       |
| 0x85           | Проверка `seqno` не выполнена, сработала защита ответа                                                                          |
| 0x86           | `wallet-id` не соответствует сохраненному                                                                                       |
| 0x87           | Проверка `Ed25519 signature` не выполнена                                                                                       |
| 0x88           | Проверка `valid-until` не выполнена                                                                                             |
| 0x89           | Убедитесь, что в `send_mode` установлен бит +2 (игнорировать ошибки) для внешнего сообщения. |
| 0x8A           | Префикс `external-signed` не соответствует полученному префиксу                                                                 |
| 0x8B           | Операция добавления расширения была неуспешной                                                                                  |
| 0x8C           | Операция удаления расширения была неуспешной                                                                                    |
| 0x8D           | Неподдерживаемый расширенный префикс сообщения                                                                                  |
| 0x8E           | Попытка отключения аутентификации по подписи, пока словарь расширений пуст                                                      |
| 0x8F           | Попытка установить подпись в уже установленное состояние                                                                        |
| 0x90           | Попытка удаления последнего расширения, когда подпись отключена                                                                 |
| 0x91           | Расширение имеет неправильный воркчейн                                                                                          |
| 0x92           | Попытка изменения режима подписи с помощью внешнего сообщения                                                                   |
| 0x93           | Недопустимый `c5`, проверка `action_send_msg` не выполнена                                                                      |
| 0x0            | Стандартный код завершения при успешном выполнении                                                                              |

:::danger
Обратите внимание, что коды завершения `0x8E`, `0x90` и `0x92` кошелька предназначены для того, чтобы вы не потеряли доступ к функциям кошелька. Тем не менее, вам следует помнить, что кошелек не проверяет, существуют ли сохраненные адреса расширений в TON на самом деле. Вы также можете развернуть кошелек с начальными данными, состоящими из пустого словаря расширений и ограниченного режима подписи. В этом случае вы сможете получить доступ к кошельку через публичный ключ до тех пор, пока не добавите свое первое расширение. Поэтому будьте осторожны с такими сценариями.
:::

#### GET-методы

1. int `is_signature_allowed()` – возвращает сохраненный `is_signature_allowed` флаг.
2. int `seqno()` – возвращает текущий сохраненный seqno.
3. int `get_subwallet_id()` – возвращает идентификатор текущего subwallet.
4. int `get_public_key()` – возвращает текущий сохраненный публичный ключ.
5. cell `get_extensions()` – возвращает словарь расширений.

#### Подготовка к безгазовым транзакциям

Как было сказано ранее, смарт-контракт кошелька v5 позволяет обрабатывать внутренние сообщения, подписанные владельцем. Это также позволяет совершать безгазовые транзакции, например, оплачивать сетевые комиссии при переводе USDt в сам USDt. Общая схема выглядит следующим образом:

![image](/img/gasless.jpg)

:::tip
В следствие этого, будут существовать сервисы (такие как [Tonkeeper's Battery](https://blog.ton.org/tonkeeper-releases-huge-update#tonkeeper-battery)), предоставляющие данную функциональность: они выплачивают комиссию за транзакцию в TON от имени пользователя, но взимают данную комиссию в токенах.
:::

#### Пользовательский путь

1. При отправке USDt пользователь подписывает одно сообщение, содержащее два исходящих перевода USDt:
  1. Перевод USDt на адрес получателя.
  2. Перевод небольшой суммы USDt в пользу Сервиса.
2. Это подписанное сообщение отправляется off-chain по HTTPS на бэкэнд Сервиса. Бэкэнд Сервиса отправляет его в блокчейн TON, выплачивая toncoin за комиссию сети.

Бета-версия безгазового бэкэнда API доступна на [tonapi.io/api-v2](https://tonapi.io/api-v2). Если вы разрабатываете какое-либо приложение для кошелька и у вас есть отзывы об этих методах, пожалуйста, поделитесь ими в чате [@tonapitech](https://t.me/tonapitech).

Исходный код кошелька:

- [ton-blockchain/wallet-contract-v5](https://github.com/ton-blockchain/wallet-contract-v5)

## Специальные кошельки

Иногда функциональности базовых кошельков недостаточно. Поэтому существует несколько типов специализированных кошельков: `high-load`, `lockup` и `restricted`.

Давайте посмотрим на них.

### Highload-кошельки

При работе с большим количеством сообщений за короткий промежуток времени возникает необходимость в специальном кошельке, называемом Highload Wallet. Прочитайте [статью](/v3/documentation/smart-contracts/contracts-specs/highload-wallet) для получения дополнительной информации.

### Lockup-кошелек

Если вам по какой-то причине нужно на некоторое время заблокировать монеты в кошельке без возможности их вывести до истечения этого времени, обратите внимание на lockup-кошелек.

Данный типа кошелька позволяет вам установить время, до которого вы не сможете ничего вывести из кошелька. Вы также можете настроить его, установив периоды разблокировки, чтобы получить возможность тратить монеты в течение этих периодов.

Например: вы можете создать кошелек, в котором будет храниться 1 миллион монет с общим сроком наделения правами 10 лет (`total duration`). Установите продолжительность блокировки (`cliff_diration`) на один год, таким образом, средства будут заблокированы в течение первого года после создания кошелька. Затем вы можете установить период разблокировки (`unlock_period`) в один месяц таким образом `1 000 000 TON / 120 месяцев = ~8333 TON` будут разблокированы каждый месяц.

Исходный код кошелька:

- [ton-blockchain/lockup-wallet-contract](https://github.com/ton-blockchain/lockup-wallet-contract)

### Restricted-кошелек

Функциональность данного кошелька заключается в том, чтобы выступать в роли обычного кошелька, но ограничивать переводы только одним заранее определенным адресом назначения. Вы можете задать адрес назначения при создании этого кошелька, и тогда вы сможете переводить средства с него только на этот адрес. Но обратите внимание, что вы все еще можете переводить средства на контракты валидации, так что вы можете запустить валидатора с помощью этого кошелька.

Исходный код кошелька:

- [EmelyanenkoK/nomination-contract/restricted-wallet](https://github.com/EmelyanenkoK/nomination-contract/tree/master/restricted-wallet)

## Известные оп-коды

Как видите, в TON существует множество различных версий кошельков. Но в большинстве случаев вам нужны только `V3R2` или `V4R2`. Вы также можете использовать один из специальных кошельков, если вам нужна какая-то дополнительная функциональность, например, периодическая разблокировка средств.

## См. также

- [Работа со смарт-контрактами кошелька](/v3/guidelines/smart-contracts/howto/wallet)
- [Источники базовых кошельков](https://github.com/ton-blockchain/ton/tree/master/crypto/smartcont)
- [Более подробное техническое описание версий](https://github.com/toncenter/tonweb/blob/master/src/contract/wallet/WalletSources.md)
- [Источники и подробное описание Wallet V4](https://github.com/ton-blockchain/wallet-contract)
- [Источники блокировки кошелька и подробное описание](https://github.com/ton-blockchain/lockup-wallet-contract)
- [Источники с ограниченным кошельком](https://github.com/EmelyanenkoK/nomination-contract/tree/master/restricted-wallet)
- [Безгазовые операции на TON](https://medium.com/@buidlingmachine/gasless-transactions-on-ton-75469259eff2)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/fift-and-tvm-assembly.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/fift-and-tvm-assembly.md
================================================
# Сборка Fift и TVM

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Fift — это язык программирования на основе стека, который имеет специфичные для TON функции и, следовательно, может работать с ячейками. Сборка TVM — это также язык программирования на основе стека, также специфичный для TON, и он также может работать с ячейками. Так в чем же разница между ними?

## В чем разница

Fift выполняется **во время компиляции** — когда ваш компилятор создает код смарт-контракта BOC, после обработки кода FunC. Fift может выглядеть по-разному:

```
// tuple primitives
x{6F0} @Defop(4u) TUPLE
x{6F00} @Defop NIL
x{6F01} @Defop SINGLE
x{6F02} dup @Defop PAIR @Defop CONS
```

> Определения кодов операций TVM в Asm.fif

```
"Asm.fif" include
<{ SETCP0 DUP IFNOTRET // return if recv_internal
   DUP 85143 INT EQUAL OVER 78748 INT EQUAL OR IFJMP:<{ // "seqno" and "get_public_key" get-methods
     1 INT AND c4 PUSHCTR CTOS 32 LDU 32 LDU NIP 256 PLDU CONDSEL  // cnt or pubk
   }>
   INC 32 THROWIF	// fail unless recv_external
   9 PUSHPOW2 LDSLICEX DUP 32 LDU 32 LDU 32 LDU 	//  signature in_msg subwallet_id valid_until msg_seqno cs
   NOW s1 s3 XCHG LEQ 35 THROWIF	//  signature in_msg subwallet_id cs msg_seqno
   c4 PUSH CTOS 32 LDU 32 LDU 256 LDU ENDS	//  signature in_msg subwallet_id cs msg_seqno stored_seqno stored_subwallet public_key
   s3 s2 XCPU EQUAL 33 THROWIFNOT	//  signature in_msg subwallet_id cs public_key stored_seqno stored_subwallet
   s4 s4 XCPU EQUAL 34 THROWIFNOT	//  signature in_msg stored_subwallet cs public_key stored_seqno
   s0 s4 XCHG HASHSU	//  signature stored_seqno stored_subwallet cs public_key msg_hash
   s0 s5 s5 XC2PU	//  public_key stored_seqno stored_subwallet cs msg_hash signature public_key
   CHKSIGNU 35 THROWIFNOT	//  public_key stored_seqno stored_subwallet cs
   ACCEPT
   WHILE:<{
     DUP SREFS	//  public_key stored_seqno stored_subwallet cs _51
   }>DO<{	//  public_key stored_seqno stored_subwallet cs
     8 LDU LDREF s0 s2 XCHG	//  public_key stored_seqno stored_subwallet cs _56 mode
     SENDRAWMSG
   }>	//  public_key stored_seqno stored_subwallet cs
   ENDS SWAP INC	//  public_key stored_subwallet seqno'
   NEWC 32 STU 32 STU 256 STU ENDC c4 POP
}>c
```

> wallet_v3_r2.fif

Последний фрагмент кода выглядит как сборка TVM, и большая его часть на самом деле таковой и является Как это может произойти?

Представьте, что вы разговариваете с программистом-стажером и говорите ему: "А теперь добавьте команды, выполняющие это, это и то, в конец функции". Ваши команды оказываются в программе стажера. Они обрабатываются дважды — как и здесь, коды операций написанные заглавными буквами (SETCP0, DUP и т. д.) обрабатываются как Fift, так и TVM.

Вы можете объяснить высокоуровневые абстракции своему стажеру, в конечном итоге он поймет и сможет их использовать. Fift также расширяем — вы можете определять свои собственные команды. Фактически, Asm[Tests].fif полностью посвящен определению кодов операций TVM.

Коды операций TVM, с другой стороны, выполняются **во время выполнения** — это код смарт-контрактов. Их можно рассматривать как программу вашего стажера — сборка TVM может делать меньше вещей (например, у нее нет встроенных примитивов для подписи данных — потому что все, что TVM делает в блокчейне, является публичным), но она действительно может взаимодействовать со своей средой.

## Использование в смарт-контрактах

### [Fift] — Помещение большого BOC в контракт

Это возможно, если вы используете `toncli`. Если вы используете другие компиляторы для сборки контракта, возможно, есть другие способы включить большой BOC.
Отредактируйте `project.yaml` так, чтобы `fift/blob.fif` был включен при сборке кода смарт-контракта:

```
contract:
  fift:
    - fift/blob.fif
  func:
    - func/code.fc
```

Поместите BOC в `fift/blob.boc`, затем добавьте следующий код в `fift/blob.fif`:

```
<b 8 4 u, 8 4 u, "fift/blob.boc" file>B B>boc ref, b> <s @Defop LDBLOB
```

Теперь вы можете извлечь этот blob из смарт-контракта:

```
cell load_blob() asm "LDBLOB";

() recv_internal() {
    send_raw_message(load_blob(), 160);
}
```

### [Сборка TVM] - Преобразование целого числа в строку

К сожалению, попытка преобразования int в строку с использованием примитивов Fift завершилась неудачей.

```
slice int_to_string(int x) asm "(.) $>s PUSHSLICE";
```

Причина очевидна: Fift выполняет вычисления во время компиляции, где еще нет `x`, доступного для преобразования. Чтобы преобразовать непостоянное целое число в фрагмент строки, вам нужна сборка TVM. Например, это код одного из участников TON Smart Challenge 3:

```
tuple digitize_number(int value)
  asm "NIL WHILE:<{ OVER }>DO<{ SWAP TEN DIVMOD s1 s2 XCHG TPUSH }> NIP";

builder store_number(builder msg, tuple t)
  asm "WHILE:<{ DUP TLEN }>DO<{ TPOP 48 ADDCONST ROT 8 STU SWAP }> DROP";

builder store_signed(builder msg, int v) inline_ref {
  if (v < 0) {
    return msg.store_uint(45, 8).store_number(digitize_number(- v));
  } elseif (v == 0) {
    return msg.store_uint(48, 8);
  } else {
    return msg.store_number(digitize_number(v));
  }
}
```

### [Сборка TVM] - Дешевое умножение по модулю

```
int mul_mod(int a, int b, int m) inline_ref {               ;; 1232 gas units
  (_, int r) = muldivmod(a % m, b % m, m);
  return r;
}
int mul_mod_better(int a, int b, int m) inline_ref {        ;; 1110 gas units
  (_, int r) = muldivmod(a, b, m);
  return r;
}
int mul_mod_best(int a, int b, int m) asm "x{A988} s,";     ;; 65 gas units
```

`x{A988}` - это код операции, отформатированный в соответствии с [5.2 Деление](/v3/documentation/tvm/instructions#A988): деление с предварительным умножением, где единственным возвращаемым результатом является остаток по модулю третьего аргумента. Но код операции должен попасть в код смарт-контракта - именно это и делает `s,`: он сохраняет фрагмент поверх стека в сборщике немного ниже.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/fift-deep-dive.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/fift-deep-dive.md
================================================
# Глубокое погружение в Fift

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Высокоуровневый стековый язык Fift используется для локальной манипуляции ячейками и другими примитивами TVM, в основном для преобразования ассемблерного кода TVM в код контракта bag-of-cells.

:::caution
В этом разделе описывается взаимодействие с специфичными для TON функциями на **очень** низком уровне.
Требуется серьезное понимание основ стековых языков.
:::

## Простая арифметика

Вы можете использовать интерпретатор Fift как калькулятор, записывая выражения в [обратной польской нотации](https://en.wikipedia.org/wiki/Reverse_Polish_notation).

```
6 17 17 * * 289 + .
2023 ok
```

## Стандартный выход

```
27 emit ."[30;1mgrey text" 27 emit ."[37m"
grey text ok
```

`emit` берет число с вершины стека и выводит символ Unicode с указанным кодом в stdout.
`."..."` выводит строку-константу.

## Определение функций (Fift-слов)

Основной способ определения слова - заключить его значения в фигурные скобки, затем написать ":" и название слова.

```
{ minmax drop } : min
{ minmax nip } : max
```

> Fift.fif

Хотя есть несколько "определяющих слов", а не только ":". Они отличаются в смысле слов, определяемых некоторыми из них, **активные** (работают внутри фигурных скобок), а некоторые **префиксные** (не требуют пробела после них):

```
{ bl word 1 2 ' (create) } "::" 1 (create)
{ bl word 0 2 ' (create) } :: :
{ bl word 2 2 ' (create) } :: :_
{ bl word 3 2 ' (create) } :: ::_
{ bl word 0 (create) } : create
```

> Fift.fif

## Условное выполнение

Блоки кода (разделенные фигурными скобками) могут выполняться как условно, так и безоговорочно.

```
{ { ."true " } { ."false " } cond } : ?.   4 5 = ?.  4 5 < ?.
false true  ok
{ ."hello " } execute ."world"
hello world ok
```

## Циклы

```
// ( l c -- l')  deletes first c elements from list l
{ ' safe-cdr swap times } : list-delete-first
```

> GetOpt.fif

Слово цикла `times` принимает два аргумента — назовем их `cont` и `n` — и выполняет `cont` `n` раз.
Здесь `list-delete-first` берет продолжение `safe-cdr` (команда удаления заголовка из списка в стиле Lisp), помещает его под `c`, а затем `c` times удаляет заголовок из списка, присутствующего в стеке.

Есть также слова `while` и `until`.

## Комментарии

```
{ 0 word drop 0 'nop } :: //
{ char " word 1 { swap { abort } if drop } } ::_ abort"
{ { bl word dup "" $= abort"comment extends after end of file" "*/" $= } until 0 'nop } :: /*
```

> Fift.fif

Комментарии определены в `Fift.fif`. Однострочный комментарий начинается с `//` и продолжается до конца строки; многострочный комментарий начинается с `/*` и заканчивается `*/`.

Давайте разберемся, почему они так работают.
Программа Fift по сути является последовательностью слов, каждое из которых каким-либо образом преобразует стек или определяет новые слова. Первая строка `Fift.fif` (код показан выше) является объявлением нового слова `//`.
Комментарии должны работать даже при определении новых слов, поэтому они должны работать во вложенной среде. Вот почему они определены как **активные** слова с помощью `::`. Действия создаваемого слова перечислены в фигурных скобках:

1. `0`: ноль помещается в стек
2. `word`: эта команда считывает символы до тех пор, пока не будет достигнут один, равный вершине стека, и помещает считанные данные в стек как строку. Ноль — это особый случай: здесь `word` пропускает начальные пробелы и затем читает до конца текущей входной строки.
3. `drop`: верхний элемент (данные комментария) удаляется из стека.
4. `0`: ноль снова помещается в стек — число результатов, использованное потому, что слово определено как `::`.
5. `nop` помещает токен выполнения, ничего не делая при вызове. Это практически эквивалентно `{ nop }`.

## Использование Fift для определения кодов сборки TVM

```
x{00} @Defop NOP
{ 1 ' @addop does create } : @Defop
{ tuck sbitrefs @ensurebitrefs swap s, } : @addop
{ @havebitrefs ' @| ifnot } : @ensurebitrefs
{ 2 pick brembitrefs 1- 2x<= } : @havebitrefs
{ rot >= -rot <= and } : 2x<=
...
```

> Asm.fif (порядок строк обратный)

`@Defop` проверяет, достаточно ли места для кода операции (`@havebitrefs`), и если его нет, он продолжает запись в другой сборщик (`@|`; также известно как неявный переход). Вот почему вы обычно не хотите писать `x{A988} s` в качестве кода операции: для размещения этого кода операции может быть недостаточно места, поэтому компиляция завершится неудачей; вместо этого вам следует написать `x{A988} @addop`.

Вы можете использовать Fift для включения большого bag-of-cells в контракт:

```
<b 8 4 u, 8 4 u, "fift/blob.boc" file>B B>boc ref, b> <s @Defop LDBLOB
```

Эта команда определяет код операции, который при включении в программу записывает `x{88}` (`PUSHREF`) и ссылку на предоставленный bag-of-cells. Поэтому, когда запускается инструкция `LDBLOB`, она помещает ячейку в стек TVM.

## Специальные возможности

- Шифрование Ed25519
 - newkeypair - генерирует пару закрытый-открытый ключ
 - priv>pub - генерирует открытый ключ из закрытого
 - ed25519_sign[_uint] - генерирует подпись по заданным данным и закрытому ключу
 - ed25519_chksign - проверяет подпись Ed25519
- Взаимодействие с TVM
 - runvmcode и подобное - вызывает TVM с фрагментом кода, взятым из стека
- Запись BOC в файлы:
 `boc>B ".../contract.boc" B>file`

## Продолжаем изучение

- [Fift: Краткое введение](https://docs.ton.org/fiftbase.pdf) Николая Дурова



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/overview.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/fift/overview.mdx
================================================
import Button from '@site/src/components/button'

# Общие сведения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Fift — это стековый язык программирования общего назначения, оптимизированный для создания, отладки и управления смарт-контрактами блокчейна TON.
Fift был специально разработан для взаимодействия с виртуальной машиной TON (TON VM или TVM) и блокчейном TON.

```fift
{ ."hello " } execute ."world"
hello world ok
```

:::info
Usually, using the Fift is not required for programming smart contracts in TON. However, Sometimes, you may need to use the Fift language to solve uncommon technical challenges as part of your task.
You might be interested in:

- [TVM Retracer](https://retracer.ton.org/)
  :::

<Button href="https://blog.ton.org/introduction-to-fift"
colorType="primary" sizeType={'sm'}>

Введение в Fift

</Button>

<Button href="https://www.youtube.com/watch?v=HVsveTmVowc&list=PLtUBO1QNEKwttRsAs9eacL2oCMOhWaOZs"
          colorType="secondary" sizeType={'sm'}>

Его величество Fift

</Button>

<br></br><br></br>

## Документация

- [Fift: Краткое введение](https://ton.org/fiftbase.pdf)
- [Виртуальная машина TON](/v3/documentation/tvm/tvm-overview)

## Примеры

- [Примеры смарт-контрактов Fift](/v3/documentation/smart-contracts/contracts-specs/examples#fift-smart-contracts)

## Руководства

- [Введение в Fift](https://blog.ton.org/introduction-to-fift)
- [[YouTube]Его величество Fift](https://www.youtube.com/watch?v=HVsveTmVowc&list=PLtUBO1QNEKwttRsAs9eacL2oCMOhWaOZs) [[RU версия](https://www.youtube.com/playlist?list=PLyDBPwv9EPsCYG-hR4N5FRTKUkfM8POgh)] от **@MarcoDaTr0p0je** и **@Wikimar**.

## Исходный код

- [Скрипты Fift для стандартных смарт-контрактов](https://github.com/ton-blockchain/ton/tree/master/crypto/smartcont)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/changelog.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/changelog.md
================================================
# История FunC

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

# Первоначальная версия

Первоначальная версия была создана Telegram, и активная разработка была прекращена после мая 2020 года. Мы называем версию мая 2020 года "начальной".

# Версия 0.1.0

Выпущена в [обновлении 05.2022](https://github.com/ton-blockchain/ton/releases/tag/v2022.05).

В этой версии добавлены:

- [Константы](/v3/documentation/smart-contracts/func/docs/literals_identifiers#constants)
- [Расширенные строковые литералы](/v3/documentation/smart-contracts/func/docs/literals_identifiers#string-literals)
- [Семантическое версионирование](/v3/documentation/smart-contracts/func/docs/compiler_directives#pragma-version)
- [Включения](/v3/documentation/smart-contracts/func/docs/compiler_directives#pragma-version)

Исправлено:

- Исправлены редко проявляющиеся ошибки в Asm.fif.

# Версия 0.2.0

Выпущена в [обновлении 08.2022](https://github.com/ton-blockchain/ton/releases/tag/v2022.08).

В этой версии добавлено:

- Несбалансированные ветви if/else (когда некоторые ветви возвращаются, а некоторые нет)

Исправлено:

- [FunC неправильно обрабатывает циклы while(false) #377](https://github.com/ton-blockchain/ton/issues/377)
- [FunC неправильно генерирует код для ветвей ifelse #374](https://github.com/ton-blockchain/ton/issues/374)
- [FunC неправильно возвращает из условия во встроенных функциях #370](https://github.com/ton-blockchain/ton/issues/370)
- [Asm.fif: разбиение больших функциональных блоков некорректно влияет на встроенные строки #375](https://github.com/ton-blockchain/ton/issues/375)

# Версия 0.3.0

Выпущено в [обновлении 10.2022](https://github.com/ton-blockchain/ton/releases/tag/v2022.10).

В этой версии добавлены:

- [Многострочные asms](/v3/documentation/smart-contracts/func/docs/functions#multiline-asms)
- Разрешено дублирование идентичных определений для констант и asms
- Разрешены побитовые операции с константами для констант

# Версия 0.4.0

Выпущено в [обновлении 01.2023](https://github.com/ton-blockchain/ton/releases/tag/v2023.01).

В этой версии добавлены:

- [Инструкции try/catch](/v3/documentation/smart-contracts/func/docs/statements#try-catch-statements)
- [Функции throw_arg](/v3/documentation/smart-contracts/func/docs/builtins#throwing-exceptions)
- Разрешены модификации и массовое присвоение глобальных переменных: `a~inc()` и `(a, b) = (3, 5)`, где `a` является глобальной

Исправлено:

- Запрещена неоднозначная модификация локальных переменных после их использования в том же выражении: `var x = (ds, ds~load_uint(32), ds~load_unit(64));` запрещены, а `var x = (ds~load_uint(32), ds~load_unit(64), ds);` нет
- Разрешено пустые встроенные функции
- Исправлена ​​редкая ошибка оптимизации `while`



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/cookbook.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/cookbook.md
================================================
# Кулинарная книга FunC

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Основная цель создания кулинарной книги FunC - собрать весь опыт разработчиков FunC в одном месте, чтобы будущие разработчики могли им воспользоваться!

По сравнению с [документацией FunC](/v3/documentation/smart-contracts/func/docs/types), эта статья больше сосредоточена на повседневных задачах каждого разработчика FunC, которые необходимо решать при разработке смарт-контрактов.

## Основы

### Как написать оператор if

Допустим, мы хотим проверить, имеет ли значение какое-либо событие. Для этого мы используем переменную флага. Помните, что в FunC `true` — это `-1`, а `false` — это `0`.

```func
int flag = 0; ;; false

if (flag) { 
    ;; do something
}
else {
    ;; reject the transaction
}
```

> 💡 Примечание
>
> Нам не нужен оператор `==`, потому что значение `0` — это `false`, поэтому любое другое значение будет `true`.

> 💡 Полезные ссылки
>
> ["Оператор If" в документации](/v3/documentation/smart-contracts/func/docs/statements#if-statements)

### Как написать цикл repeat

Как пример, возьмем возведение в степень

```func
int number = 2;
int multiplier = number;
int degree = 5;

repeat(degree - 1) {

    number *= multiplier;
}
```

> 💡 Полезные ссылки
>
> ["Цикл repeat" в документации](/v3/documentation/smart-contracts/func/docs/statements#repeat-loop)

### Как написать цикл while

While полезен, когда мы не знаем, как часто выполнять определенное действие. Например, возьмем `cell`, которая, как известно, хранит до четырех ссылок на другие ячейки.

```func
cell inner_cell = begin_cell() ;; create a new empty builder
        .store_uint(123, 16) ;; store uint with value 123 and length 16 bits
        .end_cell(); ;; convert builder to a cell

cell message = begin_cell()
        .store_ref(inner_cell) ;; store cell as reference
        .store_ref(inner_cell)
        .end_cell();

slice msg = message.begin_parse(); ;; convert cell to slice
while (msg.slice_refs_empty?() != -1) { ;; we should remind that -1 is true
    cell inner_cell = msg~load_ref(); ;; load cell from slice msg
    ;; do something
}
```

> 💡 Полезные ссылки
>
> ["Цикл while" в документации](/v3/documentation/smart-contracts/func/docs/statements#while-loop)
>
> ["Cell" в документации](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage)
>
> ["slice_refs_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#slice_refs_empty)
>
> ["store_ref()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_ref)
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#end_cell)
>
> ["begin_parse()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_parse)

### Как написать цикл do until

Когда нам нужно, чтобы цикл выполнился хотя бы один раз, мы используем `do until`.

```func
int flag = 0;

do {
    ;; do something even flag is false (0) 
} until (flag == -1); ;; -1 is true
```

> 💡 Полезные ссылки
>
> ["Until loop" в документации](/v3/documentation/smart-contracts/func/docs/statements#until-loop)

### Как определить, пуст ли срез

Перед тем, как работать с `slice`, необходимо проверить, есть ли у него какие-либо данные, чтобы правильно их обработать. Для этого можно использовать `slice_empty?()`, но нужно учитывать, что он вернет `0` (`false`), если есть хотя бы один `bit` данных или одна `ref`.

```func
;; creating empty slice
slice empty_slice = "";
;; `slice_empty?()` returns `true`, because slice doesn't have any `bits` and `refs`
empty_slice.slice_empty?();

;; creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";
;; `slice_empty?()` returns `false`, because slice have any `bits`
slice_with_bits_only.slice_empty?();

;; creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_empty?()` returns `false`, because slice have any `refs`
slice_with_refs_only.slice_empty?();

;; creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_empty?()` returns `false`, because slice have any `bits` and `refs`
slice_with_bits_and_refs.slice_empty?();
```

> 💡 Полезные ссылки
>
> ["slice_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#slice_empty)
>
> ["store_slice()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_slice)
>
> ["store_ref()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_ref)
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#end_cell)
>
> ["begin_parse()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_parse)

### Как определить, является ли срез пустым (не имеет битов, но может иметь ссылки)

Если нам нужно проверить только `bits` и неважно, есть ли какие-либо `refs` в `slice`, то нам следует использовать `slice_data_empty?()`.

```func
;; creating empty slice
slice empty_slice = "";
;; `slice_data_empty?()` returns `true`, because slice doesn't have any `bits`
empty_slice.slice_data_empty?();

;; creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";
;; `slice_data_empty?()` returns `false`, because slice have any `bits`
slice_with_bits_only.slice_data_empty?();

;; creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_data_empty?()` returns `true`, because slice doesn't have any `bits`
slice_with_refs_only.slice_data_empty?();

;; creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_data_empty?()` returns `false`, because slice have any `bits`
slice_with_bits_and_refs.slice_data_empty?();
```

> 💡 Полезные ссылки
>
> ["slice_data_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#slice_data_empty)
>
> ["store_slice()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_slice)
>
> ["store_ref()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_ref)
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#end_cell)
>
> ["begin_parse()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_parse)

### Как определить, является ли срез пустым (не имеет ссылок, но может иметь биты)

В случае, если нас интересуют только `refs`, мы должны проверить их наличие с помощью `slice_refs_empty?()`.

```func
;; creating empty slice
slice empty_slice = "";
;; `slice_refs_empty?()` returns `true`, because slice doesn't have any `refs`
empty_slice.slice_refs_empty?();

;; creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";
;; `slice_refs_empty?()` returns `true`, because slice doesn't have any `refs`
slice_with_bits_only.slice_refs_empty?();

;; creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_refs_empty?()` returns `false`, because slice have any `refs`
slice_with_refs_only.slice_refs_empty?();

;; creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")
    .store_ref(null())
    .end_cell()
    .begin_parse();
;; `slice_refs_empty?()` returns `false`, because slice have any `refs`
slice_with_bits_and_refs.slice_refs_empty?();
```

> 💡 Полезные ссылки
>
> ["slice_refs_empty?()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#slice_refs_empty)
>
> ["store_slice()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#store_slice)
>
> ["store_ref()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#store_ref)
>
> ["begin_cell()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["end_cell()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#end_cell)
>
> ["begin_parse()" в документациии](/v3/documentation/smart-contracts/func/docs/stdlib#begin_parse)

### Как определить, пуста ли ячейка

Чтобы проверить, есть ли какие-либо данные в `cell`, мы должны сначала преобразовать ее в `slice`. Если нас интересуют только `bits`, мы должны использовать `slice_data_empty?()`, если только `refs` - `slice_refs_empty?()`. В случае, если мы хотим проверить наличие каких-либо данных, независимо от того, являются ли они `bit` или `ref`, мы должны использовать `slice_empty?()`.

```func
cell cell_with_bits_and_refs = begin_cell()
    .store_uint(1337, 16)
    .store_ref(null())
    .end_cell();

;; Change `cell` type to slice with `begin_parse()`
slice cs = cell_with_bits_and_refs.begin_parse();

;; determine if slice is empty
if (cs.slice_empty?()) {
    ;; cell is empty
}
else {
    ;; cell is not empty
}
```

> 💡 Полезные ссылки
>
> ["slice_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#slice_empty)
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["store_uint()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_uint)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#end_cell)
>
> ["begin_parse()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_parse)

### Как определить, пуст ли словарь

Существует метод `dict_empty?()` для проверки наличия данных в словаре. Этот метод эквивалентен `cell_null?()`, поскольку обычно `null`-ячейка является пустым словарем.

```func
cell d = new_dict();
d~udict_set(256, 0, "hello");
d~udict_set(256, 1, "world");

if (d.dict_empty?()) { ;; Determine if dict is empty
    ;; dict is empty
}
else {
    ;; dict is not empty
}
```

> 💡 Полезные ссылки
>
> ["dict_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#dict_empty)
>
> ["new_dict()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#new_dict) создание пустого словаря
>
> ["dict_set()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dict_set) добавление некоторых элементов в словарь d с помощью функции, чтобы он не был пустым

### Как определить, пуст ли кортеж

При работе с `tuples` всегда важно знать, есть ли внутри какие-либо значения для извлечения. Если мы попытаемся извлечь значение из пустого `tuple`, то получим ошибку: "кортеж недопустимого размера" с `exit code 7`.

```func
;; Declare tlen function because it's not presented in stdlib
(int) tlen (tuple t) asm "TLEN";

() main () {
    tuple t = empty_tuple();
    t~tpush(13);
    t~tpush(37);

    if (t.tlen() == 0) {
        ;; tuple is empty
    }
    else {
        ;; tuple is not empty
    }
}
```

> 💡 Примечание
>
> Мы объявляем функцию сборки tlen. Вы можете прочитать больше [здесь](/v3/documentation/smart-contracts/func/docs/functions#assembler-function-body-definition) и посмотреть [список всех команд ассемблера](/v3/documentation/tvm/instructions).

> 💡 Полезные ссылки
>
> ["empty_tuple?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#empty_tuple)
>
> ["tpush()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#tpush)
>
> ["Коды выхода" в документации](/v3/documentation/tvm/tvm-exit-codes)

### Как определить, пуст ли lisp-подобный список

```func
tuple numbers = null();
numbers = cons(100, numbers);

if (numbers.null?()) {
    ;; list-style list is empty
} else {
    ;; list-style list is not empty
}
```

Мы добавляем число 100 в наш lisp-подобный список с помощью функции [cons](/v3/documentation/smart-contracts/func/docs/stdlib/#cons), поэтому он не пуст.

### Как определить, что состояние контракта пустое

Допустим, у нас есть `counter`, который хранит количество транзакций. Эта переменная недоступна во время первой транзакции в состоянии смарт-контракта, поскольку состояние пустое, поэтому необходимо обработать такой случай. Если состояние пустое, мы создаем переменную `counter` и сохраняем ее.

```func
;; `get_data()` will return the data cell from contract state
cell contract_data = get_data();
slice cs = contract_data.begin_parse();

if (cs.slice_empty?()) {
    ;; contract data is empty, so we create counter and save it
    int counter = 1;
    ;; create cell, add counter and save in contract state
    set_data(begin_cell().store_uint(counter, 32).end_cell());
}
else {
    ;; contract data is not empty, so we get our counter, increase it and save
    ;; we should specify correct length of our counter in bits
    int counter = cs~load_uint(32) + 1;
    set_data(begin_cell().store_uint(counter, 32).end_cell());
}
```

> 💡 Примечание
>
> Мы можем определить, что состояние контракта пустое, определив, что [ячейка пуста](/v3/documentation/smart-contracts/func/cookbook#how-to-determine-if-cell-is-empty).

> 💡 Полезные ссылки
>
> ["get_data()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#get_data)
>
> ["begin_parse()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#begin_parse)
>
> ["slice_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice_empty)
>
> ["set_data?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#set_data)

### Как построить ячейку внутреннего сообщения

Если мы хотим, чтобы контракт отправлял внутреннее сообщение, мы должны сначала правильно создать его как ячейку, указав технические флаги, адрес получателя и остальные данные.

```func
;; We use literal `a` to get valid address inside slice from string containing address 
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
;; we use `op` for identifying operations
int op = 0;

cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(op, 32)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors 
```

> 💡 Примечание
>
> В этом примере мы используем литерал `a` для получения адреса. Подробнее о строковых литералах можно узнать в [документации](/v3/documentation/smart-contracts/func/docs/literals_identifiers#string-literals)

> 💡 Примечание
>
> Подробнее можно узнать в [документации](/v3/documentation/smart-contracts/message-management/sending-messages). Также можно перейти к [макету](/v3/documentation/smart-contracts/message-management/sending-messages#message-layout) по этой ссылке.

> 💡 Полезные ссылки
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["store_uint()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_uint)
>
> ["store_slice()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_slice)
>
> ["store_coins()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_coins)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#end_cell)
>
> ["send_raw_message()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#send_raw_message)

### Как включить тело в качестве ссылки на внутреннюю ячейку сообщения

В теле сообщения, которое следует за флагами и другими техническими данными, мы можем отправить `int`, `slice` и `cell`. В последнем случае необходимо установить бит равным `1` перед `store_ref()`, чтобы указать, что `cell` будет продолжена.

Мы также можем отправить тело сообщения внутри той же `cell`, что и заголовок, если уверены, что у нас достаточно места. В этом случае нам нужно установить бит равным `0`.

```func
;; We use literal `a` to get valid address inside slice from string containing address 
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
int op = 0;
cell message_body = begin_cell() ;; Creating a cell with message
    .store_uint(op, 32)
    .store_slice("❤")
.end_cell();
    
cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; default message headers (see sending messages page)
    .store_uint(1, 1) ;; set bit to 1 to indicate that the cell will go on
    .store_ref(message_body)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors 
```

> 💡 Примечание
>
> В этом примере мы используем литерал `a` для получения адреса. Подробнее о строковых литералах можно узнать в [документации](/v3/documentation/smart-contracts/func/docs/literals_identifiers#string-literals)

> 💡 Примечание
>
> В этом примере мы использовали режим 3, чтобы взять входящие ton и отправить ровно столько, сколько указано (сумма), при этом выплачивая комиссию с баланса контракта и игнорируя ошибки. Режим 64 необходим для возврата всех полученных ton, вычитая комиссию, а режим 128 отправит весь баланс.

> 💡 Примечание
>
> Мы [создаем сообщение](/v3/documentation/smart-contracts/func/cookbook#how-to-build-an-internal-message-cell), но добавляем тело сообщения отдельно.

> 💡 Полезные ссылки
>
> ["begin_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#begin_cell)
>
> ["store_uint()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_uint)
>
> ["store_slice()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_slice)
>
> ["store_coins()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#store_coins)
>
> ["end_cell()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#end_cell)
>
> ["send_raw_message()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#send_raw_message)

### Как включить тело в качестве среза во внутреннюю ячейку сообщения

При отправке сообщений тело сообщения может быть отправлено либо как `cell`, либо как `slice`. В этом примере мы отправляем тело сообщения внутри `slice`.

```func
;; We use literal `a` to get valid address inside slice from string containing address 
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
int op = 0;
slice message_body = "❤"; 

cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(op, 32)
    .store_slice(message_body)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors 
```

> 💡 Примечание
>
> В этом примере мы используем литерал `a` для получения адреса. Подробнее о строковых литералах можно узнать в [документации](/v3/documentation/smart-contracts/func/docs/literals_identifiers#string-literals)

> 💡 Примечание
>
> В этом примере мы использовали режим 3, чтобы взять входящие ton и отправить ровно столько, сколько указано (сумма), при этом выплачивая комиссию из баланса контракта и игнорируя ошибки. Режим 64 необходим для возврата всех полученных ton, вычитая комиссию, а режим 128 отправит весь баланс.

> 💡 Примечание
>
> Мы [строим сообщение](/v3/documentation/smart-contracts/func/cookbook#how-to-build-an-internal-message-cell), но добавляем сообщение как срез.

### Как перебирать кортежи (в обоих направлениях)

Если мы хотим работать с массивом или стеком в FunC, то там понадобится кортеж. И в первую очередь нам нужно уметь перебирать значения, чтобы работать с ними.

```func
(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";

() main () {
    tuple t = to_tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    int len = t.tlen();
    
    int i = 0;
    while (i < len) {
        int x = t.at(i);
        ;; do something with x
        i = i + 1;
    }

    i = len - 1;
    while (i >= 0) {
        int x = t.at(i);
        ;; do something with x
        i = i - 1;
    }
}
```

> 💡 Примечание
>
> Мы объявляем функцию ассемблера `tlen`. Вы можете прочитать больше [здесь](/v3/documentation/smart-contracts/func/docs/functions#assembler-function-body-definition) и посмотреть [список всех команд ассемблера](/v3/documentation/tvm/instructions).
>
> Также мы объявляем функцию `to_tuple`. Она просто изменяет тип данных любого ввода на кортеж, поэтому будьте осторожны при ее использовании.

### Как писать собственные функции с использованием ключевого слова `asm`

При использовании любых функций мы фактически используем заранее подготовленные для нас методы внутри `stdlib.fc`. Но на самом деле, нам доступно гораздо больше возможностей, и нам нужно научиться писать их самим.

Например, у нас есть метод `tpush`, который добавляет элемент в `tuple`, но без `tpop`. В этом случае мы должны сделать это:

```func
;; ~ means it is modifying method
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP"; 
```

Если мы хотим узнать длину `tuple` для итерации, мы должны написать новую функцию с инструкцией `TLEN` asm:

```func
int tuple_length (tuple t) asm "TLEN";
```

Некоторые примеры функций, уже известных нам из stdlib.fc:

```func
slice begin_parse(cell c) asm "CTOS";
builder begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
```

> 💡 Полезные ссылки:
>
> ["Метод изменения" в документации](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods)
>
> ["stdlib" в документации](/v3/documentation/smart-contracts/func/docs/stdlib)
>
> ["Инструкции TVM" в документации](/v3/documentation/tvm/instructions)

### Итерация n-вложенных кортежей

Иногда мы хотим итерировать вложенные кортежи. Следующий пример выполнит итерацию и выведет все элементы в кортеже в формате `[[2,6],[1,[3,[3,5]]], 3]`, начиная с заголовка

```func
int tuple_length (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
forall X -> int is_tuple (X x) asm "ISTUPLE";
forall X -> tuple cast_to_tuple (X x) asm "NOP";
forall X -> int cast_to_int (X x) asm "NOP";
forall X -> (tuple) to_tuple (X x) asm "NOP";

;; define global variable
global int max_value;

() iterate_tuple (tuple t) impure {
    repeat (t.tuple_length()) {
        var value = t~tpop();
        if (is_tuple(value)) {
            tuple tuple_value = cast_to_tuple(value);
            iterate_tuple(tuple_value);
        }
        else {
            if(value > max_value) {
                max_value = value;
            }
        }
    }
}

() main () {
    tuple t = to_tuple([[2,6], [1, [3, [3, 5]]], 3]);
    int len = t.tuple_length();
    max_value = 0; ;; reset max_value;
    iterate_tuple(t); ;; iterate tuple and find max value
    ~dump(max_value); ;; 6
}
```

> 💡 Полезные ссылки
>
> ["Глобальные переменные" в документации](/v3/documentation/smart-contracts/func/docs/global_variables)
>
> ["~dump" в документации](/v3/documentation/smart-contracts/func/docs/builtins#dump-variable)
>
> ["Инструкции TVM" в документации](/v3/documentation/tvm/instructions)

### Основные операции с кортежами

```func
(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

() main () {
    ;; creating an empty tuple
    tuple names = empty_tuple(); 
    
    ;; push new items
    names~tpush("Naito Narihira");
    names~tpush("Shiraki Shinichi");
    names~tpush("Akamatsu Hachemon");
    names~tpush("Takaki Yuichi");
    
    ;; pop last item
    slice last_name = names~tpop();

    ;; get first item
    slice first_name = names.first();

    ;; get an item by index
    slice best_name = names.at(2);

    ;; getting the length of the list 
    int number_names = names.tlen();
}
```

### Определение типа X

В следующем примере проверяется, содержится ли в кортеже какое-либо значение, но кортеж содержит значения X (cell, slice, int, tuple, int). Нам нужно проверить значение и привести его в соответствие.

```func
forall X -> int is_null (X x) asm "ISNULL";
forall X -> int is_int (X x) asm "<{ TRY:<{ 0 PUSHINT ADD DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_cell (X x) asm "<{ TRY:<{ CTOS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_slice (X x) asm "<{ TRY:<{ SBITS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_tuple (X x) asm "ISTUPLE";
forall X -> int cast_to_int (X x) asm "NOP";
forall X -> cell cast_to_cell (X x) asm "NOP";
forall X -> slice cast_to_slice (X x) asm "NOP";
forall X -> tuple cast_to_tuple (X x) asm "NOP";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

forall X -> () resolve_type (X value) impure {
    ;; value here is of type X, since we dont know what is the exact value - we would need to check what is the value and then cast it
    
    if (is_null(value)) {
        ;; do something with the null
    }
    elseif (is_int(value)) {
        int valueAsInt = cast_to_int(value);
        ;; do something with the int
    }
    elseif (is_slice(value)) {
        slice valueAsSlice = cast_to_slice(value);
        ;; do something with the slice
    }
    elseif (is_cell(value)) {
        cell valueAsCell = cast_to_cell(value);
        ;; do something with the cell
    }
    elseif (is_tuple(value)) {
        tuple valueAsTuple = cast_to_tuple(value);
        ;; do something with the tuple
    }
}

() main () {
    ;; creating an empty tuple
    tuple stack = empty_tuple();
    ;; let's say we have tuple and do not know the exact types of them
    stack~tpush("Some text");
    stack~tpush(4);
    ;; we use var because we do not know type of value
    var value = stack~tpop();
    resolve_type(value);
}
```

> 💡 Полезные ссылки
>
> ["Инструкции TVM" в документации](/v3/documentation/tvm/instructions)

### Как получить текущее время

```func
int current_time = now();
  
if (current_time > 1672080143) {
    ;; do some stuff 
}
```

### Как сгенерировать случайное число

:::caution черновик

Ознакомьтесь с [генерацией случайных чисел](/v3/guidelines/smart-contracts/security/random-number-generation) для получения дополнительной информации.
:::

```func
randomize_lt(); ;; do this once

int a = rand(10);
int b = rand(1000000);
int c = random();
```

### Операции по модулю

В качестве примера предположим, что мы хотим выполнить следующее вычисление всех 256 чисел: `(xp + zp)*(xp-zp)`. Поскольку большинство этих операций используются в криптографии, в следующем примере мы используем оператор по модулю для кривых Монтгомери.
Обратите внимание, что xp+zp — это допустимое имя переменной (без пробелов между ними).

```func
(int) modulo_operations (int xp, int zp) {  
   ;; 2^255 - 19 is a prime number for montgomery curves, meaning all operations should be done against its prime
   int prime = 57896044618658097711785492504343953926634992332820282019728792003956564819949; 

   ;; muldivmod handles the next two lines itself
   ;; int xp+zp = (xp + zp) % prime;
   ;; int xp-zp = (xp - zp + prime) % prime;
   (_, int xp+zp*xp-zp) = muldivmod(xp + zp, xp - zp, prime);
   return xp+zp*xp-zp;
}
```

> 💡 Полезные ссылки
>
> ["muldivmod" в документации](/v3/documentation/tvm/instructions#A98C)

### Как вызывать ошибки

```func
int number = 198;

throw_if(35, number > 50); ;; the error will be triggered only if the number is greater than 50

throw_unless(39, number == 198); ;; the error will be triggered only if the number is NOT EQUAL to 198

throw(36); ;; the error will be triggered anyway
```

[Стандартные коды исключений tvm](/v3/documentation/tvm/tvm-exit-codes)

### Переворачивание кортежей

Поскольку кортеж хранит данные в виде стека, иногда нам приходится переворачивать его, чтобы прочитать данные с другого конца.

```func
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
int tuple_length (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";

(tuple) reverse_tuple (tuple t1) {
    tuple t2 = empty_tuple();
    repeat (t1.tuple_length()) {
        var value = t1~tpop();
        t2~tpush(value);
    }
    return t2;
}

() main () {
    tuple t = to_tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    tuple reversed_t = reverse_tuple(t);
    ~dump(reversed_t); ;; [10 9 8 7 6 5 4 3 2 1]
}
```

> 💡 Полезные ссылки
>
> ["tpush()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#tpush)

### Как удалить элемент с определенным индексом из списка

```func
int tlen (tuple t) asm "TLEN";

(tuple, ()) remove_item (tuple old_tuple, int place) {
    tuple new_tuple = empty_tuple();

    int i = 0;
    while (i < old_tuple.tlen()) {
        int el = old_tuple.at(i);
        if (i != place) {
            new_tuple~tpush(el);
        }
        i += 1;  
    }
    return (new_tuple, ());
}

() main () {
    tuple numbers = empty_tuple();

    numbers~tpush(19);
    numbers~tpush(999);
    numbers~tpush(54);

    ~dump(numbers); ;; [19 999 54]

    numbers~remove_item(1); 

    ~dump(numbers); ;; [19 54]
}
```

### Определить, равны ли срезы

Есть два разных способа определить равенство. Один основан на хэше среза, а другой — на использовании инструкции SDEQ asm.

```func
int are_slices_equal_1? (slice a, slice b) {
    return a.slice_hash() == b.slice_hash();
}

int are_slices_equal_2? (slice a, slice b) asm "SDEQ";

() main () {
    slice a = "Some text";
    slice b = "Some text";
    ~dump(are_slices_equal_1?(a, b)); ;; -1 = true

    a = "Text";
    ;; We use literal `a` to get valid address inside slice from string containing address
    b = "EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF"a;
    ~dump(are_slices_equal_2?(a, b)); ;; 0 = false
}
```

#### 💡 Полезные ссылки

- ["slice_hash()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice_hash)
- ["SDEQ" в документации](/v3/documentation/tvm/instructions#C705)

### Определяем, равны ли ячейки

Мы можем легко определить равенство ячеек на основе их хеша.

```func
int are_cells_equal? (cell a, cell b) {
    return a.cell_hash() == b.cell_hash();
}

() main () {
    cell a = begin_cell()
            .store_uint(123, 16)
            .end_cell();

    cell b = begin_cell()
            .store_uint(123, 16)
            .end_cell();

    ~dump(are_cells_equal?(a, b)); ;; -1 = true
}
```

> 💡 Полезные ссылки
>
> ["cell_hash()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#cell_hash)

### Определить, равны ли кортежи

Более продвинутым примером может быть повторение и сравнение каждого из значений кортежа. Поскольку они равны X, нам нужно проверить и привести к соответствующему типу, и, если это кортеж, выполнить его рекурсивную итерацию.

```func
int tuple_length (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
forall X -> int cast_to_int (X x) asm "NOP";
forall X -> cell cast_to_cell (X x) asm "NOP";
forall X -> slice cast_to_slice (X x) asm "NOP";
forall X -> tuple cast_to_tuple (X x) asm "NOP";
forall X -> int is_null (X x) asm "ISNULL";
forall X -> int is_int (X x) asm "<{ TRY:<{ 0 PUSHINT ADD DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_cell (X x) asm "<{ TRY:<{ CTOS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_slice (X x) asm "<{ TRY:<{ SBITS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_tuple (X x) asm "ISTUPLE";
int are_slices_equal? (slice a, slice b) asm "SDEQ";

int are_cells_equal? (cell a, cell b) {
    return a.cell_hash() == b.cell_hash();
}

(int) are_tuples_equal? (tuple t1, tuple t2) {
    int equal? = -1; ;; initial value to true
    
    if (t1.tuple_length() != t2.tuple_length()) {
        ;; if tuples are differ in length they cannot be equal
        return 0;
    }

    int i = t1.tuple_length();
    
    while (i > 0 & equal?) {
        var v1 = t1~tpop();
        var v2 = t2~tpop();
        
        if (is_null(t1) & is_null(t2)) {
            ;; nulls are always equal
        }
        elseif (is_int(v1) & is_int(v2)) {
            if (cast_to_int(v1) != cast_to_int(v2)) {
                equal? = 0;
            }
        }
        elseif (is_slice(v1) & is_slice(v2)) {
            if (~ are_slices_equal?(cast_to_slice(v1), cast_to_slice(v2))) {
                equal? = 0;
            }
        }
        elseif (is_cell(v1) & is_cell(v2)) {
            if (~ are_cells_equal?(cast_to_cell(v1), cast_to_cell(v2))) {
                equal? = 0;
            }
        }
        elseif (is_tuple(v1) & is_tuple(v2)) {
            ;; recursively determine nested tuples
            if (~ are_tuples_equal?(cast_to_tuple(v1), cast_to_tuple(v2))) {
                equal? = 0;
            }
        }
        else {
            equal? = 0;
        }

        i -= 1;
    }

    return equal?;
}

() main () {
    tuple t1 = cast_to_tuple([[2, 6], [1, [3, [3, 5]]], 3]);
    tuple t2 = cast_to_tuple([[2, 6], [1, [3, [3, 5]]], 3]);

    ~dump(are_tuples_equal?(t1, t2)); ;; -1 
}
```

> 💡 Полезные ссылки
>
> ["cell_hash()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#cell_hash)
>
> ["Инструкции TVM" в документации](/v3/documentation/tvm/instructions)

### Генерация внутреннего адреса

Нам нужно сгенерировать внутренний адрес, когда наш контракт должен развернуть новый контракт, но мы не знаем его адрес. Предположим, у нас уже есть `state_init` — код и данные нового контракта.

Создает внутренний адрес для соответствующего MsgAddressInt TLB.

```func
(slice) generate_internal_address (int workchain_id, cell state_init) {
    ;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;

    return begin_cell()
        .store_uint(2, 2) ;; addr_std$10
        .store_uint(0, 1) ;; anycast nothing
        .store_int(workchain_id, 8) ;; workchain_id: -1
        .store_uint(cell_hash(state_init), 256)
    .end_cell().begin_parse();
}

() main () {
    slice deploy_address = generate_internal_address(workchain(), state_init);
    ;; then we can deploy new contract
}
```

> 💡 Примечание
>
> В этом примере мы используем `workchain()` для получения идентификатора воркчейна. Подробнее о идентификаторе воркчейна можно узнать в [документации](/v3/documentation/smart-contracts/addresses#workchain-id).

> 💡 Полезные ссылки
>
> ["cell_hash()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#cell_hash)

### Генерация внешнего адреса

Мы используем схему TL-B из [block.tlb](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L101C1-L101C12), чтобы понять, как нам нужно создать адрес в этом формате.

```func
(int) ubitsize (int a) asm "UBITSIZE";

slice generate_external_address (int address) {
    ;; addr_extern$01 len:(## 9) external_address:(bits len) = MsgAddressExt;
    
    int address_length = ubitsize(address);
    
    return begin_cell()
        .store_uint(1, 2) ;; addr_extern$01
        .store_uint(address_length, 9)
        .store_uint(address, address_length)
    .end_cell().begin_parse();
}
```

Поскольку нам нужно определить количество бит, занимаемых адресом, необходимо также [объявить функцию asm](#how-to-write-own-functions-using-asm-keyword) с кодом операции `UBITSIZE`, которая вернет минимальное количество бит, необходимое для хранения числа.

> 💡 Полезные ссылки
>
> ["Инструкции TVM" в документации](/v3/documentation/tvm/instructions#B603)

### Как хранить и загружать словарь в локальном хранилище

Логика загрузки словаря

```func
slice local_storage = get_data().begin_parse();
cell dictionary_cell = new_dict();
if (~ slice_empty?(local_storage)) {
    dictionary_cell = local_storage~load_dict();
}
```

В то время как логика хранения словаря похожа на следующий пример:

```func
set_data(begin_cell().store_dict(dictionary_cell).end_cell());
```

> 💡 Полезные ссылки
>
> ["get_data()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#get_data)
>
> ["new_dict()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#new_dict)
>
> ["slice_empty?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice_empty)
>
> ["load_dict()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#load_dict)
>
> ["~" в документации](/v3/documentation/smart-contracts/func/docs/statements#unary-operators)

### Как отправить простое сообщение

Обычно мы отправляем tons с комментарием в виде простого сообщения. Чтобы указать, что тело сообщения является `comment`, мы должны установить `32 bits` перед текстом сообщения в 0.

```func
cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(100) ;; amount of nanoTons to send
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
    .store_slice("Hello from FunC!") ;; comment
.end_cell();
send_raw_message(msg, 3); ;; mode 3 - pay fees separately, ignore errors
```

> 💡 Полезные ссылки
>
> ["Макет сообщения" в документации](/v3/documentation/smart-contracts/message-management/sending-messages)

### Как отправить сообщение с помощью входящего аккаунта

Пример контракта ниже пригодится нам, если нам нужно выполнить какие-либо действия между пользователем и основным контрактом, то есть нам нужен прокси-контракт.

```func
() recv_internal (slice in_msg_body) {
    {-
        This is a simple example of a proxy-contract.
        It will expect in_msg_body to contain message mode, body and destination address to be sent to.
    -}

    int mode = in_msg_body~load_uint(8); ;; first byte will contain msg mode
    slice addr = in_msg_body~load_msg_addr(); ;; then we parse the destination address
    slice body = in_msg_body; ;; everything that is left in in_msg_body will be our new message's body

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(100) ;; just for example
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
        .store_slice(body)
    .end_cell();
    send_raw_message(msg, mode);
}
```

> 💡 Полезные ссылки
>
> ["Макет сообщения" в документации](/v3/documentation/smart-contracts/message-management/sending-messages)
>
> ["load_msg_addr()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#load_msg_addr)

### Как отправить сообщение со всем балансом

Если нам нужно отправить весь баланс смарт-контракта, то в этом случае нам нужно использовать отправить `mode 128`. Примером такого случая может служить прокси-контракт, который принимает платежи и пересылает их основному контракту.

```func
cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(0) ;; we don't care about this value right now
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
    .store_slice("Hello from FunC!") ;; comment
.end_cell();
send_raw_message(msg, 128); ;; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract
```

> 💡 Полезные ссылки
>
> ["Макет сообщения" в документации](/v3/documentation/smart-contracts/message-management/sending-messages)
>
> ["Режимы сообщения" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#send_raw_message)

### Как отправить сообщение с длинным текстовым комментарием

Как мы знаем, в одну `cell` помещается только 127 символов (< 1023 бит). Если нам нужно больше - нужно организовать ячейки змейкой.

```func
{-
    If we want to send a message with really long comment, we should split the comment to several slices.
    Each slice should have <1023 bits of data (127 chars).
    Each slice should have a reference to the next one, forming a snake-like structure.
-}

cell body = begin_cell()
    .store_uint(0, 32) ;; zero opcode - simple message with comment
    .store_slice("long long long message...")
    .store_ref(begin_cell()
        .store_slice(" you can store string of almost any length here.")
        .store_ref(begin_cell()
            .store_slice(" just don't forget about the 127 chars limit for each slice")
        .end_cell())
    .end_cell())
.end_cell();

cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    ;; We use literal `a` to get valid address inside slice from string containing address 
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(100) ;; amount of nanoTons to send
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; default message headers (see sending messages page)
    .store_uint(1, 1) ;; we want to store body as a ref
    .store_ref(body)
.end_cell();
send_raw_message(msg, 3); ;; mode 3 - pay fees separately, ignore errors
```

> 💡 Полезные ссылки
>
> ["Внутренние сообщения" в документации](/v3/documentation/smart-contracts/message-management/internal-messages)

### Как получить только биты данных из среза (без ссылок)

Если нас не интересуют `refs` внутри `slice`, то мы можем получить отдельные данные и работать с ними.

```func
slice s = begin_cell()
    .store_slice("Some data bits...")
    .store_ref(begin_cell().end_cell()) ;; some references
    .store_ref(begin_cell().end_cell()) ;; some references
.end_cell().begin_parse();

slice s_only_data = s.preload_bits(s.slice_bits());
```

> 💡 Полезные ссылки
>
> ["Примитивы срезов" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice-primitives)
>
> ["preload_bits()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#preload_bits)
>
> ["slice_bits()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice_bits)

### Как определить собственный метод изменения

Методы изменения позволяют изменять данные в пределах одной переменной. Это можно сравнить со ссылками в других языках программирования.

```func
(slice, (int)) load_digit (slice s) {
    int x = s~load_uint(8); ;; load 8 bits (one char) from slice
    x -= 48; ;; char '0' has code of 48, so we substract it to get the digit as a number
    return (s, (x)); ;; return our modified slice and loaded digit
}

() main () {
    slice s = "258";
    int c1 = s~load_digit();
    int c2 = s~load_digit();
    int c3 = s~load_digit();
    ;; here s is equal to "", and c1 = 2, c2 = 5, c3 = 8
}
```

> 💡 Полезные ссылки
>
> ["Методы изменения" в документации](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods)

### Как возвести число в степень n

```func
;; Unoptimized variant
int pow (int a, int n) {
    int i = 0;
    int value = a;
    while (i < n - 1) {
        a *= value;
        i += 1;
    }
    return a;
}

;; Optimized variant
(int) binpow (int n, int e) {
    if (e == 0) {
        return 1;
    }
    if (e == 1) {
        return n;
    }
    int p = binpow(n, e / 2);
    p *= p;
    if ((e % 2) == 1) {
        p *= n;
    }
    return p;
}

() main () {
    int num = binpow(2, 3);
    ~dump(num); ;; 8
}
```

### Как преобразовать строку в целое число

```func
slice string_number = "26052021";
int number = 0;

while (~ string_number.slice_empty?()) {
    int char = string_number~load_uint(8);
    number = (number * 10) + (char - 48); ;; we use ASCII table
}

~dump(number);
```

### Как преобразовать целое число в строку

```func
int n = 261119911;
builder string = begin_cell();
tuple chars = null();
do {
    int r = n~divmod(10);
    chars = cons(r + 48, chars);
} until (n == 0);
do {
    int char = chars~list_next();
    string~store_uint(char, 8);
} until (null?(chars));

slice result = string.end_cell().begin_parse();
~dump(result);
```

### Как перебирать словари

Словари очень полезны при работе с большим количеством данных. Мы можем получить минимальные и максимальные значения ключей, используя встроенные методы `dict_get_min?` и `dict_get_max?` соответственно. Кроме того, мы можем использовать `dict_get_next?` для перебирания словаря.

```func
cell d = new_dict();
d~udict_set(256, 1, "value 1");
d~udict_set(256, 5, "value 2");
d~udict_set(256, 12, "value 3");

;; iterate keys from small to big
(int key, slice val, int flag) = d.udict_get_min?(256);
while (flag) {
    ;; do something with pair key->val
    
    (key, val, flag) = d.udict_get_next?(256, key);
}
```

> 💡 Полезные ссылки
>
> ["Примитивы словарей" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dictionaries-primitives)
>
> ["dict_get_max?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dict_get_max)
>
> ["dict_get_min?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dict_get_min)
>
> ["dict_get_next?()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dict_get_next)
>
> ["dict_set()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#dict_set)

### Как удалить значение из словарей

```func
cell names = new_dict();
names~udict_set(256, 27, "Alice");
names~udict_set(256, 25, "Bob");

names~udict_delete?(256, 27);

(slice val, int key) = names.udict_get?(256, 27);
~dump(val); ;; null() -> means that key was not found in a dictionary
```

### Как рекурсивно перебрать дерево ячеек

Как мы знаем, одна `cell` может хранить до `1023 bits` данных и до `4 refs`. Чтобы обойти это ограничение, мы можем использовать дерево ячеек, но для этого нам нужно иметь возможность перебирать его для правильной обработки данных.

```func
forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() main () {
    ;; just some cell for example
    cell c = begin_cell()
        .store_uint(1, 16)
        .store_ref(begin_cell()
            .store_uint(2, 16)
        .end_cell())
        .store_ref(begin_cell()
            .store_uint(3, 16)
            .store_ref(begin_cell()
                .store_uint(4, 16)
            .end_cell())
            .store_ref(begin_cell()
                .store_uint(5, 16)
            .end_cell())
        .end_cell())
    .end_cell();

    ;; creating tuple with no data, which plays the role of stack
    tuple stack = null();
    ;; bring the main cell into the stack to process it in the loop
    stack~push_back(c);
    ;; do it until stack is not null
    while (~ stack.is_null()) {
        ;; get the cell from the stack and convert it to a slice to be able to process it
        slice s = stack~pop_back().begin_parse();

        ;; do something with s data

        ;; if the current slice has any refs, add them to stack
        repeat (s.slice_refs()) {
            stack~push_back(s~load_ref());
        }
    }
}
```

> 💡 Полезные ссылки
>
> ["Списки в стиле Lisp" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#lisp-style-lists)
>
> ["null()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#null)
>
> ["slice_refs()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#slice_refs)

### Как перебирать списки в стиле lisp

Тип данных кортежа может содержать до 255 значений. Если этого недостаточно, то следует использовать список в стиле lisp. Мы можем поместить кортеж внутрь кортежа, обойдя таким образом ограничение.

```func
forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() main () {
    ;; some example list
    tuple l = null();
    l~push_back(1);
    l~push_back(2);
    l~push_back(3);

    ;; iterating through elements
    ;; note that this iteration is in reversed order
    while (~ l.is_null()) {
        var x = l~pop_back();

        ;; do something with x
    }
}
```

> 💡 Полезные ссылки
>
> ["Списки в стиле Lisp" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#lisp-style-lists)
>
> ["null()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib/#null)

### Как отправить сообщение о развертывании (только с stateInit, с stateInit и body)

```func
() deploy_with_stateinit(cell message_header, cell state_init) impure {
  var msg = begin_cell()
    .store_slice(begin_parse(msg_header))
    .store_uint(2 + 1, 2) ;; init:(Maybe (Either StateInit ^StateInit))
    .store_uint(0, 1) ;; body:(Either X ^X)
    .store_ref(state_init)
    .end_cell();

  ;; mode 64 - carry the remaining value in the new message
  send_raw_message(msg, 64); 
}

() deploy_with_stateinit_body(cell message_header, cell state_init, cell body) impure {
  var msg = begin_cell()
    .store_slice(begin_parse(msg_header))
    .store_uint(2 + 1, 2) ;; init:(Maybe (Either StateInit ^StateInit))
    .store_uint(1, 1) ;; body:(Either X ^X)
    .store_ref(state_init)
    .store_ref(body)
    .end_cell();

  ;; mode 64 - carry the remaining value in the new message
  send_raw_message(msg, 64); 
}
```

### Как создать ячейку stateInit

```func
() build_stateinit(cell init_code, cell init_data) {
  var state_init = begin_cell()
    .store_uint(0, 1) ;; split_depth:(Maybe (## 5))
    .store_uint(0, 1) ;; special:(Maybe TickTock)
    .store_uint(1, 1) ;; (Maybe ^Cell)
    .store_uint(1, 1) ;; (Maybe ^Cell)
    .store_uint(0, 1) ;; (HashmapE 256 SimpleLib)
    .store_ref(init_code)
    .store_ref(init_data)
    .end_cell();
}
```

### Как рассчитать адрес контракта (используя stateInit)

```func
() calc_address(cell state_init) {
  var future_address = begin_cell() 
    .store_uint(2, 2) ;; addr_std$10
    .store_uint(0, 1) ;; anycast:(Maybe Anycast)
    .store_uint(0, 8) ;; workchain_id:int8
    .store_uint(cell_hash(state_init), 256) ;; address:bits256
    .end_cell();
}
```

### Как обновить логику смарт-контракта

Ниже представлен простой смарт-контракт `СounterV1`, который имеет функциональность для увеличения счетчика и обновления логики смарт-контракта.

```func
() recv_internal (slice in_msg_body) {
    int op = in_msg_body~load_uint(32);
    
    if (op == op::increase) {
        int increase_by = in_msg_body~load_uint(32);
        ctx_counter += increase_by;
        save_data();
        return ();
    }

    if (op == op::upgrade) {
        cell code = in_msg_body~load_ref();
        set_code(code);
        return ();
    }
}
```

После работы со смарт-контрактом вы понимаете, что вам не хватает функции сокращения счетчика. Вам необходимо скопировать код смарт-контракта `CounterV1` и рядом с функцией `increase` добавить новую функцию `decrease`. Теперь ваш код выглядит так:

```func
() recv_internal (slice in_msg_body) {
    int op = in_msg_body~load_uint(32);
    
    if (op == op::increase) {
        int increase_by = in_msg_body~load_uint(32);
        ctx_counter += increase_by;
        save_data();
        return ();
    }

    if (op == op::decrease) {
        int decrease_by = in_msg_body~load_uint(32);
        ctx_counter -= increase_by;
        save_data();
        return ();
    }

    if (op == op::upgrade) {
        cell code = in_msg_body~load_ref();
        set_code(code);
        return ();
    }
}
```

Как только смарт-контракт `CounterV2` будет готов, вам необходимо скомпилировать его вне цепочки в `cell` и отправить сообщение об обновлении смарт-контракту `CounterV1`.

```javascript
await contractV1.sendUpgrade(provider.sender(), {
    code: await compile('ContractV2'),
    value: toNano('0.05'),
});
```

> 💡 Полезные ссылки
>
> [Возможно ли повторно развернуть код на существующий адрес или его нужно развернуть как новый контракт?](/v3/documentation/faq#is-it-possible-to-re-deploy-code-to-an-existing-address-or-does-it-have-to-be-deployed-as-a-new-contract)
>
> ["set_code()" в документации](/v3/documentation/smart-contracts/func/docs/stdlib#set_code)








================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/builtins.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/builtins.md
================================================
# Встроенные функции

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В этом разделе описываются некоторые конструкции языка, которые менее фундаментальны, чем те, что описаны в предыдущих статьях. Их можно было бы определить в [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib), но это оставило бы меньше места для оптимизатора FunC.

## Выброс исключений

Исключения могут быть выброшены с помощью условных примитивов `throw_if`, `throw_unless` и безусловного `throw`. Первый аргумент — это код ошибки; второй — это условие (`throw` имеет только один аргумент). Эти примитивы имеют параметризованные версии `throw_arg_if`, `throw_arg_unless` и `throw_arg`. Первый аргумент — это параметр исключения любого типа; второй — это код ошибки; третий — это условие (`throw_arg` имеет только два аргумента).

## Булевы значения

- `true` является псевдонимом для `-1`
- `false` является псевдонимом для `0`

## Переменная дампа

Переменная может быть выгружена в журнал отладки с помощью функции `~dump`.

## Строка дампа

Строка может быть выгружена в журнал отладки с помощью функции `~strdump`.

## Операции с целыми числами

- `muldiv` — это операция умножения, а затем деления. Промежуточный результат сохраняется в 513-битном целом числе, поэтому он не будет переполне, если фактический результат поместится в 257-битное целое число.
- `divmod` - это операция, которая принимает два числа в качестве параметров и возвращает частное и остаток от их деления.

## Другие примитивы

- `null?` проверяет, является ли аргумент `null`. По значению `null` типа TVM, `Null` FunC представляет отсутствие значения некоторого атомарного типа; смотрите [значения null](/v3/documentation/smart-contracts/func/docs/types#null-values).
- `touch` и `~touch` перемещают переменную на вершину стека
- `at` получает значение компонента кортежа в указанной позиции



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/comments.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/comments.md
================================================
# Комментарии

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

FunC имеет однострочные комментарии, которые начинаются с `;;` (двойной `;`). Например:

```func
int x = 1; ;; assign 1 to x
```

Он также имеет многострочные комментарии, которые начинаются с `{-` и заканчиваются на `-}`. Обратите внимание, что в отличие от многих других языков, многострочные комментарии FunC могут быть вложенными. Например:

```func
{- This is a multi-line comment
    {- this is a comment in the comment -}
-}
```

Более того, внутри многострочных комментариев могут быть однострочные, а однострочные комментарии `;;` "сильнее" многострочных `{- -}`. Другими словами, в следующем примере:

```func
{-
  Start of the comment

;; this comment ending is itself commented -> -}

const a = 10;
;; this comment begining is itself commented -> {-

  End of the comment
-}
```

`const a = 10;` находится внутри многострочного комментария и закомментирован.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/compiler_directives.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/compiler_directives.md
================================================
# Директивы компилятора

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Это ключевые слова, которые начинаются с `#` и предписывают компилятору выполнить некоторые действия, проверки или изменить параметры.

Эти директивы можно использовать только на самом внешнем уровне (не внутри определения какой-либо функции).

## #include

Директива `#include` позволяет включить другой файл исходного кода FunC, который будет проанализирован вместо include.

Синтаксис: `#include "filename.fc";`. Файлы автоматически проверяются на повторное включение, и попытки включить
файл более одного раза будут игнорироваться по умолчанию с предупреждением, если уровень детализации не ниже 2.

Если во время анализа включенного файла происходит ошибка, дополнительно выводится стек включений с расположением
каждого включенного файла в цепочке.

## #pragma

Директива `#pragma` используется для предоставления компилятору дополнительной информации, выходящей за рамки того, что передает сам язык.

### #pragma version

Pragma Version используется для принудительного применения определенной версии компилятора FunC при компиляции файла.

Версия указывается в формате semver, то есть *a.b.c*, где *a* — основная версия, *b* — дополнительная, а *c* — патч.

Разработчику доступно несколько операторов сравнения:

- *a.b.c* или *=a.b.c* — требует именно *a.b.c* версию компилятора
- *>a.b.c* — требует, чтобы версия компилятора была выше *a.b.c*,
  - *>=a.b.c* — требует, чтобы версия компилятора была выше или равна *a.b.c*
- *\<a.b.c* — требует, чтобы версия компилятора была ниже *a.b.c*,
  - *\<=a.b.c* — требует, чтобы версия компилятора была ниже или равна *a.b.c*
- *^a.b.c* — требует, чтобы основная версия компилятора была равна части `a`, а второстепенная — не ниже части `b`,
  - *^a.b* — требует, чтобы основная версия компилятора была равна части *a*, а второстепенная — не ниже части *b*
  - *^a* — требует, чтобы основная версия компилятора была не ниже части *a*

Для других операторов сравнения (*=*, *>*, *>=*, *\<*, *\<=*) короткий формат предполагает нули в пропущенных частях, то есть:

- *>a.b* совпадает с *>a.b.0* (и поэтому НЕ соответствует версии *a.b.0*)
- *\<=a* совпадает с *\<=a.0.0* (и поэтому НЕ соответствует версии *a.0.1*)
- *^a.b.0* **НЕ** совпадает с *^a.b*

Например, *^a.1.2* совпадает с *a.1.3* но не *a.2.3* или *a.1.0*, однако *^a.1* соответствует им всем.

Эту директиву можно использовать несколько раз; версия компилятора должна удовлетворять всем предоставленным условиям.

### #pragma not-version

Синтаксис этой директивы такой же, как и у директивы version, но она завершается неудачей, если условие выполняется.

Например, ее можно использовать для внесения в черный список определенной версии, известной своими проблемами.

### #pragma allow-post-modification

*funC v0.4.1*

По умолчанию запрещено использовать переменную до ее изменения в том же выражении. Другими словами, выражение `(x, y) = (ds, ds~load_uint(8))` не будет скомпилировано, в то время как `(x, y) = (ds~load_uint(8), ds)` допустимо.

Это правило может быть заменено `#pragma allow-post-modification`, которое позволяет изменять переменную после использования в массовых назначениях и вызовах функций; как обычно, вложенные выражения будут вычисляться слева направо: `(x, y) = (ds, ds~load_bits(8))` приведет к `x`, содержащему начальную `ds`; `f(ds, ds~load_bits(8))` первый аргумент `f` будет содержать начальную `ds`, а второй - 8 бит `ds`.

`#pragma allow-post-modification` работает только для кода после директивы.

### #pragma compute-asm-ltr

*funC v0.4.1*

Объявления Asm могут перезаписывать порядок аргументов, например, в следующем выражении

```func
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref())
```

порядок разбора будет: `load_ref()`, `load_uint(256)`, `load_dict()` и `load_uint(8)` из-за следующего объявления asm (обратите внимание `asm(value index dict key_len)`):

```func
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
```

Это поведение можно изменить на строгий порядок вычислений слева направо с помощью `#pragma compute-asm-ltr`

В результате в

```func
#pragma compute-asm-ltr
...
idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref());
```

порядок разбора будет `load_dict()`, `load_uint(8)`, `load_uint(256)`, `load_ref()` и все перестановки asm будут происходить после вычислений.

`#pragma compute-asm-ltr` работает только для кода после директивы.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/dictionaries.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/dictionaries.md
================================================
# Словари в TON

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Смарт-контракты могут использовать словари — упорядоченные сопоставления ключ-значение. Внутренне они представлены деревьями ячеек.

:::warning
Working with potentially large trees of cells creates a couple of considerations:

1. Каждая операция обновления создает заметное количество ячеек (и каждая построенная ячейка стоит 500 газа, как можно найти на странице [Инструкции TVM](/v3/documentation/tvm/instructions#gas-prices), что означает, что эти операции могут исчерпать газ, если их использовать без должного внимания.
    - В частности, Wallet bot однажды столкнулся с такой проблемой при использовании кошелька highload-v2. Неограниченный цикл в сочетании с дорогостоящими обновлениями словаря на каждой итерации привел к исчерпанию газа и в конечном итоге к повторным транзакциям, таким как [fd78228f352f582a544ab7ad7eb716610668b23b88dae48e4f4dbd4404b5d7f6](https://tonviewer.com/transaction/fd78228f352f582a544ab7ad7eb716610668b23b88dae48e4f4dbd4404b5d7f6), опустошающим его баланс.
2. Двоичное дерево для N пар ключ-значение содержит N-1 разветвлений и, таким образом, в общей сложности не менее 2N-1 ячеек. Хранилище смарт-контрактов ограничено 65536 уникальными ячейками, поэтому максимальное количество записей в словаре составляет 32768 или немного больше, если есть повторяющиеся ячейки.
    :::

## Типы словарей

### "Хэш"карта

Очевидно, что наиболее известным и используемым типом словарей в TON является хэш-карта. Он имеет целый раздел, стоящий кодов операций TVM ([Инструкции TVM](/v3/documentation/tvm/instructions#quick-search) - Манипулирование словарем) и обычно используется в смарт-контрактах.

Эти словари представляют собой сопоставления ключей одинаковой длины (указанная длина указывается в качестве аргумента для всех функций) с фрагментами значений. В отличие от "хэширования" в названии, записи в них упорядочены и обеспечивают дешевое извлечение элемента по ключу, предыдущей или следующей паре ключ-значение. Значения помещаются в ту же ячейку, что и внутренние теги узлов и, возможно, ключевые части, поэтому они не могут использовать все 1023 бита; в такой ситуации обычно используется `~udict_set_ref`.

Пустая хэш-карта представляется TVM как `null`; таким образом, это не ячейка. Чтобы сохранить словарь в ячейке, сначала сохраняется один бит (0 для пустого, 1 в противном случае), а затем добавляется ссылка, если хэш-карта не пуста. Таким образом, `store_maybe_ref` и `store_dict` взаимозаменяемы, и некоторые авторы смарт-контрактов используют `load_dict` для загрузки `Maybe ^Cell` из входящего сообщения или хранилища.

Возможные операции для хэш-карт:

- загрузка из среза, сохранение в конструкторе
- получение/установка/удаление значения по ключу
- замена значения (установка нового значения, если ключ уже был) / добавление одного (если ключ отсутствовал)
- переход к следующей/предыдущей паре ключ-значение в порядке ключей (это можно использовать для [перебора словарей](/v3/documentation/smart-contracts/func/cookbook#how-to-iterate-dictionaries), если ограничение газа не имеет значения)
- извлечение минимального/максимального ключа с его значением
- получение функции (продолжение) по ключу и немедленное ее выполнение

Чтобы контракт не нарушался из-за превышения ограничения газа, при обработке одной транзакции должно происходить только ограниченное количество обновлений словаря. Если баланс контракта используется для поддержания карты в соответствии с условиями разработчика, контракт может отправить себе сообщение для продолжения очистки.

:::info
Существуют инструкции по извлечению подсловаря: подмножества записей в заданном диапазоне ключей. Они не были протестированы, поэтому вы можете проверить их только в форме сборки TVM: `SUBDICTGET` и аналогичной.
:::

#### Примеры хэш-карт

Давайте посмотрим, как выглядят хэш-карты, уделив особое внимание сопоставлению 257-битных целочисленных ключей с пустыми срезами значений (такая карта будет указывать только на наличие или отсутствие элемента).

Способ быстрой проверки — запустить следующий скрипт на Python (возможно, заменив `pytoniq` на другой SDK по мере необходимости):

```python
import pytoniq
k = pytoniq.HashMap(257)
em = pytoniq.begin_cell().to_slice()
k.set(5, em)
k.set(7, em)
k.set(5 - 2**256, em)
k.set(6 - 2**256, em)
print(str(pytoniq.begin_cell().store_maybe_ref(k.serialize()).end_cell()))
```

Структура представляет собой двоичное дерево, даже сбалансированное, если мы пропустим корневую ячейку.

```
1[80] -> {
	2[00] -> {
		265[9FC00000000000000000000000000000000000000000000000000000000000000080] -> {
			4[50],
			4[50]
		},
		266[9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40] -> {
			2[00],
			2[00]
		}
	}
}
```

В документации есть [еще примеры по разбору хэш-карт](/v3/documentation/data-formats/tlb/tl-b-types#hashmap-parsing-example).

### Расширенные карты (с дополнительными данными в каждом узле)

Эти карты используются внутри валидаторов TON для расчета общего баланса всех контрактов в шарде (использование карт с общим балансом поддерева с каждым узлом позволяет им очень быстро проверять обновления). Для работы с ними нет примитивов TVM.

### Словарь префиксов

:::info
Тестирование показывает, что для создания словарей префиксов недостаточно документации. Вам не следует использовать их в продакшен контрактах, если у вас нет полных знаний о том, как работают соответствующие opcode, `PFXDICTSET` и подобные.
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/functions.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/functions.md
================================================
# Функции

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Программа FunC по сути является списком объявлений/определений функций и объявлений глобальных переменных. В этом разделе рассматривается первая тема.

Любое объявление или определение функции начинается с общего шаблона, а затем следует одно из трех:

- одиночный `;`, что означает, что функция объявлена, но еще не определена. Она может быть определена позже в том же файле или в каком-либо другом файле, который передается компилятору FunC перед текущим. Например,
  ```func
  int add(int x, int y);
  ```
  это простое объявление функции с именем `add` типа `(int, int) -> int`.

- определение тела функции ассемблера. Это способ определения функций с помощью примитивов TVM низкого уровня для последующего использования в программе FunC. Например,
  ```func
  int add(int x, int y) asm "ADD";
  ```
  это ассемблерное определение той же функции `add` типа `(int, int) -> int`, которое будет транслироваться в код операции TVM `ADD`.

- обычное определение тела функции блочного оператора. Это обычный способ определения функций. Например,
  ```func
  int add(int x, int y) {
    return x + y;
  }
  ```
  это обычное определение функции `add`.

## Объявление функции

Как уже было сказано, любое объявление или определение функции начинается с общего шаблона. Ниже приведен:

```func
[<forall declarator>] <return_type> <function_name>(<comma_separated_function_args>) <specifiers>
```

где `[ ... ]` соответствует необязательной записи.

### Имя функции

Имя функции может быть любым [идентификатором](/v3/documentation/smart-contracts/func/docs/literals_identifiers#identifiers), а также может начинаться с символов `.` или `~`. Значение этих символов [объясняется](/v3/documentation/smart-contracts/func/docs/statements#methods-calls) в разделе операторов.

Например, `udict_add_builder?`, `dict_set` и `~dict_set` являются допустимыми и разными именами функций. (Они определены в [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib).)

#### Специальные имена функций

FunC (фактически ассемблер Fift) имеет несколько зарезервированных имен функций с предопределенными [идентификаторами](/v3/documentation/smart-contracts/func/docs/functions#method_id).

- `main` и `recv_internal` имеют id = 0
- `recv_external` имеет id = -1
- `run_ticktock` имеет id = -2

Каждая программа должна иметь функцию с id 0, то есть функцию `main` или `recv_internal`.
`run_ticktock` вызывается в транзакциях ticktock специальных смарт-контрактов.

#### Внутренние получения

`recv_internal` вызывается, когда смарт-контракт получает входящее внутреннее сообщение.
При запуске [TVM](/v3/documentation/tvm/tvm-overview#initialization-of-tvm) в стеке есть несколько переменных, задавая аргументы в `recv_internal`, мы даем коду смарт-контракта информацию о некоторых из них. Те аргументы, о которых код не будет знать, просто будут лежать внизу стека и никогда не будут затронуты.

Итак, каждое из следующих объявлений `recv_internal` является правильным, но те, у которых меньше переменных, будут тратить немного меньше газа (каждый неиспользованный аргумент добавляет дополнительные инструкции `DROP`)

```func

() recv_internal(int balance, int msg_value, cell in_msg_cell, slice in_msg) {}
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) {}
() recv_internal(cell in_msg_cell, slice in_msg) {}
() recv_internal(slice in_msg) {}
```

#### Внешние получения

`recv_external` предназначено для входящих внешних сообщений.

### Тип возврата

Тип возврата может быть любым атомарным или составным типом, как описано в разделе [типы](/v3/documentation/smart-contracts/func/docs/types). Например,

```func
int foo();
(int, int) foo'();
[int, int] foo''();
(int -> int) foo'''();
() foo''''();
```

являются допустимыми объявлениями функций.

Вывод типа также допускается. Например,

```func
_ pyth(int m, int n) {
  return (m * m - n * n, 2 * m * n, m * m + n * n);
}
```

является допустимым определением функции `pyth` типа `(int, int) -> (int, int, int)`, которая вычисляет пифагоровы тройки.

### Аргументы функции

Аргументы функции разделяются запятыми. Допустимые объявления аргумента следующие:

- Обычное объявление: тип + имя. Например, `int x` — это объявление аргумента типа `int` и имени `x` в объявлении функции `() foo(int x);`
- Объявление неиспользуемого аргумента: только тип. Например,
  ```func
  int first(int x, int) {
    return x;
  }
  ```
  это допустимое определение функции типа `(int, int) -> int`
- Аргумент с выведенным объявлением типа: только имя.
  Например,
  ```func
  int inc(x) {
    return x + 1;
  }
  ```
  это допустимое определение функции типа `int -> int`. Тип `int` для `x` выводится средством проверки типов.

Обратите внимание, что хотя функция может выглядеть как функция нескольких аргументов, на самом деле это функция одного аргумента [тензорного типа](/v3/documentation/smart-contracts/func/docs/types#tensor-types). Чтобы увидеть разницу, обратитесь к [применению функции](/v3/documentation/smart-contracts/func/docs/statements#function-application). Тем не менее, компоненты тензора аргумента традиционно называются аргументами функции.

### Вызовы функций

#### Немодифицирующие методы

:::info
Немодифицирующая функция поддерживает короткую форму вызова функции с `.`
:::

```func
example(a);
a.example();
```

Если у функции есть хотя бы один аргумент, ее можно вызвать как немодифицирующий метод. Например, `store_uint` имеет тип `(builder, int, int) -> builder` (второй аргумент — это значение для сохранения, а третий — длина в битах). `begin_cell` — это функция, которая создает новый builder. Следующие коды эквивалентны:

```func
builder b = begin_cell();
b = store_uint(b, 239, 8);
```

```func
builder b = begin_cell();
b = b.store_uint(239, 8);
```

Таким образом, первый аргумент функции может быть передан ей, будучи расположенным перед именем функции, если он разделен `.`. Код можно упростить еще больше:

```func
builder b = begin_cell().store_uint(239, 8);
```

Также возможны множественные вызовы методов:

```func
builder b = begin_cell().store_uint(239, 8)
                        .store_int(-1, 16)
                        .store_uint(0xff, 10);
```

#### Модифицирующие функции

:::info
Модифицирующая функция поддерживает краткую форму с операторами `~` и `.`.
:::

Если первый аргумент функции имеет тип `A`, а возвращаемое значение функции имеет вид `(A, B)`, где `B` — некоторый произвольный тип, то функцию можно вызвать как модифицирующий метод.

Модифицирующие вызовы функций могут принимать некоторые аргументы и возвращать некоторые значения, но они изменяют свой первый аргумент, то есть присваивают первый компонент возвращаемого значения переменной из первого аргумента.

```func
a~example();
a = example(a);
```

Например, предположим, что `cs` — это срез ячейки, а `load_uint` имеет тип `(slice, int) -> (slice, int)`: он принимает срез ячейки и количество бит для загрузки и возвращает остаток среза и загруженное значение. Следующие коды эквивалентны:

```func
(cs, int x) = load_uint(cs, 8);
```

```func
(cs, int x) = cs.load_uint(8);
```

```func
int x = cs~load_uint(8);
```

В некоторых случаях мы хотим использовать функцию в качестве модифицирующего метода, который не возвращает никакого значения и изменяет только первый аргумент. Это можно сделать, используя типы единиц измерения, следующим образом: предположим, мы хотим определить функцию `inc` типа `int -> int`, которая увеличивает целое число, и использовать ее в качестве метода модификации. Затем мы должны определить `inc` как функцию типа `int -> (int, ())`:

```func
(int, ()) inc(int x) {
  return (x + 1, ());
}
```

При таком определении его можно использовать как модифицирующий метод. Следующий пример увеличит `x`.

```func
x~inc();
```

#### `.` и `~` в именах функций

Предположим, мы хотим использовать `inc` как немодифицирующий метод. Мы можем написать что-то вроде этого:

```func
(int y, _) = inc(x);
```

Однако можно переопределить определение `inc`, используя модифицирующий метод.

```func
int inc(int x) {
  return x + 1;
}
(int, ()) ~inc(int x) {
  return (x + 1, ());
}
```

А затем назовем это так:

```func
x~inc();
int y = inc(x);
int z = x.inc();
```

Первый вызов изменит x; второй и третий — нет.

Подводя итог, когда функция с именем `foo` вызывается как немодифицирующий или модифицирующий метод (т. е. с синтаксисом `.foo` или `~foo`), компилятор FunC использует определение `.foo` или `~foo` соответственно, если такое определение представлено, а если нет, то использует определение `foo`.

### Спецификаторы

Существует три типа спецификаторов: `impure`, `inline`/`inline_ref` и `method_id`. Один, несколько или ни одного из них можно поместить в объявление функции, но в настоящее время они должны быть представлены в правильном порядке. Например, не допускается указывать `impure` после `inline`.

#### Спецификатор с побочными эффектами

Спецификатор `impure` означает, что функция может иметь некоторые побочные эффекты, которые нельзя игнорировать. Например, мы должны указать спецификатор `impure`, если функция может изменять хранилище контракта, отправлять сообщения или выдавать исключение, когда некоторые данные недействительны, и функция предназначена для проверки этих данных.

Если `impure` не указан и результат вызова функции не используется, то компилятор FunC может и удалить этот вызов функции.

Например, в функции [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib)

```func
int random() impure asm "RANDU256";
```

определено. `impure` используется, потому что `RANDU256` изменяет внутреннее состояние генератора случайных чисел.

#### Встроенный спецификатор

Если функция имеет спецификатор `inline`, ее код фактически подставляется в каждом месте, где вызывается функция. Само собой разумеется, что рекурсивные вызовы встроенных функций невозможны.

Например,

```func
(int) add(int a, int b) inline {
    return a + b;
}
```

поскольку функция `add` отмечена спецификатором `inline`. Компилятор попытается заменить вызовы `add` фактическим кодом `a + b`, избегая накладных расходов на вызов функции.

Вот еще один пример того, как можно использовать встроенный спецификатор, взятый из [ICO-Minter.fc](https://github.com/ton-blockchain/token-contract/blob/f2253cb0f0e1ae0974d7dc0cef3a62cb6e19f806/ft/jetton-minter-ICO.fc#L16):

```func
() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {
  set_data(begin_cell()
            .store_coins(total_supply)
            .store_slice(admin_address)
            .store_ref(content)
            .store_ref(jetton_wallet_code)
           .end_cell()
          );
}
```

#### Спецификатор Inline_ref

Код функции со спецификатором `inline_ref` помещается в отдельную ячейку, и каждый раз, когда вызывается функция, TVM выполняет команду `CALLREF`. Таким образом, это похоже на `inline`, но поскольку ячейку можно повторно использовать в нескольких местах, не дублируя ее, почти всегда более эффективно с точки зрения размера кода использовать спецификатор `inline_ref` вместо `inline`, если только функция не вызывается ровно один раз. Рекурсивные вызовы встроенных функций по-прежнему невозможны, поскольку в ячейках TVM нет циклических ссылок.

#### method_id

Каждая функция в программе TVM имеет внутренний целочисленный идентификатор, по которому она может быть вызвана. Обычные функции нумеруются последующими целыми числами, начиная с 1, но get методы контракта нумеруются хэшами crc16 их имен. спецификатор `method_id(<some_number>)` позволяет присвоить идентификатору функции указанное значение, а `method_id` использует значение по умолчанию `(crc16(<function_name>) & 0xffff) | 0x10000`. Если функция имеет спецификатор `method_id`, то она может быть вызвана в lite-client или ton-explorer как get-метод по своему имени.

Например:

```func
int get_counter() method_id {
  load_data();
  return ctx_counter;
}
```

### Полиморфизм с forall

Перед объявлением или определением любой функции может быть указатель переменных типа `forall`. Он имеет следующий синтаксис:

```func
forall <comma_separated_type_variables_names> ->
```

где имя переменной типа может быть любым [идентификатором](/v3/documentation/smart-contracts/func/docs/literals_identifiers#identifiers). Обычно они именуются заглавными.

Например,

```func
forall X, Y -> [Y, X] pair_swap([X, Y] pair) {
  [X p1, Y p2] = pair;
  return [p2, p1];
}
```

это функция, которая принимает кортеж длиной ровно 2, но со значениями любых типов (одиночная запись стека) в компонентах и ​​меняет их местами.

`pair_swap([2, 3])` вернет `[3, 2]`, а `pair_swap([1, [2, 3, 4]])` вернет `[[2, 3, 4], 1]`.

В этом примере `X` и `Y` являются [переменными типа](/v3/documentation/smart-contracts/func/docs/types#polymorphism-with-type-variables). При вызове функции переменные типа заменяются фактическими типами, и выполняется код функции. Обратите внимание, что хотя функция является полиморфной, фактический код ассемблера для нее одинаков для каждой подстановки типа. Это достигается по сути полиморфизмом примитивов манипуляции стеком. В настоящее время другие формы полиморфизма (например, ad-hoc полиморфизм с классами типов) не поддерживаются.

Также стоит отметить, что ширина типа `X` и `Y` должна быть равна 1; то есть значения `X` или `Y` должны занимать одну запись в стеке. Так что вы на самом деле не можете вызвать функцию `pair_swap` для кортежа типа `[(int, int), int]`, потому что тип `(int, int)` имеет ширину 2, то есть занимает 2 записи в стеке.

## Определение тела функции ассемблера

Как упоминалось выше, функция может быть определена кодом ассемблера. Синтаксис представляет собой ключевое слово `asm`, за которым следует одна или несколько команд ассемблера, представленных в виде строк.
Например, можно определить:

```func
int inc_then_negate(int x) asm "INC" "NEGATE";
```

– функция, которая увеличивает целое число, а затем инвертирует его. Вызовы этой функции будут транслироваться в 2 команды ассемблера `INC` и `NEGATE`. Альтернативный способ определения функции:

```func
int inc_then_negate'(int x) asm "INC NEGATE";
```

`INC NEGATE` будет рассматриваться FunC как одна команда ассемблера, но это нормально, поскольку ассемблер Fift знает, что это 2 отдельные команды.

:::info
Список команд ассемблера можно найти здесь: [инструкции TVM](/v3/documentation/tvm/instructions).
:::

### Перестановка записей стека

В некоторых случаях мы хотим передать аргументы функции ассемблера в другом порядке, чем требует команда ассемблера, или/и получить результат в другом порядке записей стека, чем возвращает команда. Мы могли бы вручную переставить стек, добавив соответствующие примитивы стека, но FunC может сделать это автоматически.

:::info
Обратите внимание, что в случае ручной перестановки аргументы будут вычисляться в переставленном порядке. Чтобы переопределить это поведение, используйте `#pragma compute-asm-ltr`: [compute-asm-ltr](/v3/documentation/smart-contracts/func/docs/compiler_directives#pragma-compute-asm-ltr)
:::

Например, предположим, что команда на ассемблере STUXQ принимает целое число, builder и integer; затем она возвращает значение builder вместе с флагом integer, указывающим на успех или неудачу операции.
Мы можем определить функцию:

```func
(builder, int) store_uint_quite(int x, builder b, int len) asm "STUXQ";
```

Однако предположим, что мы хотим изменить порядок аргументов. Тогда мы можем определить:

```func
(builder, int) store_uint_quite(builder b, int x, int len) asm(x b len) "STUXQ";
```

Таким образом, вы можете указать требуемый порядок аргументов после ключевого слова `asm`.

Кроме того, мы можем изменить возвращаемые значения следующим образом:

```func
(int, builder) store_uint_quite(int x, builder b, int len) asm( -> 1 0) "STUXQ";
```

Числа соответствуют индексам возвращаемых значений (0 — самая глубокая запись стека среди возвращаемых значений).

Также возможно объединение этих методов.

```func
(int, builder) store_uint_quite(builder b, int x, int len) asm(x b len -> 1 0) "STUXQ";
```

### Многострочные asm

Многострочные команды ассемблера или даже фрагменты Fift-кода можно определить с помощью многострочных строк, которые начинаются и заканчиваются `"""`.

```func
slice hello_world() asm """
  "Hello"
  " "
  "World"
  $+ $+ $>s
  PUSHSLICE
""";
```



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/global_variables.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/global_variables.md
================================================
# Глобальные переменные

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Программа FunC, по сути, представляет собой список объявлений функций/определений и глобальных переменных. В этом разделе рассматривается вторая тема.

Глобальная переменная может быть объявлена ​​с помощью ключевого слова `global`, за которым следует тип переменной и имя переменной. Например,

```func
global ((int, int) -> int) op;

int check_assoc(int a, int b, int c) {
  return op(op(a, b), c) == op(a, op(b, c));
}

int main() {
  op = _+_;
  return check_assoc(2, 3, 9);
}
```

это простая программа, которая записывает в глобальную функциональную переменную `op` оператор сложения `_+_` и проверяет ассоциативность сложения трех выборочных целых чисел; 2, 3 и 9.

Внутренне глобальные переменные хранятся в регистре управления c7 TVM.

Тип глобальной переменной можно не указывать. Если это так, то это будет определено на основе использования переменной. Например, мы можем переписать программу следующим образом:

```func
global op;

int check_assoc(int a, int b, int c) {
  return op(op(a, b), c) == op(a, op(b, c));
}

int main() {
  op = _+_;
  return check_assoc(2, 3, 9);
}
```

Можно объявить несколько переменных после одного и того же ключевого слова `global`. Следующие коды эквивалентны:

```func
global int A;
global cell B;
global C;
```

```func
global int A, cell B, C;
```

Запрещено объявлять локальную переменную с тем же именем, что и у уже объявленной глобальной переменной. Например, этот код не будет скомпилирован:

```func
global cell C;

int main() {
  int C = 3;
  return C;
}
```

Обратите внимание, что следующий код правильный:

```func
global int C;

int main() {
  int C = 3;
  return C;
}
```

но здесь `int C = 3;` эквивалентно `C = 3;`, т. е. это присвоение глобальной переменной `C`, а не объявление локальной переменной `C` (вы можете найти объяснение этого эффекта в [выражениях](/v3/documentation/smart-contracts/func/docs/statements#variable-declaration)).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/literals_identifiers.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/literals_identifiers.md
================================================
# Литералы и идентификаторы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Числовые литералы

FunC допускает десятичные и шестнадцатеричные целочисленные литералы (разрешены начальные нули).

Например, `0`, `123`, `-17`, `00987`, `0xef`, `0xEF`, `0x0`, `-0xfFAb`, `0x0001`, `-0`, `-0x0` являются допустимыми числовыми литералами.

## Строковые литералы

Строки в FunC заключаются в двойные кавычки `"` как `"эта строка"`. Специальные символы, такие как `\n`, и многострочные строки не поддерживаются.
По желанию, строковые литералы могут указывать тип после себя, например, `"string "u`.

Поддерживаются следующие типы строк:

- без типа — используется для определений функций asm и для определения константы среза по строке ASCII
- `s` — определяет необработанную константу среза по ее содержимому (в шестнадцатеричной кодировке и, при необходимости, дополненную битами)
- `a` — создает константу среза, содержащую структуру `MsgAddressInt` из указанного адреса
- `u` — создает константу int, которая соответствует шестнадцатеричным значениям предоставленной строки ASCII
- `h` — создает константу int, которая является первыми 32 битами хэша SHA256 строки
- `H` — создает константу int, которая является все 256 бит хэша SHA256 строки
- `c` — создает константу int, которая является значением crc32 строки

Например, следующие значения приводят к соответствующим константам:

- `"string"` становится `x{737472696e67}` срез const
- `"abcdef"s` становится `x{abcdef}` срез const
- `"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF"a` становится `x{9FE66666666666666666666666666666666666666666666666666666666666667_}` срез const (`addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33`)
- `"NstK"u` становится `0x4e73744b` int const
- `"transfer(slice, int)"h` становится `0x7a62e8a8` int const
- `"transfer(slice, int)"H` становится `0x7a62e8a8ebac41bd6de16c65e7be363bc2d2cbc6a0873778dead4795c13db979` int const
- `"transfer(slice, int)"c` становится `2235694568` int const

## Идентификаторы

FunC допускает действительно широкий класс идентификаторов (имена функций и переменных). А именно, любая (однострочная) строка, которая не содержит специальные символы `;`, `,`, `(`, `)`, ` ` (пробел или табуляция), `~` и `.`, не начинается как комментарий или строковый литерал (с `"`), не является числовым литералом, не является подчеркиванием `_` и не является ключевым словом, является допустимым идентификатором (за исключением того, что если она начинается с `` ` ``, она должна заканчиваться тем же `` ` `` и не может содержать никаких других `` ` ``, кроме этих двух).

Кроме того, имена функций в определениях функций могут начинаться с `.` или `~`.

Например, это допустимые идентификаторы:

- `query`, `query'`, `query''`
- `elem0`, `elem1`, `elem2`
- `CHECK`
- `_internal_value`
- `message_found?`
- `get_pubkeys&signatures`
- `dict::udict_set_builder`
- `_+_` (стандартный оператор сложения типа `(int, int) -> int` в префиксной нотации, хотя он уже определен)
- `fatal!`

`'` в конце имени переменной обычно используется, когда вводится некоторая измененная версия старого значения. Например, почти все модифицирующие встроенные примитивы для манипуляции хэш-картой (кроме тех, что с префиксом `~`) берут хэш-карту и возвращают новую версию хэш-карты вместе с некоторыми другими данными, если это необходимо. Удобно называть эти значения тем же именем, с суффиксом `'`.

Суффикс `?` обычно используется для булевых переменных (TVM не имеет встроенного типа bool; булевы переменные представлены целыми числами: 0 — ложь, а -1 — истина) или для функций, которые возвращают некоторый флаг, обычно указывающий на успешность операции (например, `udict_get?` из [stdlib.fc](/v3/documentation/smart-contracts/func/docs/stdlib)).

Это недопустимые идентификаторы:

- `take(first)Entry`
- \\`"not_a_string
- `msg.sender`
- `send_message,then_terminate`
- `_`

Еще несколько необычных примеров допустимых идентификаторов:

- `123validname`
- `2+2=2*2`
- `-alsovalidname`
- `0xefefefhahaha`
- `{hehehe}`
- `pa{--}in`aaa\`\`.

Это также недопустимые идентификаторы:

- `pa;;in`aaa`` (потому что `;`` запрещено)
- `{-aaa-}`
- `aa(bb`
- `123` (это число)

Кроме того, в FunC есть специальный тип идентификаторов, который заключается в обратные кавычки `` ` ``.
В кавычках допустимы любые символы, кроме `\n` и самих кавычек.

Например, `` `Я тоже переменная` `` является допустимым идентификатором, как и `` `здесь разрешены любые символы ; ~ ()...` ``

## Константы

FunC позволяет определять константы времени компиляции, которые подставляются и предварительно вычисляются во время компиляции.

Константы определяются как `const Optional-Type Id = value-or-expression;`

`optional-type` можно использовать для принудительного указания определенного типа константы и для лучшей читаемости.

На данный момент поддерживаются типы `int` и `slice`.

`value-or-expression` может быть литералом или предварительно вычисляемым выражением литералов и констант.

Например, константы можно определить следующим образом:

- `const int101 = 101;` определяет константу `int101`, которая эквивалентна числовому литералу `101`
- `const str1 = "const1", str2 = "aabbcc"s;` определяет две константы, которые равны соответствующим им строкам
- `const int int240 = ((int1 + int2) * 10) << 3;` определяет константу `int240`, которая равна результату вычисления
- `const slice str2r = str2;` определяет константу `str2r`, которая равна значению константы `str2`

Поскольку числовые константы подставляются во время компиляции, все оптимизации и предварительные вычисления, выполняемые во время компиляции, успешно выполняются (в отличие от старого метода определения констант с помощью встроенного asm `PUSHINT`s).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/statements.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/statements.md
================================================
# Операторы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В этом разделе кратко рассматриваются операторы FunC, составляющие код обычных тел функций.

## Операторы выражений

Наиболее распространенным типом оператора является оператор выражения. Это выражение, за которым следует `;`. Описание выражения было бы довольно сложным, поэтому здесь представлен только краткий обзор. Как правило, все вложенные выражения вычисляются слева направо, за исключением [перестановки стека asm](/v3/documentation/smart-contracts/func/docs/functions#rearranging-stack-entries), которая может определять порядок вручную.

### Объявление переменной

Невозможно объявить локальную переменную, не определив ее начальное значение.

Вот несколько примеров объявлений переменных:

```func
int x = 2;
var x = 2;
(int, int) p = (1, 2);
(int, var) p = (1, 2);
(int, int, int) (x, y, z) = (1, 2, 3);
(int x, int y, int z) = (1, 2, 3);
var (x, y, z) = (1, 2, 3);
(int x = 1, int y = 2, int z = 3);
[int, int, int] [x, y, z] = [1, 2, 3];
[int x, int y, int z] = [1, 2, 3];
var [x, y, z] = [1, 2, 3];
```

Переменная может быть "переобъявлена" в том же блоке. Для примера, вот правильный код:

```func
int x = 2;
int y = x + 1;
int x = 3;
```

На самом деле, второе появление `int x` - это не объявление, а просто проверка во время компиляции того, что `x` имеет тип `int`. Таким образом, третья строка, по сути, эквивалентна простому присваиванию `x = 3;`.

Во вложенных областях переменная может быть действительно объявлена заново, как и в языке С. Для примера, вот правильный код:

```func
int x = 0;
int i = 0;
while (i < 10) {
  (int, int) x = (i, i + 1);
  ;; here x is a variable of type (int, int)
  i += 1;
}
;; here x is a (different) variable of type int
```

Но как упоминалось в [разделе глобальных переменных](/v3/documentation/smart-contracts/func/docs/global_variables), глобальная переменная не может быть переопределена.

Обратите внимание, что объявление переменной — **это** оператор выражения, поэтому на самом деле конструкции вроде `int x = 2` являются полноценными выражениями. Для примера, вот правильный код:

```func
int y = (int x = 3) + 1;
```

Это объявление двух переменных `x` и `y`, равных `3` и `4` соответственно.

#### Подчеркивание

Подчеркивание `_` используется, когда значение не требуется. Например, предположим, что функция `foo` имеет тип `int -> (int, int, int)`. Мы можем получить первое возвращаемое значение и проигнорировать второе и третье, как показано ниже:

```func
(int fst, _, _) = foo(42);
```

### Применение функции

Вызов функции выглядит так в общепринятом языке. Аргументы вызова функции перечислены после имени функции и разделены запятыми.

```func
;; suppose foo has type (int, int, int) -> int
int x = foo(1, 2, 3);
```

Но обратите внимание, что `foo` на самом деле является функцией одного аргумента типа `(int, int, int)`. Чтобы увидеть разницу, предположим, что `bar` — это функция типа `int -> (int, int, int)`. В отличие от обычных языков, вы можете составлять функции следующим образом:

```func
int x = foo(bar(42));
```

вместо похожей, но более длинной формы:

```func
(int a, int b, int c) = bar(42);
int x = foo(a, b, c);
```

Также возможны вызовы в стиле Haskell, но не всегда (будут исправлены позже):

```func
;; suppose foo has type int -> int -> int -> int
;; i.e. it's carried
(int a, int b, int c) = (1, 2, 3);
int x = foo a b c; ;; ok
;; int y = foo 1 2 3; wouldn't compile
int y = foo (1) (2) (3); ;; ok
```

### Лямбда-выражения

Лямбда-выражения пока не поддерживаются.

### Вызовы методов

#### Немодифицирующие методы

Если у функции есть хотя бы один аргумент, ее можно вызвать как немодифицирующий метод. Например, `store_uint` имеет тип `(builder, int, int) -> builder` (второй аргумент — это значение для сохранения, а третий — длина бита). `begin_cell` — это функция, которая создает новый builder. Следующие коды эквивалентны:

```func
builder b = begin_cell();
b = store_uint(b, 239, 8);
```

```func
builder b = begin_cell();
b = b.store_uint(239, 8);
```

Таким образом, первый аргумент функции может быть передан ей, будучи расположенным перед именем функции, если они разделены `.`. Код можно еще больше упростить:

```func
builder b = begin_cell().store_uint(239, 8);
```

Также возможны множественные вызовы методов:

```func
builder b = begin_cell().store_uint(239, 8)
                        .store_int(-1, 16)
                        .store_uint(0xff, 10);
```

#### Модифицирующие методы

Если первый аргумент функции имеет тип `A`, а возвращаемое значение функции имеет форму `(A, B)`, где `B` — некоторый произвольный тип, то функцию можно вызвать как модифицирующий метод. Модифицирующие вызовы методов могут принимать некоторые аргументы и возвращать некоторые значения, но они изменяют свой первый аргумент, то есть присваивают первый компонент возвращаемого значения переменной из первого аргумента. Например, предположим, что `cs` — это срез ячейки, а `load_uint` имеет тип `(slice, int) -> (slice, int)`: он принимает срез ячейки и количество бит для загрузки и возвращает остаток среза и загруженное значение. Следующие коды эквивалентны:

```func
(cs, int x) = load_uint(cs, 8);
```

```func
(cs, int x) = cs.load_uint(8);
```

```func
int x = cs~load_uint(8);
```

В некоторых случаях мы хотим использовать функцию как модифицирующий метод, который не возвращает никакого значения, а только изменяет первый аргумент. Это можно сделать с помощью типов единиц следующим образом: Предположим, мы хотим определить функцию `inc типа int -> int`, которая увеличивает целое число, и использовать ее как модифицирующий метод. Тогда мы должны определить `inc` как функцию типа `int -> (int, ())`:

```func
(int, ()) inc(int x) {
  return (x + 1, ());
}
```

При таком определении ее можно использовать как модифицирующий метод. Следующее будет увеличивать `x`.

```func
x~inc();
```

#### `.` и `~` в именах функций

Предположим, мы хотим использовать `inc` также как немодифицирующий метод. Мы можем написать что-то вроде этого:

```func
(int y, _) = inc(x);
```

Но можно переопределить определение `inc` как модифицирующего метода.

```func
int inc(int x) {
  return x + 1;
}
(int, ()) ~inc(int x) {
  return (x + 1, ());
}
```

И затем вызвать его так:

```func
x~inc();
int y = inc(x);
int z = x.inc();
```

Первый вызов изменит x; второй и третий - нет.

Подводя итог, можно сказать, что когда функция с именем `foo` вызывается как немодифицирующий или модифицирующий метод (т. е. с синтаксисом `.foo` или `~foo`), компилятор FunC использует определение `.foo` или `~foo` соответственно, если такое определение представлено, а если нет, то он использует определение `foo`.

### Операторы

Обратите внимание, что в настоящее время все унарные и бинарные операторы являются целочисленными операторами. Логические операторы представлены как побитовые целочисленные операторы [(ср. отсутствие булевого типа)](/v3/documentation/smart-contracts/func/docs/types#absence-of-boolean-type)).

#### Унарные операторы

Существует два унарных оператора:

- `~` - побитовое Не (приоритет 75)
- `-` - целочисленное отрицание (приоритет 20)

Их следует отделять от аргумента:

- `- x` - допустимо.
- `-x` не подходит (это одиночный идентификатор)

#### Бинарные операторы

С приоритетом 30 (левоассоциативный):

- `*` - целочисленное умножение
- `/` - целочисленное деление (floor)
- `~/` - целочисленное деление (round)
- `^/` - целочисленное деление (ceil)
- `%` - это уменьшение целого числа по модулю (floor)
- `~%` - уменьшение целого числа по модулю (round)
- `^%` - это уменьшение целого числа по модулю (ceil)
- `/%` возвращает частное и остаток
- `&` - побитовое И

С приоритетом 20 (левоассоциативный):

- `+` - целочисленное сложение
- `-` - целочисленное вычитание
- `|` - побитовое ИЛИ
- `^` - побитовое исключение ИЛИ

С приоритетом 17 (левоассоциативный):

- `<<` - побитовый сдвиг влево
- `>>` - побитовый сдвиг вправо
- `~>>` - побитовый сдвиг вправо (round)
- `^>>` - побитовый сдвиг вправо (ceil)

С приоритетом 15 (левоассоциативный):

- `==` проверка равенства целых чисел
- `!=` проверка неравенства целых чисел
- `<` сравнение целых чисел
- `<=` сравнение целых чисел
- `>` сравнение целых чисел
- `>=` сравнение целых чисел
- `<=>` сравнение целых чисел (возвращает -1, 0 или 1)

Их также следует отделить от аргумента:

- `x + y` допустимо
- `x+y` недопустимо (это один идентификатор)

#### Условный оператор

Имеет обычный синтаксис.

```func
<condition> ? <consequence> : <alternative>
```

Например:

```func
x > 0 ? x * fac(x - 1) : 1;
```

Имеет приоритет 13.

#### Присваивания

Приоритет 10.

Простое присваивание `=` и аналоги бинарных операций: `+=`, `-=`, `*=`, `/=`, `~/=`, `^/=`, `%=`, `~%=`, `^%=`, `<<=`, `>>=`, `~>>=`, `^>>=`, `&=`, `|=`, `^=`.

## Циклы

FunC поддерживает циклы `repeat`, `while` и `do { ... } until`. Цикл `for` не поддерживается.

### Цикл повтора

Синтаксис представляет собой ключевое слово `repeat`, за которым следует выражение типа `int`. Повторяет код указанное количество раз. Примеры:

```func
int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024
```

```func
int x = 1, y = 10;
repeat(y + 6) {
  x *= 2;
}
;; x = 65536
```

```func
int x = 1;
repeat(-1) {
  x *= 2;
}
;; x = 1
```

Если количество раз меньше, `-2^31` или больше, `2^31 - 1`, выдается исключение проверки диапазона.

### Цикл с условием

Имеет обычный синтаксис. Пример:

```func
int x = 2;
while (x < 100) {
  x = x * x;
}
;; x = 256
```

Обратите внимание, что истинностное значение условия `x < 100` имеет тип `int` (ср. [ср. отсутствие типа boolean](/v3/documentation/smart-contracts/func/docs/types#absence-of-boolean-type)).

### Цикл до

Имеет следующий синтаксис:

```func
int x = 0;
do {
  x += 3;
} until (x % 17 == 0);
;; x = 51
```

## Операторы If

Примеры:

```func
;; usual if
if (flag) {
  do_something();
}
```

```func
;; equivalent to if (~ flag)
ifnot (flag) {
  do_something();
}
```

```func
;; usual if-else
if (flag) {
  do_something();
}
else {
  do_alternative();
}
```

```func
;; Some specific features
if (flag1) {
  do_something1();
} else {
  do_alternative4();
}
```

Фигурные скобки необходимы. Такой код не будет скомпилирован:

```func
if (flag1)
  do_something();
```

## Операторы Try-Catch

*Доступно в func с v0.4.0*.

Выполняет код в блоке `try`. В случае сбоя полностью откатывает изменения, внесенные в блок `try`, и вместо этого выполняет блок `catch`; `catch` получает два аргумента: параметр исключения любого типа (`x`) и код ошибки (`n`, целое число).

В отличие от многих других языков в операторе FunC try-catch изменения, внесенные в блок try, в частности изменение локальных и глобальных переменных, все изменения регистров (т. е. регистра хранения `c4`, регистра действия/сообщения `c5`, регистра контекста `c7` и других) **отменяются**, если в блоке try есть ошибка, и, следовательно, все обновления хранилища контрактов и отправка сообщений будут отменены. Важно отметить, что некоторые параметры состояния TVM, такие как *codepage* и счетчики газа, не будут откатываться. Это означает, в частности, что весь газ, потраченный в блоке try, будет учтен, а эффекты OP, которые изменяют лимит газа (`accept_message` и `set_gas_limit`), будут сохранены.

Обратите внимание, что параметр исключения может быть любого типа (возможно, разного в случае разных исключений), и поэтому funC не может предсказать его во время компиляции. Это означает, что разработчику нужно "помочь" компилятору, приведя параметр исключения к некоторому типу (см. пример 2 ниже):

Примеры:

```func
try {
  do_something();
} catch (x, n) {
  handle_exception();
}
```

```func
forall X -> int cast_to_int(X x) asm "NOP";
...
try {
  throw_arg(-1, 100);
} catch (x, n) {
  x.cast_to_int();
  ;; x = -1, n = 100
  return x + 1;
}
```

```func
int x = 0;
try {
  x += 1;
  throw(100);
} catch (_, _) {
}
;; x = 0 (not 1)
```

## Операторы блока

Операторы блока также разрешены. Они открывают новую вложенную область:

```func
int x = 1;
builder b = begin_cell();
{
  builder x = begin_cell().store_uint(0, 8);
  b = x;
}
x += 1;
```



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/stdlib.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/stdlib.mdx
================================================
---
toc_min_heading_level: 2
toc_max_heading_level: 6
---

# Стандартная библиотека FunC

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::info
В этом разделе обсуждается библиотека [stdlib.fc](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc) со стандартными функциями, используемыми в FunC.
:::

В настоящее время библиотека является просто оберткой для наиболее распространенного ассемблера команд TVM, которые не являются встроенными. Описание каждой команды TVM, используемой в библиотеке, можно найти в разделе [документация TVM](/v3/documentation/tvm/tvm-overview). Некоторые описания были взяты для этого документа.

Некоторые функции в файле закомментированы. Это означает, что они уже стали встроенными в целях оптимизации. Однако сигнатура типа и семантика остаются прежними.

Обратите внимание, что некоторые менее распространенные команды не представлены в stdlib. Они также будут добавлены в будущем.

## Примитивы для манипулирования кортежами

Имена и типы в основном говорят сами за себя. См. [полиморфизм с forall](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall) для получения дополнительной информации о полиморфных функциях.

Обратите внимание, что в настоящее время значения атомарного типа `tuple` не могут быть преобразованы в составные типы кортежей (например, `[int, cell]`) и наоборот.

### Списки в стиле Lisp

Списки могут быть представлены как вложенные кортежи из 2 элементов. Пустой список традиционно представляется как значение TVM `null` (его можно получить, вызвав `null()`). Например, кортеж `(1, (2, (3, null)))` представляет список `[1, 2, 3]`. Элементы списка могут быть разных типов.

#### cons

```func
forall X -> tuple cons(X head, tuple tail) asm "CONS";
```

Добавляет элемент в начало списка в стиле lisp.

#### uncons

```func
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";
```

Извлекает начало и конец списка в стиле lisp.

#### list_next

```func
forall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) "UNCONS";
```

Извлекает начало и конец списка в стиле lisp. Может использоваться как [(не)модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#methods-calls).

```func
() foo(tuple xs) {
    (_, int x) = xs.list_next(); ;; get the first element, `_` means do not use tail list
    int y = xs~list_next(); ;; pop the first element
    int z = xs~list_next(); ;; pop the second element
}
```

#### car

```func
forall X -> X car(tuple list) asm "CAR";
```

Возвращает начало списка в стиле lisp.

#### cdr

```func
tuple cdr(tuple list) asm "CDR";
```

Возвращает конец списка в стиле lisp.

### Другие примитивы кортежа

#### empty_tuple

```func
tuple empty_tuple() asm "NIL";
```

Создает кортеж из 0 элементов.

#### tpush

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
```

Добавляет значение `x` к `Tuple t = (x1, ..., xn)`, но только если полученный `Tuple t' = (x1, ..., xn, x)` не длиннее 255 символов. В противном случае выдается исключение проверки типа.

#### single

```func
forall X -> [X] single(X x) asm "SINGLE";
```

Создает одиночку, т. е. кортеж длиной один.

#### unsingle

```func
forall X -> X unsingle([X] t) asm "UNSINGLE";
```

Распаковывает одиночку.

#### pair

```func
forall X, Y -> [X, Y] pair(X x, Y y) asm "PAIR";
```

Создает пару.

#### unpair

```func
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";
```

Распаковывает пару.

#### triple

```func
forall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm "TRIPLE";
```

Создает тройку.

#### untriple

```func
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";
```

Распаковывает тройку.

#### tuple4

```func
forall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";
```

Создает кортеж из 4 элементов.

#### untuple4

```func
forall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm "4 UNTUPLE";
```

Распаковывает кортеж из 4 элементов.

#### first

```func
forall X -> X first(tuple t) asm "FIRST";
```

Возвращает первый элемент кортежа.

#### second

```func
forall X -> X second(tuple t) asm "SECOND";
```

Возвращает второй элемент кортежа.

#### third

```func
forall X -> X third(tuple t) asm "THIRD";
```

Возвращает третий элемент кортежа.

#### fourth

```func
forall X -> X fourth(tuple t) asm "3 INDEX";
```

Возвращает четвертый элемент кортежа.

#### pair_first

```func
forall X, Y -> X pair_first([X, Y] p) asm "FIRST";
```

Возвращает первый элемент пары.

#### pair_second

```func
forall X, Y -> Y pair_second([X, Y] p) asm "SECOND";
```

Возвращает второй элемент пары.

#### triple_first

```func
forall X, Y, Z -> X triple_first([X, Y, Z] p) asm "FIRST";
```

Возвращает первый элемент тройки.

#### triple_second

```func
forall X, Y, Z -> Y triple_second([X, Y, Z] p) asm "SECOND";
```

Возвращает второй элемент тройки.

#### triple_third

```func
forall X, Y, Z -> Z triple_third([X, Y, Z] p) asm "THIRD";
```

Возвращает третий элемент тройки.

## Примитивы, специфичные для домена

### Извлечение информации из c7

Некоторые полезные сведения о вызове смарт-контракта можно найти в [специальном регистре c7](/v3/documentation/tvm/tvm-overview#control-registers). Эти примитивы служат для удобного извлечения данных.

#### now

```func
int now() asm "NOW";
```

Возвращает текущее время Unix как целое число

#### my_address

```func
slice my_address() asm "MYADDR";
```

Возвращает внутренний адрес текущего смарт-контракта как срез с `MsgAddressInt`. При необходимости его можно проанализировать далее с помощью примитивов, таких как `parse_std_addr`.

#### get_balance

```func
[int, cell] get_balance() asm "BALANCE";
```

Возвращает оставшийся баланс смарт-контракта в виде `tuple`, состоящего из `int` (оставшийся баланс в nanotoncoin) и `cell` (словарь с 32-битными ключами, представляющими баланс "дополнительных валют"). Поскольку это произойдет в фазе вычислений, баланс контракта будет включать входящее сообщение `value`, вычитать `storage_fee` и `import_fee`.

:::warning
Необработанные примитивы, такие как `send_raw_message`, не обновляют это поле.
:::

#### cur_lt

```func
int cur_lt() asm "LTIME";
```

Возвращает логическое время текущей транзакции.

#### block_lt

```func
int block_lt() asm "BLOCKLT";
```

Возвращает начальное логическое время текущего
блока.

#### config_param

```func
cell config_param(int x) asm "CONFIGOPTPARAM";
```

Возвращает значение глобального параметра конфигурации с целочисленным индексом `i` как `cell` или `null` значение.

### Хэши

#### cell_hash

```func
int cell_hash(cell c) asm "HASHCU";
```

Вычисляет хэш представления `cell c` и возвращает его как 256-битное беззнаковое целое число `x`. Полезно для подписи и проверки подписей произвольных сущностей, представленных деревом ячеек.

#### slice_hash

```func
int slice_hash(slice s) asm "HASHSU";
```

Вычисляет хэш `slice s` и возвращает его как 256-битное целое число без знака `x`. Результат такой же, как если бы была создана обычная ячейка, содержащая только данные и ссылки из `s`, и ее хэш был вычислен `cell_hash`.

#### string_hash

```func
int string_hash(slice s) asm "SHA256U";
```

Вычисляет sha256 бит данных `slice s`. Если длина бит `s` не делится на восемь, выдается исключение потери значимости ячейки. Значение хэша возвращается как 256-битное целое число без знака `x`.

### Проверка подписи

#### check_signature

```func
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
```

Проверяет `signature` Ed25519 для `hash` (256-битное беззнаковое целое число, обычно вычисляемое как хэш некоторых данных) с помощью `public_key` (также представленного 256-битным беззнаковым целым числом). Подпись должна содержать не менее 512 бит данных; используются только первые 512 бит. Если подпись действительна, результат равен `-1`; в противном случае это `0`. Обратите внимание, что `CHKSIGNU` создает 256-битный срез с хешем и вызывает `CHKSIGNS`. То есть, если `hash` вычисляется как хеш некоторых данных, эти данные хешируются _дважды_, второе хеширование происходит внутри `CHKSIGNS`.

#### check_data_signature

```func
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";
```

Проверяет, является ли `signature` допустимой подписью Ed25519 части данных `slice data`, используя `public_key`, аналогично `check_signature`. Если длина бит `data` не делится на восемь, выдается исключение переполнения ячейки. Проверка подписей Ed25519 является стандартной, с использованием sha256 для сокращения `data` до 256-битного числа, которое фактически подписано.

### Вычисление размера boc

Приведенные ниже примитивы могут быть полезны для расчета платы за хранение предоставленных пользователем данных.

#### compute_data_size?

```func
(int, int, int, int) compute_data_size?(cell c, int max_cells) asm "CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Возвращает `(x, y, z, -1)` или `(null, null, null, 0)`. Рекурсивно вычисляет количество отдельных ячеек `x`, битов данных `y` и ссылок на ячейки `z` в DAG с корнем `cell c`, фактически возвращая общее хранилище, используемое этим DAG, с учетом идентификации равных ячеек. Значения `x`, `y` и `z` вычисляются путем обхода в глубину этого DAG с хэш-таблицей хэшей посещенных ячеек, используемых для предотвращения посещений уже посещенных ячеек. Общее количество посещенных ячеек `x` не может превышать неотрицательного `max_cells`; в противном случае вычисление прерывается до посещения `(max_cells + 1)`-й ячейки и возвращается нулевой флаг, указывающий на ошибку. Если `c` равно `null`, возвращается `x = y = z = 0`.

#### slice_compute_data_size?

```func
(int, int, int, int) slice_compute_data_size?(slice s, int max_cells) asm "SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";
```

Аналогично `compute_data_size?`, но принимает `slice s` вместо `cell`. Возвращаемое значение `x` не учитывает ячейку, содержащую сам срез `s`; однако биты данных и ссылки на ячейки `s` учитываются в `y` и `z`.

#### compute_data_size

```func
(int, int, int) compute_data_size(cell c, int max_cells) impure asm "CDATASIZE";
```

Не тихая версия `compute_data_size?`, которая выдает исключение переполнения ячейки (8) при сбое.

#### slice_compute_data_size

```func
(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm "SDATASIZE";
```

Не тихая версия `slice_compute_data_size?`, которая выдает исключение переполнения ячейки (8) при сбое.

### Сохранение и загрузка постоянного хранилища

#### get_data

```func
cell get_data() asm "c4 PUSH";
```

Возвращает ячейку постоянного хранилища контракта. Позже ее можно проанализировать или изменить с помощью примитивов среза и конструктора.

#### set_data

```func
() set_data(cell c) impure asm "c4 POP";
```

Устанавливает ячейку `c` как постоянные данные контракта. Вы можете обновить постоянное хранилище контракта с помощью этого примитива.

### Примитивы продолжения

#### get_c3

```func
cont get_c3() impure asm "c3 PUSH";
```

Обычно `c3` имеет продолжение, инициализированное всем кодом контракта. Оно используется для вызовов функций. Примитив возвращает текущее значение `c3`.

#### set_c3

```func
() set_c3(cont c) impure asm "c3 POP";
```

Обновляет текущее значение `c3`. Обычно используется для обновления кода смарт-контракта во время выполнения. Обратите внимание, что после выполнения этого примитива текущий код (и стек рекурсивных вызовов функций) не изменится, но любой другой вызов функции будет использовать функцию из нового кода.

#### bless

```func
cont bless(slice s) impure asm "BLESS";
```

Преобразует `slice s` в простое обычное продолжение `c` с `c.code = s`, пустым стеком и списком сохранения.

### Примитивы, связанные с газом

#### accept_message

```func
() accept_message() impure asm "ACCEPT";
```

Устанавливает текущий лимит газа `gl` на максимально допустимое значение `gm` и сбрасывает газовый кредит `gc` на ноль, уменьшая значение `gr` на `gc` в процессе. Другими словами, текущий смарт-контракт соглашается купить немного газа, чтобы завершить текущую транзакцию. Это действие требуется для обработки внешних сообщений, которые не несут никакой ценности (следовательно, нет газа).

Для получения более подробной информации проверьте [accept_message effects](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects)

#### set_gas_limit

```func
() set_gas_limit(int limit) impure asm "SETGASLIMIT";
```

Устанавливает текущий лимит газа `gl` на минимальное значение `limit` и `gm` и сбрасывает газовый кредит `gc` на ноль. В этот момент, если количество потребленного газа (включая текущую инструкцию) превышает результирующее значение `gl`, перед установкой новых лимитов газа выдается (необработанное) исключение отсутствия газа. Обратите внимание, что `set_gas_limit` с аргументом `limit ≥ 2^63 − 1` эквивалентно `accept_message`.

Для получения более подробной информации см. [accept_message effects](/v3/documentation/smart-contracts/transaction-fees/accept-message-effects)

#### commit

```func
() commit() impure asm "COMMIT";
```

Фиксирует текущее состояние регистров `c4` ("постоянные данные") и `c5` ("действия"), так что текущее выполнение считается "успешным" с сохраненными значениями, даже если позже выдается исключение.

#### buy_gas

```func
() buy_gas(int gram) impure asm "BUYGAS";
```

:::caution
Код операции `BUYGAS` в настоящее время не реализован
:::

Вычисляет количество газа, которое можно купить за `gram` nanotoncoin, и устанавливает `gl` соответственно так же, как `set_gas_limit`.

### Примитивы действий

#### raw_reserve

```func
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
```

Создает выходное действие, которое зарезервирует ровно `amount` nanotoncoin (если `mode = 0`), максимум `amount` nanotoncoin (если `mode = 2`) или все, кроме `amount` nanotoncoin (если `mode = 1` или `mode = 3`) из оставшегося баланса на аккаунте. Это примерно эквивалентно созданию исходящего сообщения, переносящего `amount` nanotoncoin (или `b − amount` nanotoncoin, где `b` — оставшийся баланс) самому себе, так что последующие выходные действия не смогут потратить больше денег, чем остаток. Бит +2 в `mode` означает, что внешнее действие не терпит неудачу, если указанная сумма не может быть зарезервирована; вместо этого весь оставшийся баланс резервируется. Бит +8 в `mode` означает `amount <- -amount` перед выполнением любых дальнейших действий. Бит +4 в `mode` означает, что `amount` увеличивается на исходный баланс текущего аккаунта (до фазы вычислений), включая все дополнительные валюты перед выполнением любых других проверок и действий. В настоящее время `amount` должно быть неотрицательным целым числом, а `mode` должно быть в диапазоне `0..15`.

#### raw_reserve_extra

```func
() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm "RAWRESERVEX";
```

Похоже на `raw_reserve`, но также принимает словарь `extra_amount` (представленный `cell` или `null`) с дополнительными валютами. Таким образом, можно зарезервировать валюты, отличные от Toncoin.

#### send_raw_message

```func
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
```

Отправляет необработанное сообщение, содержащееся в `msg`, которое должно содержать правильно сериализованный объект Message X, с единственным исключением, что исходный адрес может иметь фиктивное значение `addr_none` (которое будет автоматически заменено текущим адресом смарт-контракта), а поля `ihr_fee`, `fwd_fee`, `created_lt` и `created_at` могут иметь произвольные значения (которые будут перезаписаны правильными значениями во время фазы действия текущей транзакции). Целочисленный параметр `mode` содержит флаги.

В настоящее время существует 3 режима и 4 флага для сообщений. Вы можете объединить один режим с несколькими (возможно, ни одним) флагами, чтобы получить требуемый `mode`. Комбинация просто означает получение суммы их значений. Таблица с описаниями режимов и флагов приведена ниже.

| Режим  | Описание                                                                                                                                                                                                                       |
| :----- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `0`    | Обычное сообщение                                                                                                                                                                                                              |
| `64`   | Перенести всю оставшуюся стоимость входящего сообщения в дополнение к стоимости, изначально указанной в новом сообщении                                                                                                        |
| `128`  | Перенести весь оставшийся баланс текущего смарт-контракта вместо стоимости, изначально указанной в сообщении                                                                                                                   |

| Флаг  | Описание                                                                                                                                                                                                             |
| :---- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `+1`  | Оплатить комиссию за перевод отдельно от стоимости сообщения                                                                                                                                                         |
| `+2`  | Игнорировать некоторые ошибки, возникающие при обработке этого сообщения на этапе действия (см. примечание ниже)                                                                                                     |
| `+16` | В случае сбоя действия — возврат транзакции. Никакого эффекта, если используется `+2`.                                                                                                                               |
| `+32` | Текущий аккаунт должен быть уничтожен, если его результирующий баланс равен нулю (часто используется с режимом 128)                                                                                                  |

:::info +2 флага

1. Недостаточно Toncoin:
   - Недостаточно стоимости для перевода с сообщением (вся стоимость входящего сообщения была израсходована).
   - Недостаточно средств для обработки сообщения.
   - Недостаточно стоимости, прикрепленной к сообщению, для оплаты комиссий за пересылку.
   - Недостаточно дополнительной валюты для отправки с сообщением.
   - Недостаточно средств для оплаты исходящего внешнего сообщения.
2. Сообщение слишком большое (проверьте [размер сообщения](/v3/documentation/smart-contracts/message-management/sending-messages#message-size) для получения дополнительной информации).
3. Сообщение имеет слишком большую глубину Меркла.

Однако он не игнорирует ошибки в следующих сценариях:

1. Сообщение имеет недопустимый формат.
2. Режим сообщения включает как 64, так и 128 модификаций.
3. Исходящее сообщение имеет недопустимые библиотеки в StateInit.
4. Внешнее сообщение не является обычным или включает флаг +16 или +32 или оба
   :::

:::warning

1. **Флаг +16** - не использовать во внешних сообщениях (например, на кошельках), так как нет отправителя, который мог бы получить отклоненное сообщение.
2. **Флаг +2** - важно во внешних сообщениях (например, на кошельках).
   :::

Вы можете увидеть подробный пример [здесь](/v3/documentation/smart-contracts/message-management/sending-messages#example-with-use-cases).

#### set_code

```func
() set_code(cell new_code) impure asm "SETCODE";
```

Создает выходное действие, которое изменит этот код смарт-контракта на тот, который задан ячейкой `new_code`. Обратите внимание, что это изменение вступит в силу только после успешного завершения текущего выполнения смарт-контракта. (Ср. [set_c3](/v3/documentation/smart-contracts/func/docs/stdlib#set_c3))

### Примитивы генератора случайных чисел

Генератор псевдослучайных чисел использует случайное начальное число, беззнаковое 256-битное целое число и (иногда) другие данные, хранящиеся в [c7](/v3/documentation/tvm/tvm-overview#control-registers). Начальное значение случайного начального числа перед выполнением смарт-контракта в блокчейне TON представляет собой хэш адреса смарт-контракта и глобального случайного начального числа блока. Если внутри блока есть несколько запусков одного и того же смарт-контракта, то все эти запуски будут иметь одинаковое случайное начальное число. Это можно исправить, например, запустив `randomize_lt` перед первым использованием генератора псевдослучайных чисел.

:::caution
Keep in mind that random numbers generated by the functions below can be predicted if you do not use additional tricks.

- [Генерация случайных чисел](/v3/guidelines/smart-contracts/security/random-number-generation)

:::

#### random

```func
int random() impure asm "RANDU256";
```

Генерирует новое псевдослучайное целое число без знака длиной 256 бит `x`. Алгоритм следующий: если `r` — это старое значение случайного начального числа, рассматриваемого как 32-байтовый массив (путем построения представления с обратным порядком байтов без знака длиной 256 бит), то вычисляется его `sha512(r)`; первые 32 байта этого хэша сохраняются как новое значение `r'` случайного начального числа, а оставшиеся 32 байта возвращаются как следующее случайное значение `x`.

#### rand

```func
int rand(int range) impure asm "RAND";
```

Генерирует новое псевдослучайное целое число `z` в диапазоне `0..range−1` (или `range..−1`, если `range < 0`). Точнее, генерируется случайное значение `x` без знака, как в `random`; затем `z := x * range / 2^256` вычисляется.

#### get_seed

```func
int get_seed() impure asm "RANDSEED";
```

Возвращает текущее случайное начальное число как беззнаковое 256-битное целое число.

#### set_seed

```func
int set_seed(int seed) impure asm "SETRAND";
```

Устанавливает случайное начальное число как беззнаковое 256-битное `seed`.

#### randomize

```func
() randomize(int x) impure asm "ADDRAND";
```

Смешивает беззнаковое 256-битное целое число `x` со случайным начальным числом `r`, устанавливая для случайного начального значения значение sha256 для объединения двух 32-байтовых строк: первая с представлением старого начального значения числа `r`, а вторая с представлением значения в порядке возрастания `x`.

#### randomize_lt

```func
() randomize_lt() impure asm "LTIME" "ADDRAND";
```

Эквивалентно `randomize(cur_lt());`.

### Примитивы манипуляции адресами

Примитивы манипуляции адресами, перечисленные ниже, сериализуют и десериализуют значения в соответствии со следующей схемой TL-B.

```func
addr_none$00 = MsgAddressExt;

addr_extern$01 len:(## 8) external_address:(bits len)
             = MsgAddressExt;

anycast_info$_ depth:(#<= 30) { depth >= 1 }
  rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)
  workchain_id:int8 address:bits256 = MsgAddressInt;

addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
  workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
```

Десериализованный `MsgAddress` представлен кортежем `t` следующим образом:

- `addr_none` представлен как `t = (0)`, т. е. кортеж, содержащий ровно одно целое число, равное нулю
- `addr_extern` представлен как `t = (1, s)`, где срез `s` содержит
  поле `external_address`. Другими словами, `t` - это пара (кортеж, состоящий из двух записей), содержащая целое число, равное единице, и срез `s`
- `addr_std` представлен как `t = (2, u, x, s)`, где `u` - это либо `null` (если `anycast` отсутствует), либо срез `s'`, содержащий `rewrite_pfx` (если `anycast` присутствует). Далее, целое число `x` является `workchain_id`, а срез `s` содержит адрес
- `addr_var` представлено как `t = (3, u, x, s)`, где `u`, `x` и `s` имеют то же значение, что и для `addr_std`

#### load_msg_addr

```func
(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
```

Загружает из `slice s` единственный префикс, который является допустимым `MsgAddress`, и возвращает как этот префикс `s'`, так и остаток `s''` от `s` в виде срезов.

#### parse_addr

```func
tuple parse_addr(slice s) asm "PARSEMSGADDR";
```

Раскладывает `slice s`, содержащий допустимый `MsgAddress`, на `tuple t` с отдельными полями этого `MsgAddress`. Если `s` не является допустимым `MsgAddress`, выдается исключение десериализации ячейки.

#### parse_std_addr

```func
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";
```

Анализирует срез `s`, содержащий допустимый `MsgAddressInt` (обычно `msg_addr_std`), применяет перезапись из `anycast` (если присутствует) к префиксу адреса той же длины и возвращает как воркчейн, так и 256-битный адрес в виде целых чисел. Если адрес не 256-битный или если `s` не является допустимой сериализацией `MsgAddressInt`, выдает исключение `deserialization` ячейки.

#### parse_var_addr

```func
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";
```

Вариант `parse_std_addr`, который возвращает (переписанный) адрес как срез `s`, даже если его длина не точно 256 бит (представлено `msg_addr_var`).

## Примитивы отладки

Примитивы отладки можно использовать для проверки состояния различных переменных во время выполнения тестов или консольных скриптов.

#### ~dump

```func
forall X -> () ~dump(X value) impure asm "s0 DUMP";
```

Выводит значение. Несколько значений можно вывести как кортеж, например `~dump([v1, v2, v3])`.

#### ~strdump

```func
() ~strdump(slice str) impure asm "STRDUMP";
```

Выводит строку. Длина бит параметра среза должна делиться на 8.

#### dump_stack

```func
() dump_stack() impure asm "DUMPSTK";
```

Выводит стек (максимум 255 верхних значений) и показывает общую глубину стека.

## Примитивы среза

Говорят, что примитив _загружает_ некоторые данные, если он возвращает данные и остаток среза (поэтому его также можно использовать как [модифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods)).

Говорят, что примитив загружает некоторые данные, если он возвращает только данные (его можно использовать как [немодифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods)).

Если не указано иное, примитивы загрузки и предзагрузки считывают данные из префикса фрагмента.

#### begin_parse

```func
slice begin_parse(cell c) asm "CTOS";
```

Преобразует `cell` в `slice`. Обратите внимание, что `c` должна быть либо обычной ячейкой, либо экзотической ячейкой (см. [TVM.pdf](https://ton.org/tvm.pdf), 3.1.2), которая автоматически загружается для получения обычной ячейки `c'`, преобразованной впоследствии в `slice`.

#### end_parse

```func
() end_parse(slice s) impure asm "ENDS";
```

Проверяет, является ли `s` пустым. Если нет, выдает исключение.

#### load_ref

```func
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
```

Загружает первую ссылку из среза.

#### preload_ref

```func
cell preload_ref(slice s) asm "PLDREF";
```

Предварительно загружает первую ссылку из среза.

#### load_int

```func
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
```

Загружает знаковое `len`-битное целое число из среза.

#### load_uint

```func
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
```

Загружает беззнаковое `len`-битное целое число из среза.

#### preload_int

```func
;; int preload_int(slice s, int len) asm "PLDIX";
```

Предварительно загружает знаковое `len`-битное целое число из среза.

#### preload_uint

```func
;; int preload_uint(slice s, int len) asm "PLDUX";
```

Предварительно загружает беззнаковое `len`-битное целое число из среза.

#### load_bits

```func
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
```

Загружает первые `0 ≤ len ≤ 1023` бит из среза `s` в отдельный срез `s''`.

#### preload_bits

```func
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";
```

Предварительно загружает первые `0 ≤ len ≤ 1023` бит из slice `s` в отдельный slice `s''`.

#### load_coins

```func
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
```

Загружает сериализованное количество Toncoin (любое беззнаковое целое число до `2^120 - 1`).

#### skip_bits

```func
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
```

Возвращает все, кроме первых `0 ≤ len ≤ 1023` бит `s`.

#### first_bits

```func
slice first_bits(slice s, int len) asm "SDCUTFIRST";
```

Возвращает первые `0 ≤ len ≤ 1023` бит `s`.

#### skip_last_bits

```func
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";
```

Возвращает все, кроме последних `0 ≤ len ≤ 1023` бит `s`.

#### slice_last

```func
slice slice_last(slice s, int len) asm "SDCUTLAST";
```

Возвращает последние `0 ≤ len ≤ 1023` бит `s`.

#### load_dict

```func
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";
```

Загружает словарь `D` из среза `s`. Может применяться к словарям или к значениям произвольных типов `Maybe ^Y` (возвращает `null`, если используется конструктор `nothing`).

#### preload_dict

```func
cell preload_dict(slice s) asm "PLDDICT";
```

Предварительно загружает словарь `D` из среза `s`.

#### skip_dict

```func
slice skip_dict(slice s) asm "SKIPDICT";
```

Загружает словарь как `load_dict`, но возвращает только остаток среза.

### Примитивы размера среза

#### slice_refs

```func
int slice_refs(slice s) asm "SREFS";
```

Возвращает количество ссылок в срезе `s`.

#### slice_bits

```func
int slice_bits(slice s) asm "SBITS";
```

Возвращает количество бит данных в срезе `s`.

#### slice_bits_refs

```func
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
```

Возвращает как количество бит данных, так и количество ссылок в `s`.

#### slice_empty?

```func
int slice_empty?(slice s) asm "SEMPTY";
```

Проверяет, является ли срез `s` пустым (т. е. не содержит бит данных и ссылок на ячейки).

#### slice_data_empty?

```func
int slice_data_empty?(slice s) asm "SDEMPTY";
```

Проверяет, нет ли в срезе `s` битов данных.

#### slice_refs_empty?

```func
int slice_refs_empty?(slice s) asm "SREMPTY";
```

Проверяет, нет ли в срезе `s` ссылок.

#### slice_depth

```func
int slice_depth(slice s) asm "SDEPTH";
```

Возвращает глубину среза `s`. Если в `s` нет ссылок, то возвращается `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `s`.

## Примитивы конструктора

Говорят, что примитив _сохраняет_ значение `x` в конструкторе `b`, если он возвращает измененную версию конструктора `b'` со значением `x`, сохраненным в конце. Его можно использовать как [немодифицирующий метод](/v3/documentation/smart-contracts/func/docs/statements#non-modifying-methods).

Все перечисленные ниже примитивы сначала проверяют, достаточно ли места в `builder`, а затем диапазон сериализуемого значения.

#### begin_cell

```func
builder begin_cell() asm "NEWC";
```

Создает новый пустой `builder`.

#### end_cell

```func
cell end_cell(builder b) asm "ENDC";
```

Преобразует `builder` в обычную `cell`.

#### store_ref

```func
builder store_ref(builder b, cell c) asm(c b) "STREF";
```

Сохраняет ссылку на ячейку `c` в builder `b`.

#### store_uint

```func
builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
```

Сохраняет беззнаковое `len`-битное целое `x` в `b` для `0 ≤ len ≤ 256`.

#### store_int

```func
builder store_int(builder b, int x, int len) asm(x b len) "STIX";
```

Сохраняет знаковое `len`-битное целое `x` в `b` для `0 ≤ len ≤ 257`.

#### store_slice

```func
builder store_slice(builder b, slice s) asm "STSLICER";
```

Сохраняет срез `s` в builder `b`.

#### store_grams

```func
builder store_grams(builder b, int x) asm "STGRAMS";
```

#### store_coins

```func
builder store_coins(builder b, int x) asm "STGRAMS";
```

Сохраняет (сериализует) целое `x` в диапазоне `0..2^120 − 1` в builder `b`. Сериализация `x` состоит из 4-битного беззнакового целого числа с обратным порядком байтов `l`, которое является наименьшим целым числом `l ≥ 0`, таким образом, что `x < 2^8l`, за которым следует `8l`-битное беззнаковое представление `x` с обратным порядком байтов. Если `x` не принадлежит поддерживаемому диапазону, выдается исключение проверки диапазона.

Это наиболее распространенный способ хранения Toncoin.

#### store_dict

```func
builder store_dict(builder b, cell c) asm(c b) "STDICT";
```

Сохраняет словарь `D`, представленный ячейкой `c` или `null`, в builder `b`. Другими словами, сохраняет `1`-бит и ссылку на `c`, если `c` не является `null`, и `0`-бит в противном случае.

#### store_maybe_ref

```func
builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";
```

Эквивалентно `store_dict`.

### Примитивы размера конструктора

#### builder_refs

```func
int builder_refs(builder b) asm "BREFS";
```

Возвращает количество ссылок на ячейки, уже сохраненных в Builder `b`.

#### builder_bits

```func
int builder_bits(builder b) asm "BBITS";
```

Возвращает количество битов данных, уже сохраненных в Builder `b`.

#### builder_depth

```func
int builder_depth(builder b) asm "BDEPTH";
```

Возвращает глубину builder `b`. Если в `b` не сохранено ссылок на ячейки, то возвращает `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `b`.

## Примитивы ячеек

#### cell_depth

```func
int cell_depth(cell c) asm "CDEPTH";
```

Возвращает глубину ячейки `c`. Если у `c` нет ссылок, то возвращает `0`; в противном случае возвращаемое значение равно единице плюс максимальная глубина ячеек, на которые ссылается `c`. Если `c` является `null` вместо ячейки, возвращается ноль.

#### cell_null?

```func
int cell_null?(cell c) asm "ISNULL";
```

Проверяет, является ли `c` `null`. Обычно `null`-ячейка представляет собой пустой словарь. FunC также имеет встроенный полиморфный `null?`. (См. [built-ins](/v3/documentation/smart-contracts/func/docs/builtins#other-primitives).)

## Примитивы словарей

:::caution
Приведенные ниже примитивы словарей являются низкоуровневыми и не проверяют, что структура ячейки, к которой они применяются, соответствует сигнатуре операции. Применение операции словаря к "не словарю" или применение операции, соответствующей одной длине/знаку ключа, к словарю с другим типом ключей, например, одновременная запись в один словарь значений ключей с 8-битным подписанным ключом и 7-битным неподписанным ключом, является **Неопределенным поведением**. Часто в таких случаях выдается исключение, но в редких случаях может быть записано/считано неправильное значение. Разработчикам настоятельно рекомендуется избегать такого кода.
:::

Как сказано в [TVM.pdf](https://ton.org/tvm.pdf):

> Словари допускают два различных представления в качестве значений стека TVM:
>
> - Срез `s` с сериализацией значения TL-B типа `HashmapE(n, X)`. Другими словами, `s` состоит либо из одного бита, равного нулю (если словарь пуст), либо из одного бита, равного единице, и ссылки на ячейку, содержащую корень двоичного дерева, т. е. сериализованное значение типа `Hashmap(n, X)`.
> - "Ячейка Maybe" `c^?`, т. е. значение, которое является либо ячейкой (содержащей сериализованное значение типа `Hashmap(n, X)`, как и раньше), либо `null` (соответствующее пустому словарю, см. [нулевые значения](/v3/documentation/smart-contracts/func/docs/types#null-values)). Когда ячейка Maybe `c^?` используется для представления словаря, мы обычно обозначаем ее `D`.
>
> Большинство примитивов словаря, перечисленных ниже, принимают и возвращают словари во второй форме, что более удобно для работы со стеком. Однако сериализованные словари внутри более крупных объектов TL-B используют первое представление.

В FunC словари также представлены типом `cell` с неявным предположением, что это может быть значение `null`. Для словарей с разной длиной ключа или типом значения нет отдельных типов (в конце концов, это FunC, а не FunC++).

### Примечание по таксономии

Примитив словаря может интерпретировать ключи словаря либо как беззнаковые `l`-битные целые числа, либо как знаковые `l`-битные целые числа, либо как `l`-битные срезы. Примитивы, перечисленные ниже, отличаются префиксом перед словом `dict` в их именах. `i` обозначает знаковые целые ключи, `u` обозначает беззнаковые целые ключи, а пустой префикс обозначает ключи среза.

Например, `udict_set` — это функция установки по ключу для словарей с беззнаковыми целочисленными ключами; `idict_set` — это соответствующая функция для словарей с целочисленными ключами со знаком; `dict_set` — это функция для словарей с ключами срезов.

В заголовках используется пустой префикс.

Кроме того, некоторые примитивы имеют свои аналоги с префиксом `~`. Это позволяет использовать их как [модифицирующие методы](/v3/documentation/smart-contracts/func/docs/statements#modifying-methods).

### Значения в словарях

Значения в словаре могут храниться либо как подсрез во внутренней ячейке словаря, либо через ссылку на отдельную ячейку. В первом случае нет гарантии, что значение, достаточно малое для размещения в ячейке, также поместится в словаре, поскольку часть пространства внутренней ячейки может быть уже занята частью соответствующего ключа. Напротив, последний метод хранения менее эффективен с точки зрения использования газа. Сохранение значения с использованием второго метода равносильно вставке среза без битов данных и единственной ссылкой на значение в первом методе.

#### dict_set

```func
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
```

Устанавливает значение, связанное с `key_len`-bit key `index` в словаре `dict`, в `value` (ячейки) и возвращает результирующий словарь.

#### dict_set_ref

```func
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
```

Аналогично `dict_set`, но со значением, заданным как ссылка на `value` ячейки.

#### dict_get?

```func
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
```

Ищет ключ `index` в словаре `dict`, который использует ключи бит `key_len`. В случае успеха он извлекает связанное значение как `slice` и возвращает значение флага `-1`, чтобы указать на **успех**. Если поиск не удался, он возвращает `(null, 0)​​`.

#### dict_get_ref?

```func
(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF";
(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF";
```

Аналогично `dict_get?`, но возвращает первую ссылку найденного значения.

#### dict_get_ref

```func
cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
```

Вариант `dict_get_ref?`, который возвращает `null` вместо значения, если ключ `index` отсутствует в словаре `dict`.

#### dict_set_get_ref

```func
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";
```

Устанавливает значение, связанное с `index`, в `value` (если `value` равно `null`, то вместо этого удаляется ключ) и возвращает старое значение (или `null`, если значение отсутствовало).

#### dict_delete?

```func
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
```

Удаляет `key_len`-битный ключ `index` из словаря `dict`. Если ключ присутствует, возвращает измененный словарь `dict'` и флаг успеха `−1`. В противном случае возвращает исходный словарь `dict` и `0`.

#### dict_delete_get?

```func
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
```

Удаляет `key_len`-битный ключ `index` из словаря `dict`. Если ключ присутствует, возвращает измененный словарь `dict'`, исходное значение `x`, связанное с ключом k (представленное срезом), и флаг успеха `−1`. В противном случае возвращает `(dict, null, 0)`.

#### dict_add?

```func
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
```

Аналог `dict_set` с `add` устанавливает значение, связанное с ключом `index` в словаре `dict`, в `value`, но только если оно еще не присутствует в `D`. Возвращает либо измененную версию словаря и флаг `-1`, либо `(dict, 0)`.

#### dict_replace?

```func
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
```

Операция `replace`, похожая на `dict_set`, но которая устанавливает значение ключа `index` в словаре `dict` в `value`, только если ключ уже присутствовал в `dict`. Возвращает либо измененную версию словаря и флаг `-1`, либо `(dict, 0)`.

### Аналоги конструктора

Следующие примитивы принимают новое значение в качестве компоновщика вместо среза, что часто удобнее, если значение необходимо сериализовать из нескольких компонентов, вычисленных в стеке. Чистый эффект примерно эквивалентен преобразованию b в срез и выполнению соответствующего примитива, перечисленного выше.

#### dict_set_builder

```func
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
```

Похоже на `dict_set`, но принимает конструктор.

#### dict_add_builder?

```func
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
```

Похоже на `dict_add?`, но принимает конструктор.

#### dict_replace_builder?

```func
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
```

Аналогично `dict_replace?`, но принимает конструктор.

#### dict_delete_get_min

```func
(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` — это измененная версия `dict`, а `x` — это значение, связанное с `k`. Если словарь пуст, возвращает `(dict, null, null, 0)`.

Обратите внимание, что ключ, возвращаемый `idict_delete_get_min`, может отличаться от ключа, возвращаемого `dict_delete_get_min` и `udict_delete_get_min`.

#### dict_delete_get_max

```func
(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, удаляет его и возвращает `(dict', k, x, -1)`, где `dict'` — это измененная версия `dict`, а `x` — это значение, связанное с `k`. Если словарь пуст, возвращает `(dict, null, null, 0)`.

#### dict_get_min?

```func
(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
```

Вычисляет минимальный ключ `k` в словаре `dict`, связанное значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_max?

```func
(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
```

Вычисляет максимальный ключ `k` в словаре `dict`, связанное значение `x` и возвращает `(k, x, -1)`. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_min_ref?

```func
(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_min?` но возвращает единственную ссылку в значении в качестве ссылки.

#### dict_get_max_ref?

```func
(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_max?`, но возвращает единственную ссылку в значении в качестве ссылки.

#### dict_get_next?

```func
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
```

Вычисляет минимальное значение ключа `k` в словаре `dict`, которое больше, чем `pivot`; возвращает `k`, соответствующее значение и флаг, указывающий на успех. Если словарь пуст, возвращает `(null, null, 0)`.

#### dict_get_nexteq?

```func
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет минимальный ключ `k`, который больше или равен `pivot`.

#### dict_get_prev?

```func
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_next?`, но вычисляет максимальный ключ `k`, меньший, чем `pivot`.

#### dict_get_preveq?

```func
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";
```

Аналогично `dict_get_prev?`, но вычисляет максимальный ключ `k`, меньший или равный `pivot`.

#### new_dict

```func
cell new_dict() asm "NEWDICT";
```

Создает пустой словарь, который на самом деле является значением `null`. Особый случай `null()`.

#### dict_empty?

```func
int dict_empty?(cell c) asm "DICTEMPTY";
```

Проверяет, является ли словарь пустым. Эквивалентно `cell_null?`.

## Примитивы префиксных словарей

TVM также поддерживает словари с ключами нефиксированной длины, которые формируют префиксный код (т. е. нет ключа, который является префиксом другого ключа). Узнайте больше о них в разделе [Инструкции TVM](/v3/documentation/tvm/tvm-overview).

#### pfxdict_get?

```func
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";
```

Возвращает `(s', x, s'', -1)` или `(null, null, s, 0)`.
Ищет уникальный префикс среза `key`, присутствующий в словаре префиксного кода `dict`. Если он найден, префикс `s` возвращается как `s'`, а соответствующее значение (также срез) как `x`. Остаток `s` возвращается как срез `s''`. Если ни один префикс `s` не является ключом в словаре префиксного кода `dict`, он возвращает неизмененный `s` и нулевой флаг.

#### pfxdict_set?

```func
(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";
```

Аналогично `dict_set`, но может завершиться ошибкой, если ключ является префиксом другого ключа, представленного в словаре. При успешном завершении возвращает флаг.

#### pfxdict_delete?

```func
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";
```

Аналогично `dict_delete?`.

## Специальные примитивы

#### null

```func
forall X -> X null() asm "PUSHNULL";
```

По типу TVM `Null`, FunC представляет отсутствие значения некоторого атомарного типа. Поэтому `null` может фактически иметь любой атомарный тип.

#### ~impure_touch

```func
forall X -> (X, ()) ~impure_touch(X x) impure asm "NOP";
```

Помечает переменную как используемую, чтобы код, который ее создал, не был удален, даже если он не является нечистым. (например, [нечистый спецификатор](/v3/documentation/smart-contracts/func/docs/functions#impure-specifier))

## Другие примитивы

#### мин

```func
int min(int x, int y) asm "MIN";
```

Вычисляет минимум из двух целых чисел `x` и `y`.

#### max

```func
int max(int x, int y) asm "MAX";
```

Вычисляет максимум из двух целых чисел `x` и `y`.

#### minmax

```func
(int, int) minmax(int x, int y) asm "MINMAX";
```

Сортирует два целых числа.

#### abs

```func
int abs(int x) asm "ABS";
```

Вычисляет абсолютное значение целого числа `x`.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/types.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/docs/types.md
================================================
# Типы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::info

Документация по FunC была изначально написана [@akifoq](https://github.com/akifoq).

:::

FunC имеет следующие встроенные типы.

## Атомарные типы

- `int` — тип 257-битных знаковых целых чисел. По умолчанию проверки переполнения включены и приводят к исключениям переполнения целых чисел.
- `cell` — тип ячеек TVM. Все постоянные данные в блокчейне TON хранятся в деревьях ячеек. Каждая ячейка имеет до 1023 бит произвольных данных и до четырех ссылок на другие ячейки. Ячейки служат памятью в стековых TVM.
- `slice` — тип срезов ячеек. Ячейку можно преобразовать в срез, а затем биты данных и ссылки на другие ячейки из ячейки можно получить, загрузив их из среза.
- `builder` — тип построителей ячеек. Биты данных и ссылки на другие ячейки могут храниться в конструкторе, а затем конструктор может быть завершен для новой ячейки.
- `tuple` - тип кортежей TVM. Кортеж - это упорядоченная коллекция, содержащая до 255 компонентов с произвольными типами значений, которые могут отличаться друг от друга.
- `cont` - тип продолжений TVM. Продолжения используются для управления ходом выполнения программы TVM. С точки зрения функциональности, это объект довольно низкого уровня, хотя, как это ни парадоксально, довольно общий.

Обратите внимание, что любой из типов выше занимает только одну запись в стеке TVM.

### Отсутствие логического типа

В FunC логические значения представлены как целые числа; `false` представлено как `0`, а `true` представлено как `-1` (257 единиц в двоичной записи). Логические операции выполняются как побитовые операции. При проверке условия каждое ненулевое целое число считается значением `true`.

### Нулевые значения

Значением `null` типа TVM `Null` FunC представляет отсутствие значения некоторого атомарного типа. Некоторые примитивы из стандартной библиотеки могут быть типизированы как возвращающие атомарный тип и фактически возвращающие `null` в некоторых случаях. Другие могут быть типизированы как исключающие значение атомарного типа, но также прекрасно работать со значениями `null`. Такое поведение явно указано в спецификации примитива. По умолчанию значения `null` запрещены и приводят к исключению во время выполнения.

Таким образом, атомарный тип `A` может быть неявно преобразован в тип `A^?`, также известный как `Maybe A` (проверка типов не зависит от такого преобразования).

## Тип отверстия

Функция поддерживает вывод типа. Типы `_` и `var` представляют собой "пробелы" в типах, которые позже могут быть заполнены каким-либо фактическим типом во время проверки типа. Например, `var x = 2;` - это определение переменной `x`, равной `2`. Средство проверки типов может сделать вывод, что `x` имеет тип `int`, потому что `2` имеет тип `int`, а левая и правая части присваивания должны иметь одинаковые типы.

## Составные типы

Типы могут быть объединены в более сложные.

### Функциональный тип

Типы формы `A -> B` представляют функции с указанным доменом и кодовой областью. Например, `int -> cell` — это тип функции, которая принимает один целочисленный аргумент и возвращает ячейку TVM.

Внутренне значения таких типов представлены как продолжения.

### Тензорные типы

Типы вида "(A, B, ...)" по сути представляют собой упорядоченные наборы значений типов "A", "B", "...", которые все вместе занимают более одной записи в стеке TVM.

Например, если функция `foo` имеет тип `int -> (int, int)`, это означает, что функция принимает одно целое число и возвращает пару из них.

Вызов этой функции может выглядеть как `(int a, int b) = foo(42);`. Внутри функция потребляет одну запись стека и оставляет две из них.

Обратите внимание, что с точки зрения низкого уровня значение `(2, (3, 9))` типа `(int, (int, int))` и значение `(2, 3, 9)` типа `(int, int, int)` представлены так же, как три записи стека `2`, `3` и `9`. Для проверки типов FunC это значения **разных** типов. Например, код `(int a, int b, int c) = (2, (3, 9));` не будет скомпилирован.

Частным случаем тензорного типа является тип **unit** `()`. Обычно он используется для обозначения того факта, что функция не возвращает никакого значения или не имеет аргументов. Например, функция `print_int` будет иметь тип `int -> ()`, а функция `random` - тип `() -> int`. У нее есть уникальный пользователь `()`, который занимает 0 записей в стеке.

Тип формы `(A)` рассматривается проверкой типов как тот же тип, что и `A`.

### Типы кортежей

Типы формы `[A, B, ...]` представляют кортежи TVM с определенными длинами и типами компонентов, известными во время компиляции. Например, `[int, cell]` — это тип кортежа TVM, длина которого ровно 2, и где первый компонент — целое число, а второй — ячейка. `[]` — это тип пустых кортежей (у которых есть единственный обитатель - пустой кортеж). Обратите внимание, что в отличие от типа объекта `()`, значение `[]` занимает одну запись стека.

## Полиморфизм с переменной типа

FunC имеет систему типов Миллера-Рабина с поддержкой полиморфных функций. Например, следующая функция:

```func
forall X -> (X, X) duplicate(X value) {
  return (value, value);
}
```

является полиморфной функцией, которая принимает значение (одну запись стека) и возвращает две копии этого значения. `duplicate(6)` создаст значения `6 6`, а `duplicate([])` создаст две копии `[] []` пустого кортежа.

В этом примере `X` — это переменная типа.

Подробнее об этой теме смотрите в разделе [функции](/v3/documentation/smart-contracts/func/docs/functions#polymorphism-with-forall).

## Пользовательские типы

В настоящее время FunC не поддерживает определение типов, за исключением конструкций типов, описанных выше.

## Ширина типа

Как вы могли заметить, каждое значение типа занимает некоторое количество записей стека. Если это одно и то же число для всех значений типа, это число называется **шириной типа**. Полиморфные функции в настоящее время могут быть определены только для типов с фиксированной и заранее известной шириной типа.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/libraries.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/libraries.md
================================================
# SDK и библиотеки для FunC

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Стандартные библиотеки

- [stdlib](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/stdlib.fc) — Стандартная библиотека для FunC
- mathlib](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/mathlib.fc) — Математическая библиотека с фиксированной точкой

## Библиотеки сообщества

- [continuation-team/openlib.func](https://github.com/continuation-team/openlib.func) - Снижает комиссию за транзакции в обычных сценариях.
- [open-contracts/utils](https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/utils) — библиотека утилит
- [open-contracts/strings](https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/strings) — предоставляет операции со строками
- [open-contracts/math](https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/math) — математическая библиотека, расширяющая арифметические операции FunC
- [open-contracts/tuples](https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/tuples) — коллекция функций, связанных с кортежами, для FunC
- [open-contracts/crypto](https://github.com/TonoxDeFi/open-contracts/tree/main/contracts/crypto) — Предоставляет операции на кривой secp256k1
- [toncli/test-libs](https://github.com/disintar/toncli/tree/master/src/toncli/lib/test-libs) - Операции над TLB, генерация и разбор обычных сообщений и типов
- [ston-fi/funcbox](https://github.com/ston-fi/funcbox) - Коллекция фрагментов кода и утилит на FunC.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/overview.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/func/overview.mdx
================================================
import Button from '@site/src/components/button'

# Общие сведения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

**FunC**, язык высокого уровня, используется для программирования смарт-контрактов в TON.

FunC — это специализированный, C-подобный, статически типизированный язык.
Вот простой пример метода отправки денег, написанного на FunC:

```func
() send_money(slice address, int amount) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6) ;; nobounce
        .store_slice(address)
        .store_coins(amount)
        .end_cell();

    send_raw_message(msg, 64);
}
```

Программы FunC компилируются в код ассемблера Fift, который генерирует соответствующий байт-код для [виртуальной машины TON](/v3/documentation/tvm/tvm-overview).

этот байт-код (по сути, [дерево ячеек](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage), как и любые другие данные в блокчейне TON) затем можно использовать для создания смарт-контрактов в блокчейне или запустить на локальном экземпляре TVM.

<Button href="/v3/documentation/smart-contracts/func/cookbook" colorType={'primary'} sizeType={'sm'}>

Книга рецептов FunC

</Button>

<Button href="/v3/documentation/smart-contracts/func/docs/types" colorType={'secondary'} sizeType={'sm'}>

Документация FunC

</Button>

## Компилятор

### Компиляция с помощью JS

Самый удобный и быстрый способ начать разработку и компиляцию смарт-контрактов — использовать фреймворк Blueprint. Подробнее читайте в разделе [Blueprint](/v3/documentation/smart-contracts/getting-started/javascript).

```bash
npm create ton@latest
```

### Компиляция с использованием оригинальных двоичных файлов

Если вы хотите использовать собственный компилятор TON, FunC, локально, вам необходимо настроить двоичные файлы на вашем компьютере. Двоичные файлы компилятора FunC для Windows, macOS (Intel/M1) и Ubuntu можно загрузить с:

- [Страница настройки среды](/v3/documentation/archive/precompiled-binaries)

:::info
В качестве альтернативы вы можете создать двоичные файлы из исходного кода, например, [исходный код компилятора FunC](https://github.com/ton-blockchain/ton/tree/master/crypto/func) (прочитайте [как скомпилировать](/v3/guidelines/smart-contracts/howto/compile/compilation-instructions#func) компилятор FunC из исходников).
:::

## Курс TON: FunC

[Курс по блокчейну TON](https://stepik.org/course/176754/) - это полное руководство по разработке на блокчейне TON.

Модуль 4 полностью охватывает язык FunC и разработку смарт-контрактов.

<Button href="https://stepik.org/course/176754/promo"
        colorType={'primary'} sizeType={'sm'}>

Проверьте курс по блокчейну TON

</Button>

<Button href="https://stepik.org/course/201638/promo"
        colorType={'secondary'} sizeType={'sm'}>

CHN

</Button>

<Button href="https://stepik.org/course/201855/promo"
        colorType={'secondary'} sizeType={'sm'}>

RU

</Button>

## Учебники

:::tip совет для начинающих
Лучшее место для начала разработки с использованием FunC: [ВВЕДЕНИЕ](/v3/documentation/smart-contracts/overview)
:::

Дополнительные материалы, любезно предоставленные экспертами сообщества:

- [🚩 Задача 1: Простое развертывание NFT](https://github.com/romanovichim/TONQuest1)
- [🚩 Задача 2: Контракт чат-бота](https://github.com/romanovichim/TONQuest2)
- [🚩 Задача 3: Торговый автомат жетонов](https://github.com/romanovichim/TONQuest3)
- [🚩 Задача 4: Лотерея/розыгрыш](https://github.com/romanovichim/TONQuest4)
- [🚩 Задача 5: Создание пользовательского интерфейса для взаимодействия с контрактом за 5 минут](https://github.com/romanovichim/TONQuest5)
- [🚩 Задача 6: Анализ продаж NFT на маркетплейсе Getgems](https://github.com/romanovichim/TONQuest6)


- [Func & Blueprint](https://www.youtube.com/watch?v=7omBDfSqGfA&list=PLtUBO1QNEKwtO_zSyLj-axPzc9O9rkmYa) от **@MarcoDaTr0p0je**
- [TON Hello World: пошаговое руководство по написанию вашего первого смарт-контракта](https://helloworld.tonstudio.io/02-contract/)
- [TON Hello World: Пошаговое руководство по тестированию вашего первого смарт-контракта](https://helloworld.tonstudio.io/04-testing/)
- [10 уроков FunC](https://github.com/romanovichim/TonFunClessons_Eng) от **@romanovichim**, с использованием blueprint
- [10 уроков FunC (RU)](https://github.com/romanovichim/TonFunClessons_ru) от **@romanovichim**, с использованием blueprint
- [Тест по FunC](https://t.me/toncontests/60) от **Вадима** — подходит для самопроверки. Займет 10–15 минут. Вопросы в основном о FunС с несколькими общими вопросами о TON
- [Тест по FunC (RU)](https://t.me/toncontests/58?comment=14888) от **Вадима** — тест по FunC на русском языке

## Конкурсы

Вы также можете изучить предыдущие конкурсы в учебных целях.

Вы также можете изучить предыдущие конкурсы в учебных целях.

#### Наследие конкурсов

| Описание конкурса            | Задачи                                                                                                       | Решения                                                                                                                           |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------- |
| TSC #5 (декабрь, 2023)       | [Задачи](https://github.com/ton-community/tsc5)                                                              |                                                                                                                                   |
| TSC #4 (сентябрь, 2023)      | [Задачи](https://github.com/ton-community/tsc4)                                                              | [Решения](/v3/documentation/smart-contracts/contracts-specs/examples#ton-smart-challenge-4)                                       |
| TSC #3 (декабрь, 2022)       | [Задачи](https://github.com/ton-blockchain/func-contest3)                                                    | [Решения](https://github.com/nns2009/TON-FunC-contest-3)                                                                          |
| TSC #2 (июль, 2022)          | [Задачи](https://github.com/ton-blockchain/func-contest2)                                                    | [Решения](https://github.com/ton-blockchain/func-contest2-solutions)                                                              |
| TSC #1 (март, 2022)          | [Задачи](https://github.com/ton-blockchain/func-contest1)                                                    | [Решения](https://github.com/ton-blockchain/func-contest1-solutions)                                                              |

## Примеры смарт-контрактов

Стандартные базовые смарт-контракты, такие как кошельки, выборщики (которые управляют валидацией в TON), кошельки с несколькими подписями и т. д., могут служить ссылками при изучении.

- [Примеры смарт-контрактов](/v3/documentation/smart-contracts/contracts-specs/examples)

## Список изменений

[История обновлений funC](/v3/documentation/smart-contracts/func/changelog).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/ide-plugins.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/ide-plugins.md
================================================
# Плагины для IDE

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Плагин для IntelliJ IDE

![](/img/docs/ton-jetbrains-plugin.png)

:::info
Этот плагин можно использовать с любым продуктом JetBrains.
(IntelliJ IDEA, WebStorm, PyCharm, CLion и т. д.)
:::

Есть несколько способов установки плагина:

- Найдите плагин непосредственно в разделе плагинов IDE с ключевым словом "**TON**"
- [Ссылка на маркетплейс](https://plugins.jetbrains.com/plugin/23382-ton)
- [Репозиторий GitHub](https://github.com/ton-blockchain/intellij-ton)

## Плагин для VS Code

Visual Studio Code — это бесплатная и популярная IDE для разработчиков.

- [Ссылка на маркетплейс](https://marketplace.visualstudio.com/items?itemName=tonwhales.func-vscode)
- [Репозиторий GitHub](https://github.com/ton-foundation/vscode-func)

## Плагин FunC для Sublime Text

- [Репозиторий GitHub](https://github.com/savva425/func_plugin_sublimetext3)

## Neovim

Чтобы включить подсветку синтаксиса в Neovim, следуйте инструкциям по установке в [руководстве по быстрому запуску nvim-treesitter](https://github.com/nvim-treesitter/nvim-treesitter#quickstart).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/javascript.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/javascript.mdx
================================================
import Button from '@site/src/components/button'

# SDK Blueprint

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

![Blueprint](/img/blueprint/logo.svg)

Среда разработки TON для написания, тестирования и развертывания смарт-контрактов.

## Быстрый старт 🚀

Запустите следующее в терминале, чтобы создать новый проект, и следуйте инструкциям на экране:

```bash
npm create ton@latest
```

<Button href="https://www.youtube.com/watch?v=7omBDfSqGfA&list=PLtUBO1QNEKwtO_zSyLj-axPzc9O9rkmYa" colorType={'secondary'} sizeType={'sm'}>

Посмотреть видеоуроки

</Button>

### Основные функции

- Упрощенный рабочий процесс для создания, тестирования и развертывания смарт-контрактов
- Очень простое развертывание в основной сети/тестовой сети с использованием вашего любимого кошелька (например, Tonkeeper)
- Невероятно быстрое тестирование нескольких смарт-контрактов в изолированном блокчейне, запущенном в процессе работы

### Технический стек

- Компиляция FunC с https://github.com/ton-community/func-js (без cli)
- Тестирование смарт-контрактов с помощью https://github.com/ton-org/sandbox
- Развертывание смарт-контрактов с помощью кошельков, совместимых с TON Connect 2.0 или deeplink `ton://`

### Требования

- [Node.js](https://nodejs.org/) с последней версией, например v18, проверьте версию с помощью `node -v`
- IDE с поддержкой TypeScript и FunC, например [Visual Studio Code](https://code.visualstudio.com/) с [плагином FunC](https://marketplace.visualstudio.com/items?itemName=tonwhales.func-vscode)

## Ссылки

### GitHub

- https://github.com/ton-org/blueprint

### Материалы

- [Использование Blueprint на стриме DoraHacks](https://www.youtube.com/watch?v=5ROXVM-Fojo)
- [Создание нового проекта](https://github.com/ton-org/blueprint#create-a-new-project)
- [Разработка нового смарт-контракта](https://github.com/ton-org/blueprint#develop-a-new-contract)
- [[YouTube] Func with Blueprint EN](https://www.youtube.com/watch?v=7omBDfSqGfA&list=PLtUBO1QNEKwtO_zSyLj-axPzc9O9rkmYa) ([RU версия](https://youtube.com/playlist?list=PLyDBPwv9EPsA5vcUM2vzjQOomf264IdUZ))

## См. также

- [Введение в разработку смарт-контракта](/v3/documentation/smart-contracts/overview)
- [Как работать со смарт-контрактами кошелька](/v3/guidelines/smart-contracts/howto/wallet)
- [SDK](/v3/guidelines/dapps/apis-sdks/sdk)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/testnet.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/getting-started/testnet.md
================================================
# Понимание тестовой сети

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Используйте тестовую сеть TON для разработки и тестирования.

:::info
Монеты в тестовой сети не имеют ценности, и сеть может быть сброшена в любое время.
:::

- Глобальная конфигурация тестовой сети: https://ton.org/testnet-global.config.json
- Получите бесплатные тестовые монеты от [@test_giver_ton_bot](https://t.me/testgiver_ton_bot)
- Проверьте статус тестовой сети в Telegram канале: [@testnetstatus](https://t.me/testnetstatus)

### Основные сервисы

Для удобства почти вся инфраструктура основной сети (кошельки, API, мосты и т. д.) была воспроизведена в тестовой сети.

- Проводник: https://testnet.tonscan.org
- Веб-кошелек: https://wallet.ton.org/?testnet=true
- Расширение браузера: используйте [расширение браузера основной сети](https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd) и [сделайте это](https://github.com/toncenter/ton-wallet#switch-between-mainnettestnet-in-extension).
- TON Center AP тестовой сети: https://testnet.toncenter.com
- HTTP API тестовой сети: https://testnet.tonapi.io/
- Мост тестовой сети: https://bridge.ton.org/?testnet=true
- GraphQL dTON тестовой сети: https://testnet.dton.io/

## Сервисы тестовой сети экосистемы TON

### Кошельки

- Чтобы переключиться на [тестовую сеть Tonkeeper](https://tonkeeper.com/), нажмите на версию 5 раз в настройках.
- Тестовая сеть CryptoBot: https://t.me/CryptoTestnetBot
- Специальная ссылка для тестовой сети TON Space: https://t.me/wallet/start?startapp=tonspace_settings
- https://multisig.ton.org/?testnet=true

### Обозреватели

- https://testnet.tonscan.org
- https://testnet.tonviewer.com
- https://test-explorer.toncoin.org
- https://tonsandbox.com/explorer
- https://testnet.ton.cx

### Другие сервисы

- https://minter.ton.org/?testnet=true

- https://dns.ton.org/?testnet=true

- https://vesting.ton.org/?testnet=true

- https://teststaking.xyz

- https://testnet.getgems.io

- https://app.hipo.finance/#/network=testnet/

- https://testnet-elections.toncenter.com/getValidationCycles?limit=2&return_participants=true





================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/ecosystem-messages-layout.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/ecosystem-messages-layout.mdx
================================================
import ConceptImage from '@site/src/components/conceptImage';
import ThemedImage from '@theme/ThemedImage';

# Макет сообщений экосистемы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Отправка сообщений

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_1_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Развертывание контракта

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_2.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_2_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Сжигание жетонов

- Смарт-контракт [modern_jetton](https://github.com/EmelyanenkoK/modern_jetton/blob/master/contracts/op-codes.func)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_3.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_3_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Запросить адрес кошелька жетонов

- Смарт-контракт [modern_jetton](https://github.com/EmelyanenkoK/modern_jetton/blob/master/contracts/op-codes.func)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_4.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_4_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Перевод жетонов

- Смарт-контракт [modern_jetton](https://github.com/EmelyanenkoK/modern_jetton/blob/master/contracts/op-codes.func)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_5_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Выпуск жетонов

- Смарт-контракт [minter-contract](https://github.com/ton-blockchain/minter-contract/blob/main/contracts/imports/op-codes.fc)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_6.png?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_6_dark.png?raw=true',
  }}
/>
</div>
<br></br>

## Подтвердить право собственности SBT на контракт

- Смарт-контракт [nft_contracts](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/op-codes.fc)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_7.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_7_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Перевод NFT

- Смарт-контракт [nft_contracts](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/op-codes.fc)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_8.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_8_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Выпуск NFT

:::info
Не указано в стандарте NFT для /ton-blockchain /token-contract
:::  

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_9.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_9_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Пакетный выпуск NFT

:::info
Не указано в стандарте NFT для /ton-blockchain /token-contract
:::   

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_10.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_10_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Уничтожение SBT пользователем

- Смарт-контракт [nft_contracts](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/op-codes.fc)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_11.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_11_dark.svg?raw=true',
  }}
/>
</div>
<br></br>

## Уничтожение SBT администратором

- Смарт-контракт [nft_contracts](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/op-codes.fc)

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_12.svg?raw=true',
    dark: '/img/docs/ecosystem-messages-layout/ecosystem_messages_layout_12_dark.svg?raw=true',
  }}
/>
</div>
<br></br>



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/external-messages.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/external-messages.md
================================================
# Внешние сообщения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Внешние сообщения `отправляются извне` в смарт-контракты, находящиеся в блокчейне TON, чтобы заставить их выполнить определенные действия.

Например, смарт-контракт кошелька ожидает получения внешних сообщений, содержащих заявки (например, внутренние сообщения, которые должны быть отправлены из смарт-контракта кошелька), подписанных владельцем кошелька. Когда такое внешнее сообщение получено смарт-контрактом кошелька, он сначала проверяет подпись, затем принимает сообщение (запуская примитив TVM `ACCEPT`), а затем выполняет все необходимые действия.

:::danger
Обратите внимание, что все внешние сообщения `должны быть защищены` от атак повторного воспроизведения. Обычно валидаторы удаляют внешнее сообщение из пула предлагаемых внешних сообщений (полученных из сети); однако в некоторых ситуациях `другой валидатор` может обработать одно и то же внешнее сообщение дважды (тем самым создавая вторую транзакцию для одного и того же внешнего сообщения, что приводит к дублированию исходного действия). Хуже того, `злоумышленник может извлечь` внешнее сообщение из блока, содержащего транзакцию обработки, и повторно отправить его позже. Это может заставить смарт-контракт кошелька повторить платеж, например.
:::

export const Highlight = ({children, color}) => (
<span
style={{
backgroundColor: color,
borderRadius: '2px',
color: '#4a080b',
padding: '0.2rem',
}}>
{children} </span>
);

<Highlight color="#ffeced">Самый простой способ защиты смарт-контрактов от атак воспроизведения</Highlight>, связанных с внешними сообщениями, — это хранить 32-битный счетчик `cur-seqno` в постоянных данных смарт-контракта и ожидать значение `req-seqno` в (подписанной части) любых входящих внешних сообщений. Затем внешнее сообщение принимается только в том случае, если и подпись действительна, и `req-seqno` равно `cur-seqno`. После успешной обработки значение `cur-seqno` в постоянных данных увеличивается на единицу, поэтому <Highlight color="#ffeced">то же самое внешнее сообщение больше никогда не будет принято</Highlight>.

И <Highlight color="#ffeced">Можно также</Highlight> включить поле `expire-at` во внешнее сообщение и принять внешнее сообщение, только если текущее время Unix меньше значения этого поля. Этот подход можно использовать вместе с `seqno`; в качестве альтернативы принимающий смарт-контракт может хранить набор (хэшей) всех последних (не просроченных) принятых внешних сообщений в своих постоянных данных и отклонять новое внешнее сообщение, если оно является дубликатом одного из сохраненных сообщений. Также следует выполнить некоторую сборку сообщений с истекшим сроком действия в этом наборе, чтобы избежать раздувания сохраняемых данных.

:::note
В общем случае внешнее сообщение начинается с 256-битной подписи (при необходимости), 32-битного `req-seqno` (при необходимости), 32-битного `expire-at` (при необходимости) и, возможно, 32-битного `op` и других обязательных параметров в зависимости от `op`. Структура внешних сообщений не обязательно должна быть такой же стандартизированной, как структура внутренних сообщений, поскольку внешние сообщения не используются для взаимодействия между различными смарт-контрактами (написанными разными разработчиками и управляемыми разными владельцами).
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/internal-messages.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/internal-messages.md
================================================
# Внутренние сообщения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Общие сведения

Смарт-контракты взаимодействуют друг с другом, отправляя так называемые **внутренние сообщения**. Когда внутреннее сообщение достигает своего адресата, создается обычная транзакция от имени акккаунта получателя, а внутреннее сообщение обрабатывается в соответствии с кодом и постоянными данными этого аккаунта (смарт-контракт).

:::info
В частности, транзакция обработки может создавать одно или несколько исходящих внутренних сообщений, некоторые из которых могут быть адресованы исходному адресу обрабатываемого внутреннего сообщения. Это можно использовать для создания простых "клиент-серверных приложений", когда запрос инкапсулируется во внутреннее сообщение и отправляется другому смарт-контракту, который обрабатывает запрос и снова отправляет ответ в качестве внутреннего сообщения.
:::

Этот подход приводит к необходимости различать, предназначено ли внутреннее сообщение как "запрос", "ответ" или не требует никакой дополнительной обработки (например, "простой денежный перевод"). Кроме того, при получении ответа должен быть способ определить, какому запросу он соответствует.

Для достижения этой цели можно использовать следующие подходы к внутреннему макету сообщения (обратите внимание, что блокчейн TON не накладывает никаких ограничений на тело сообщения, поэтому это всего лишь рекомендации).

### Внутренняя структура сообщения

Тело сообщения может быть встроено в само сообщение или сохранено в отдельной ячейке, на которую ссылается сообщение, как указано во фрагменте схемы TL-B:

```tlb
message$_ {X:Type} ... body:(Either X ^X) = Message X;
```

Принимающий смарт-контракт должен принимать как минимум внутренние сообщения со встроенными телами сообщений (всякий раз, когда они помещаются в ячейку, содержащую сообщение). Если он принимает тела сообщений в отдельных ячейках (используя конструктор `right` из `(Either X ^X)`), обработка входящего сообщения не должна зависеть от конкретного варианта встраивания, выбранного для тела сообщения. С другой стороны, совершенно допустимо не поддерживать тела сообщений в отдельных ячейках для более простых запросов и ответов.

### Внутреннее тело сообщения

Тело сообщения обычно начинается со следующих полей:

```
* A 32-bit (big-endian) unsigned integer `op`, identifying the `operation` to be performed, or the `method` of the smart contract to be invoked.
* A 64-bit (big-endian) unsigned integer `query_id`, used in all query-response internal messages to indicate that a response is related to a query (the `query_id` of a response must be equal to the `query_id` of the corresponding query). If `op` is not a query-response method (e.g., it invokes a method that is not expected to send an answer), then `query_id` may be omitted.
* The remainder of the message body is specific for each supported value of `op`.
```

### Простое сообщение с комментарием

Если `op` равен нулю, то сообщение является "простым сообщением о передаче с комментарием". Комментарий содержится в оставшейся части тела сообщения (без поля `query_id`, т. е. начиная с пятого байта). Если он не начинается с байта `0xff`, комментарий является текстовым; он может быть отображен "как есть" конечному пользователю кошелька (после фильтрации недопустимых и контрольных символов и проверки того, что это допустимая строка UTF-8).

Когда комментарий настолько длинный, что не помещается в ячейку, не вмещающийся конец строки помещается в первую ссылку ячейки. Этот процесс продолжается рекурсивно для описания комментариев, которые не помещаются в две или более ячеек:

```
root_cell("0x00000000" - 32 bit, "string" up to 123 bytes)
         ↳1st_ref("string continuation" up to 127 bytes)
                 ↳1st_ref("string continuation" up to 127 bytes)
                         ↳....
```

Тот же формат используется для комментариев переводов NFT и [жетонов](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#forward_payload-format).

Например, пользователи могут указать цель простого перевода со своего кошелька на кошелек другого пользователя в этом текстовом поле. С другой стороны, если комментарий начинается с байта `0xff`, то остаток представляет собой "двоичный комментарий", который не должен отображаться конечному пользователю в виде текста (только в виде шестнадцатеричного дампа, если необходимо). Предполагаемое использование "двоичных комментариев" заключается, например, в том, чтобы содержать идентификатор покупки для платежей в магазине, который автоматически генерируется и обрабатывается программным обеспечением магазина.

Большинство смарт-контрактов не должны выполнять нетривиальные действия или отклонять входящее сообщение при получении "простого сообщения о переводе". Таким образом, как только `op` оказывается равным нулю, функция смарт-контракта для обработки входящих внутренних сообщений (обычно называемая `recv_internal()`) должна немедленно завершиться с нулевым кодом выхода, указывающим на успех (например, путем выдачи исключения `0`, если смарт-контрактом не был установлен пользовательский обработчик исключений). Это приведет к тому, что на принимающий аккаунт будет зачислено значение, переданное сообщением, без каких-либо дальнейших последствий.

### Сообщения с зашифрованными комментариями

Если `op` равен `0x2167da4b`, то сообщение является "сообщением передачи с зашифрованным комментарием". Это сообщение сериализуется следующим образом:

Ввод:

- `pub_1` и `priv_1` - Ed25519 открытый и закрытый ключи отправителя, по 32 байта каждый.
- `pub_2` - Ed25519 открытый ключ получателя, 32 байта.
- `msg` - сообщение для шифрования, произвольная строка байтов. `len(msg) <= 960`.

Алгоритм шифрования следующий:

1. Вычислить `shared_secret` с помощью `priv_1` и `pub_2`.
2. Пусть `salt` будет [представлением bas64url](/v3/documentation/smart-contracts/addresses#user-friendly-address) адреса кошелька отправителя с `isBounceable=1` и `isTestnetOnly=0`.
3. Выберите байтовую строку `prefix` длиной от 16 до 31, так что `len(prefix+msg)` делится на 16. Первый байт `prefix` равен `len(prefix)`, остальные байты случайны. Пусть `data = prefix + msg`.
4. Пусть `msg_key` будет первыми 16 байтами `hmac_sha512(salt, data)`.
5. Вычислите `x = hmac_sha512(shared_secret, msg_key)`. Пусть `key=x[0:32]` и `iv=x[32:48]`.
6. Зашифруйте `data` с помощью AES-256 в режиме CBC с `key` и `iv`.
7. Создайте зашифрованный комментарий:
  1. `pub_xor = pub_1 ^ pub_2` - 32 байта. Это позволяет каждой стороне расшифровать сообщение, не заглядывая в открытый ключ другой стороны.
  2. `msg_key` - 16 байт.
  3. Зашифрованные `data`.
8. Тело сообщения начинается с 4-байтового тега `0x2167da4b`. Затем этот зашифрованный комментарий сохраняется:
  1. Строка байтов делится на сегменты и сохраняется в цепочке ячеек `c_1,...,c_k` (`c_1` является корнем тела). Каждая ячейка (кроме последней) имеет ссылку на следующую.
  2. `c_1` содержит до 35 байт (не включая 4-байтовый тег), все остальные ячейки содержат до 127 байт.
  3. Этот формат имеет следующие ограничения: `k <= 16`, максимальная длина строки 1024.

Тот же формат используется для комментариев при переводе NFT и жетонов, обратите внимание, что следует использовать открытый ключ адреса отправителя и адреса получателя (не адреса jetton-wallet).

:::info
Learn from examples of the message encryption algorithm:

- [encryption.js](https://github.com/toncenter/ton-wallet/blob/master/src/js/util/encryption.js)
- [SimpleEncryption.cpp](https://github.com/ton-blockchain/ton/blob/master/tonlib/tonlib/keys/SimpleEncryption.cpp)
  :::

### Простые сообщения о передаче без комментариев

"Простое сообщение о передаче без комментариев" имеет пустое тело (даже без поля `op`). Вышеизложенные соображения применимы и к таким сообщениям. Обратите внимание, что такие сообщения должны иметь свои тела, встроенные в ячейку сообщения.

### Различие между сообщениями запроса и ответа

Мы ожидаем, что сообщения "запроса" будут иметь `op` с очищенным старшим битом, т. е. в диапазоне `1 .. 2^31-1`, а сообщения "ответа" будут иметь `op` с установленным старшим битом, т. е. в диапазоне `2^31 .. 2^32-1`. Если метод не является ни запросом, ни ответом (так что соответствующее тело сообщения не содержит поля `query_id`), он должен использовать `op` в диапазоне "запроса" `1 .. 2^31 - 1`.

### Обработка стандартных сообщений ответа

Существуют некоторые "стандартные" сообщения ответа с `op`, равным `0xffffffff` и `0xfffffffe`. В общем случае значения `op` от `0xffffffff0` до `0xffffffff` зарезервированы для таких стандартных ответов.

```
* `op` = `0xffffffff` means "operation not supported". It is followed by the 64-bit `query_id` extracted from the original query, and the 32-bit `op` of the original query. All but the simplest smart contracts should return this error when they receive a query with an unknown `op` in the range `1 .. 2^31-1`.
* `op` = `0xfffffffe` means "operation not allowed". It is followed by the 64-bit `query_id` of the original query, followed by the 32-bit `op` extracted from the original query.
```

Обратите внимание, что неизвестные "ответы" (с `op` в диапазоне `2^31 .. 2^32-1`) следует игнорировать (в частности, в ответ на них не следует генерировать ответ с `op`, равным `0xffffffff`), так же как и неожиданные возвращенные сообщения (с установленным флагом "bounced").

## Известные коды операций

:::info
Также op-code, op::code и операционный код
:::

| Тип контракта | Шестнадцатеричный код | OP::Code                                                                                                   |
| ------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| Общий         | 0x00000000            | Текстовый комментарий                                                                                                                      |
| Общий         | 0xffffffff            | Отклонение                                                                                                                                 |
| Общий         | 0x2167da4b            | [Зашифрованный комментарий](/v3/documentation/smart-contracts/message-management/internal-messages#messages-with-encrypted-comments)       |
| Общий         | 0xd53276db            | Избыток                                                                                                                                    |
| Электор       | 0x4e73744b            | Новая ставка                                                                                                                               |
| Электор       | 0xf374484c            | Подтверждение новой ставки                                                                                                                 |
| Электор       | 0x47657424            | Запрос на восстановление ставки                                                                                                            |
| Электор       | 0x47657424            | Ответ на восстановление ставки                                                                                                             |
| Кошелек       | 0x0f8a7ea5            | Перевод жетонов                                                                                                                            |
| Кошелек       | 0x235caf52            | [Вызов жетона](https://testnet.tonviewer.com/transaction/1567b14ad43be6416e37de56af198ced5b1201bb652f02bc302911174e826ef7)                 |
| Жетон         | 0x178d4519            | Внутренняя передача жетона                                                                                                                 |
| Жетон         | 0x7362d09c            | Уведомление жетона                                                                                                                         |
| Жетон         | 0x595f07bc            | Сжигание жетона                                                                                                                            |
| Жетон         | 0x7bdd97de            | Уведомление о сжигании жетона                                                                                                              |
| Жетон         | 0xeed236d3            | Установка статуса жетона                                                                                                                   |
| Выпуск жетона | 0x642b7d07            | Выпуск жетона                                                                                                                              |
| Выпуск жетона | 0x6501f354            | Изменение администратора жетона                                                                                                            |
| Выпуск жетона | 0xfb88e119            | Запрос администратора жетона                                                                                                               |
| Выпуск жетона | 0x7431f221            | Сброс администратора жетона                                                                                                                |
| Выпуск жетона | 0xcb862902            | Изменение метаданных жетона                                                                                                                |
| Выпуск жетона | 0x2508d66a            | Обновление жетона                                                                                                                          |
| Вестинг       | 0xd372158c            | [Пополнение](https://github.com/ton-blockchain/liquid-staking-contract/blob/be2ee6d1e746bd2bb0f13f7b21537fb30ef0bc3b/PoolConstants.ts#L28) |
| Вестинг       | 0x7258a69b            | Добавление белого списка                                                                                                                   |
| Вестинг       | 0xf258a69b            | Добавление ответа в белый список                                                                                                           |
| Вестинг       | 0xa7733acd            | Отправка                                                                                                                                   |
| Вестинг       | 0xf7733acd            | Отправка ответа                                                                                                                            |
| Dedust        | 0x9c610de3            | Обмен ExtOut на Dedust                                                                                                                     |
| Dedust        | 0xe3a0d482            | Обмен жетонов на Dedust                                                                                                                    |
| Dedust        | 0xea06185d            | Внутренний обмен Dedust                                                                                                                    |
| Dedust        | 0x61ee542d            | Внешний обмен                                                                                                                              |
| Dedust        | 0x72aca8aa            | Обмен пирами                                                                                                                               |
| Dedust        | 0xd55e4686            | Внутренний депозит ликвидности                                                                                                             |
| Dedust        | 0x40e108d6            | Депозит ликвидности жетона                                                                                                                 |
| Dedust        | 0xb56b9598            | Ликвидность всех депозитов                                                                                                                 |
| Dedust        | 0xad4eb6f5            | Выплаты из пула                                                                                                                            |
| Dedust        | 0x474а86са            | Выплата                                                                                                                                    |
| Dedust        | 0xb544f4a4            | Депозит                                                                                                                                    |
| Dedust        | 0x3aa870a6            | Вывод                                                                                                                                      |
| Dedust        | 0x21cfe02b            | Создать хранилище                                                                                                                          |
| Dedust        | 0x97d51f2f            | Создать непостоянный пул                                                                                                                   |
| Dedust        | 0x166cedee            | Отмена депозита                                                                                                                            |
| StonFi        | 0x25938561            | Внутренний обмен                                                                                                                           |
| StonFi        | 0xf93bb43f            | Запрос платежа                                                                                                                             |
| StonFi        | 0xfcf9e58f            | Обеспечение ликвидности                                                                                                                    |
| StonFi        | 0xc64370e5            | Успешный обмен                                                                                                                             |
| StonFi        | 0x45078540            | Ссылка на успешный обмен                                                                                                                   |

:::info
[DeDust docs](https://docs.dedust.io/docs/swaps)

[Документация StonFi](https://docs.ston.fi/docs/developer-section/architecture#calls-descriptions)
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/message-modes-cookbook.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/message-modes-cookbook.mdx
================================================
import ConceptImage from "@site/src/components/conceptImage";
import ThemedImage from "@theme/ThemedImage";

# Рецепты режимов сообщений

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Понимание различных режимов и флагов, доступных для отправки сообщений, имеет решающее значение для обеспечения того, чтобы ваши смарт-контракты вели себя так, как задумано.
Хотя в разделе [режимы сообщений](/v3/documentation/smart-contracts/message-management/sending-messages#message-modes) были предоставлены подробные описания этих режимов и флагов, в этом разделе мы проиллюстрируем их практическое применение на конкретных примерах.

:::info ВАЖНО
Вы можете проверить [этот пример](https://testnet.tonviewer.com/transaction/42ed45726e4fe994b7fd6dbf953a2ac24ecd77753858abeda9d6755c664a537a) в качестве реальной проверки.
:::

#### Значение сообщения и баланс аккаунта

Пожалуйста, проверьте, как работает [get_balance](/v3/documentation/smart-contracts/func/docs/stdlib/#get_balance), чтобы лучше понять состояние транзакции.

Существует два способа оплаты действий в блокчейне:

- Из [значения сообщения](/v3/documentation/data-formats/tlb/msg-tlb#commonmsginfo)
- Из [баланса контракта](https://github.com/ton-blockchain/ton/blob/7151ff26279fef6dcfa1f47fc0c5b63677ae2458/crypto/block/block.tlb#L263C1-L265C20)

Обычно она взимается с `balance` контракта, но в определенных случаях будет использоваться часть `value` сообщения.

#### Комиссии

Фактические комиссии за транзакции будут варьироваться в зависимости от конфигурации блокчейна, кода смарт-контракта и других факторов. При получении сообщения часть `balance` контракта будет израсходована на [storage fee](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#storage-fee) и gas_fees, если `value` сообщения [выше определенной суммы](/v3/documentation/tvm/tvm-overview#compute-phase-skipped).

Согласно [потоку транзакций](/v3/documentation/tvm/tvm-overview#transactions-and-phases) существует 5 фаз:

- Хранилище, состоящее из [хранилища аккаунта](https://github.com/ton-blockchain/ton/blob/7151ff26279fef6dcfa1f47fc0c5b63677ae2458/crypto/block/transaction.cpp#L651-L675) и [импорта in_msg](https://github.com/ton-blockchain/ton/blob/7151ff26279fef6dcfa1f47fc0c5b63677ae2458/crypto/block/transaction.cpp#L783-L816)
- [Кредит](https://github.com/ton-blockchain/ton/blob/7151ff26279fef6dcfa1f47fc0c5b63677ae2458/crypto/block/transaction.cpp#L959-L981), где in_msg `value` добавляется к `balance`
- Вычисление, при котором фактический код смарт-контракта выполняется в TVM
- Действие, где выполняются действия, такие как `SENDRAWMSG`
- Отскок, где обрабатывается все, что связано с отскоком

Порядок: storage_fee -> import_fee -> gas_fee -> action_fee + fwd_fee

:::info ВАЖНО
Таблица заполнена из [этого примера](https://tonviewer.com/transaction/b5e14a9c4a4e982fda42d6079c3f84fa48e76497a8f3fca872f9a3737f1f6262). Вы можете проверить [**калькулятор**](/v3/documentation/smart-contracts/transaction-fees/fees#basic-fees-formula).
:::

| Комиссия в проводнике                                                                                     | Значение       | Как она получена                            |
| :-------------------------------------------------------------------------------------------------------- | :------------- | :------------------------------------------ |
| Общая комиссия                                                                                            | 0,001982134    | газ + хранение + действие + импорт          |
| total_fwd_fees                                                                                            | 0,001          | fwd_fee + action_fee + ihr_fee              |
| gas_fees                                                                                                  | 0,0011976      | фаза вычислений, использованный газ         |
| storage_fees                                                                                              | 0,000000003    | фаза хранения, только аккаунт               |
| total_action_fees                                                                                         | 0,000133331    | фаза действий, стоимость за действие        |
| import_fee (скрыто)                                                                                       | 0,0006512      | стоимость импорта ext_msg                   |
| [fwd_fee](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#formula-1) (каждое сообщение) | 0,000266669    | стоимость fwd in_msg                        |
| [ihr_fee](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#ihr) (каждое сообщение)       | 0.0006         | стоимость ihr fwd in_msg                    |

:::info
Комиссии транзакций, используемые в этих примерах, являются гипотетическими и используются исключительно для иллюстрации, любые сборы, кроме сборов за пересылку сообщений, выходят за рамки данной статьи.
:::

## 1. Отправить обычное сообщение

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON

**A** отправил 0,1 TON **B**, [msg_fwd_fees](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#forward-fees) составляют 0,004 TON, фактическое полученное значение составит 0,096 TON, `fwd_fee` и `action_fee` вычтены из `value`.

Состояние после транзакции: аккаунт A имеет 0,9 TON, аккаунт B имеет 1,096 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_1.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_1_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги          | Код                        |
| :--------------------- | :------------------------- |
| `mode` = 0, без `flag` | `send_raw_message(msg, 0)` |

## 2. Отправить обычное сообщение, не отклонять сообщение об ошибке и игнорировать его

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON

**A** отправил 0,1 TON на **B**, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,096 TON, `fwd_fee` и `action_fee` вычитаются из `value`.
В случае ошибки во время обработки транзакции сообщение не будет возвращено и будет проигнорировано.

Состояние после транзакции: аккаунт A имеет 0,9 TON, аккаунт B имеет 1,096 TON

:::info подсказка
Средства, включенные в проигнорированное сообщение, все равно будут [зачислены на адрес получателя](https://testnet.tonviewer.com/transaction/8a388731812c80ab9b0ea9531108425488af5def854e4bd6f0ed47362b56d557).
Если ошибок нет, результат такой же, как и [`mode = 0`](#1-send-a-regular-message).
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_2.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_2_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги          | Код                        |
| :--------------------- | :------------------------- |
| `mode` = 0, `flag` = 2 | `send_raw_message(msg, 2)` |

## 3. Отправить обычное сообщение и отклонить сообщение об ошибке действия

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON

**A** отправил 0,1 TON на **B**, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,096 TON, `fwd_fee` и `action_fee` вычтены из `value`.
В случае ошибки на [фазе действия](https://retracer.ton.org/?tx=e9dccba82badc0d742f14eff41c203280f380e87180b5314fcfd742856e598f7&testnet=true) сообщение будет отклонено, а `total_fee` + `fwd_fee` будут вычтены из `value`.

Состояние после транзакции с ошибкой: у аккаунта A 1 - ([total_fee](/v3/documentation/smart-contracts/transaction-fees/fees#basic-fees-formula) + `fwd_fee`) TON, у аккаунта B 1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_3_error.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_3_error_dark.png?raw=true",
    }}
  />
</div>
<br></br>

:::info подсказка
Если ошибок нет, результат такой же, как у [`mode = 0`](#1-send-a-regular-message).
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_3_noerror.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_3_noerror_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги           | Код                         |
| :---------------------- | :-------------------------- |
| `mode` = 0, `flag` = 16 | `send_raw_message(msg, 16)` |

## 4. Отправить обычное сообщение с разделением комиссий

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON

**A** отправил 0,1 TON на **B**, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,1 TON, `fwd_fee` и `action_fee` вычтены из `balance`.

Состояние после транзакции: аккаунт A имеет 0,896 TON, аккаунт B имеет 1,1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_4.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_4_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги          | Код                        |
| :--------------------- | :------------------------- |
| `mode` = 0, `flag` = 1 | `send_raw_message(msg, 1)` |

## 5. Отправить обычное сообщение с разделением комиссий и отклонить сообщение об ошибке

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON

**A** отправил 0,1 TON на **B**, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,1 TON, `fwd_fee` и `action_fee` вычтены из `balance`.
В случае ошибки [во время фазы действия](https://retracer.ton.org/?tx=e9dccba82badc0d742f14eff41c203280f380e87180b5314fcfd742856e598f7&testnet=true) сообщение будет отклонено, и `total_fee` + `fwd_fee` будут вычтены из `value`.

Состояние после транзакции с ошибкой: у аккаунта A 1 - ([total_fee](/v3/documentation/smart-contracts/transaction-fees/fees#basic-fees-formula) + `fwd_fee`) TON, у аккаунта B 1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_5_error.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_5_error_dark.png?raw=true",
    }}
  />
</div>
<br></br>

:::info подсказка
Если ошибок нет, результат такой же, как у [`mode = 1`](#4-send-a-regular-message-with-separate-fees).
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/send_regular_message_5_noerror.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/send_regular_message_5_noerror_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги                    | Код                         |
| :------------------------------- | :-------------------------- |
| `mode` = 0, `flag` = 1 + 16 = 17 | `send_raw_message(msg, 17)` |

## 6. Перенести оставшееся значение с новым сообщением

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON **B**, после чего **B** отправил 0,5 TON **C** с `mode` = 64, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное `value` составит 0,6 TON, total_fee + `fwd_fee` вычтено из `value`.

Состояние после транзакции: аккаунт A имеет 0,896 TON, аккаунт B имеет 0,5 TON, аккаунт C имеет 1,6 - (total_fee + `fwd_fee`) TON

:::info
Вы можете проверить [этот пример](https://retracer.ton.org/?tx=4340b5ecbd83227cc64e10b1ca7628352133cda1d608081fb2ed58d299f00936&testnet=true).
Обратите внимание, что `storage_fee` включен в `total_fee`, но всегда оплачивается из `balance` контракта.
:::

:::warning
Please note that `SENDRAWMSG` doesn't update balance.

Если вы попытаетесь отправить несколько сообщений (т. е. режим 0 **и** режим 64), вы получите код выхода 37.

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_6.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_6_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги           | Код                         |
| :---------------------- | :-------------------------- |
| `mode` = 64, без `flag` | `send_raw_message(msg, 64)` |

## 7. Перенести оставшееся значение в новое сообщение с разделением комиссий

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON на **B**, после чего **B** отправил 0,5 TON на **C** с `mode` = 65, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,6 TON, total_fee + `fwd_fee` вычтено из `balance`.

Состояние после транзакции: аккаунт A имеет 0,896 TON, аккаунт B имеет 0,5 - (total_fee + `fwd_fee`) TON, аккаунт C имеет 1,6 TON

:::info
Вы можете проверить [этот пример](https://retracer.ton.org/?tx=5c2525feeb3b93db594b7b11f3250430f02dd8616595cf2b1583ebc7da79d15b&testnet=true).
Обратите внимание, что `storage_fee` включен в `total_fee`, но он всегда оплачивается из `balance` контракта.
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_7.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_7_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги           | Код                         |
| :---------------------- | :-------------------------- |
| `mode` = 64, `flag` = 1 | `send_raw_message(msg, 65)` |

## 8. Перенести оставшееся значение и отклонить сообщение об ошибке

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON в **B**, после чего **B** отправил 0,5 TON в **C** с `mode` = 80, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,6 TON, total_fee + `fwd_fee` вычтено из `value`.
В случае ошибки во время фазы действия сообщение будет отклонено, и `total_fee` + `fwd_fee` вычтено из `value`.

Состояние после транзакции с ошибкой: аккаунт A имеет 1 - (total_fee + `fwd_fee`) TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_8_error.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_8_error_dark.png?raw=true",
    }}
  />
</div>
<br></br>

:::info подсказка
Если ошибок нет, результат такой же, как [`mode = 64`](#6-carry-remaining-value-with-new-message). Этот режим на самом деле часто используется в TON для переводов жетонов, вы можете [проверить его в списке действий C5](https://retracer.ton.org/?tx=6489d60d9197c0be7ee64b0812139d82221e8f94c6e378c356acc10f9067310c) кошелька жетона.
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_8_noerror.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_8_noerror_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги            | Код                         |
| :----------------------- | :-------------------------- |
| `mode` = 64, `flag` = 16 | `send_raw_message(msg, 80)` |

## 9. Перенести оставшееся значение в новое сообщение с разделением комиссий и отклонить сообщение об ошибке

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON в **B**, после чего **B** отправил 0,5 TON в **C** с `mode` = 80, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 0,6 TON, total_fee + `fwd_fee` вычтено из `value`.
В случае ошибки во время фазы действия сообщение будет отклонено, и `total_fee` + `fwd_fee` вычтено из `value`.

Состояние после транзакции с ошибкой: аккаунт A имеет 1 - (total_fee + `fwd_fee`) TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_9_error.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_9_error_dark.png?raw=true",
    }}
  />
</div>
<br></br>

:::info подсказка
Если ошибок нет, результат такой же, как у [`mode = 65`](#7-carry-remaining-value-with-new-message-with-separate-fees).
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_9_noerror.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_9_noerror_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги                | Код                          |
| :--------------------------- | :--------------------------- |
| `mode` = 64, `flag` = 16 + 1 | `send_raw_message(msg, 81)`. |

## 10. Отправить все полученные токены вместе с балансом контракта

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON на **B**, после чего **B** отправил 0,5 TON на **C** с `mode` = 128, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение будет 1,1 - total_fee TON, total_fee вычтено из `value`.

Состояние после транзакции: аккаунт A имеет 0,896 TON, аккаунт B имеет 0 TON, аккаунт C имеет 2,1 - (total_fee + `fwd_fee`) TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_10.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_10_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги            | Код                           |
| :----------------------- | :---------------------------- |
| `mode` = 128, без `flag` | `send_raw_message(msg, 128)`. |

## 11. Отправить все полученные токены вместе с балансом контракта и отклонить сообщение об ошибке

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON на **B**, после чего **B** отправил 0,5 TON на **C** с `mode` = 144, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение будет 1,1 - total_fee TON, total_fee вычтено из `value`.

Состояние после транзакции с ошибкой: аккаунт A имеет 1 - (total_fee + `fwd_fee`) TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_11_error.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_11_error_dark.png?raw=true",
    }}
  />
</div>
<br></br>

:::info подсказка
Если ошибок нет, результат такой же, как [`mode = 128`](#10-send-all-received-tokens-together-with-the-contract-balance). Этот режим на самом деле часто используется в TON для переводов жетонов, вы можете [проверить его в списке действий C5](https://retracer.ton.org/?tx=e4f31e37eec74a8cfcecdad9246a6bbf3da20c4edb3635150cb0fa54b9def558) кошелька жетона.
:::

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_11_noerror.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_11_noerror_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги             | Код                          |
| :------------------------ | :--------------------------- |
| `mode` = 128, `flag` = 16 | `send_raw_message(msg, 144)` |

## 12. Отправить все полученные токены вместе с балансом контракта и уничтожить смарт-контракт

Состояние до транзакции: аккаунт A имеет 1 TON, аккаунт B имеет 1 TON, аккаунт C имеет 1 TON

**A** отправил 0,1 TON на **B**, после чего **B** отправил 0,5 TON на **C** с `mode` = 160, `msg_fwd_fees` составляет 0,004 TON, фактическое полученное значение составит 1,1 - total_fee TON, total_fee вычтено из `value`.

Состояние после транзакции: аккаунт A имеет 0,896 TON, аккаунт B имеет 0 TON и `nonexist`, аккаунт C имеет 2,1 - (total_fee + `fwd_fee`) TON

Когда баланс достигнет 0 TON, уничтожить контракт.

<br></br>
<div class="text--center">
  <ThemedImage
    alt=""
    sources={{
      light:
        "/img/docs/message-modes-cookbook/carry_remaining_value_12.png?raw=true",
      dark: "/img/docs/message-modes-cookbook/carry_remaining_value_12_dark.png?raw=true",
    }}
  />
</div>
<br></br>

| Режим и флаги             | Код                           |
| :------------------------ | :---------------------------- |
| `mode` = 128, `flag` = 32 | `send_raw_message(msg, 160)`. |



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/messages-and-transactions.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/messages-and-transactions.mdx
================================================
import ConceptImage from '@site/src/components/conceptImage';
import ThemedImage from '@theme/ThemedImage';

# Сообщения и транзакции

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

TON – это асинхронный блокчейн со сложной структурой, которая сильно отличается от других блокчейнов. В связи с этим у новых разработчиков часто возникают вопросы о низкоуровневом устройстве в TON. В этой статье мы рассмотрим один из таких вопросов, связанный с доставкой сообщений.

## Что такое сообщение?

Сообщение – это пакет данных, которым обмениваются участники (пользователи, приложения или смарт-контракты). Обычно оно содержит информацию, указывающую получателю, какое действие следует выполнить, например, обновить хранилище или отправить новое сообщение.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_1.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_1_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Работа с таким типом обмена данными напоминает запуск спутника в космос. Хотя мы точно знаем, какое сообщение мы создали, после запуска необходимо наблюдение, чтобы определить результат.

## Что такое транзакция?

Транзакция в TON состоит из следующего:

- входящее сообщение – инициирует запуск контракта (существуют специальные способы запуска)
- действия контракта, вызванные входящим сообщением, например, обновление хранилища контракта (необязательно)
- исходящие сообщения – создаются и отправляются другим участникам (необязательно).

> Технически контракт может быть запущен с помощью специальных функций, таких как [Tick-Tock](/v3/documentation/data-formats/tlb/transaction-layout#tick-tock), но эта функция чаще используется для внутренних контрактов ядра TON Blockchain.
>
> Не каждая транзакция приводит к созданию исходящих сообщений или обновлению хранилища контракта – это зависит от действий, заложенных в коде контракта.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_2.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_2_dark.png?raw=true',
  }}
/>
<br></br>

В асинхронной системе вы не можете получить ответ от целевого смарт-контракта в пределах той же транзакции. Обработка вызова контракта может занять несколько блоков, в зависимости от длины маршрута между источником и местом назначения.

Достижение парадигмы бесконечного шардинга требует полной параллелизации, гарантирующей, что каждая транзакция будет выполняться независимо от других. Поэтому вместо транзакций, которые затрагивают и изменяют состояние многих контрактов одновременно, каждая транзакция в TON выполняется только на одном смарт-контракте, а смарт-контракты обмениваются данными посредством сообщений. Таким образом, смарт-контракты могут взаимодействовать друг с другом только путем вызова их функций с помощью специальных сообщений и последующего получения на них ответа с помощью других сообщений.

Достижение парадигмы бесконечного шардинга требует полной параллелизации, гарантирующей, что каждая транзакция будет выполняться независимо от других. Поэтому вместо транзакций, которые затрагивают и изменяют состояние многих контрактов одновременно, каждая транзакция в TON выполняется только на одном смарт-контракте, а смарт-контракты обмениваются данными посредством сообщений. Таким образом, смарт-контракты могут взаимодействовать друг с другом только путем вызова их функций с помощью специальных сообщений и последующего получения на них ответа с помощью других сообщений.

:::info
Более подробное и точное описание на странице [Transaction Layout](/v3/documentation/data-formats/tlb/transaction-layout).
:::

### Результат транзакции

Существует [код завершения TVM](/v3/documentation/tvm/tvm-exit-codes) для транзакции, которая находилсь в фазе вычисления, и если значение данного кода не равно `0` или `1`, то произошла ошибка.
Также [фаза вычислений TVM может быть пропущена](/v3/documentation/tvm/tvm-overview#compute-phase-skipped), например, из-за отсутствия средств или статуса состояния.

:::info для toncenter api v3
Для определения успешности транзакции следует использовать `tx.description.action.success` && `tx.description.compute_ph.success`:
:::

```json
"transactions": [
    {
      "description": {
        . . . . . . . .
        "action": {
          "valid": true,
          "success": true,
         . . . . . . . .
          },
. . . . . . . .
        "destroyed": false,
        "compute_ph": {
          "mode": 0,
          "type": "vm",
          "success": true,
```

Транзакция может иметь один из трех результатов:

- Success, exit code: `0` или `1` – успешно
- Fail, `aborted: true` – неуспешно, прервано без выполнения
- Fail, [exit code](/v3/documentation/tvm/tvm-exit-codes), `aborted: true` – неуспешно, прервано.

:::info для toncenter api v3
`aborted: true` является полем из Toncenter API, а не полем вывода транзакции
:::

## Что такое логическое время?

Строго гарантируется, что транзакция, являющаяся результатом сообщения, будет иметь _lt_ больше, чем _lt_ сообщения. Аналогично _lt_ сообщения, отправленного в некоторой транзакции, строго больше, чем _lt_ транзакции, которая его вызвала. Сообщения, отправленные с одного аккаунта и транзакции, произошедшие на одном аккаунте, также строго упорядочены.

Строго гарантируется, что транзакция, являющаяся результатом сообщения, будет иметь _lt_ больше, чем _lt_ сообщения. Аналогично _lt_ сообщения, отправленного в некоторой транзакции, строго больше, чем _lt_ транзакции, которая его вызвала. Сообщения, отправленные с одного аккаунта и транзакции, произошедшие на одном аккаунте, также строго упорядочены.

<br></br>
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_3.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_3_dark.png?raw=true',
  }}
/>
<br></br>

Благодаря _lt_ мы всегда знаем порядок транзакций, полученных и отправленных сообщений для каждого аккаунта.

Более того, если аккаунт _A_ отправил два сообщения аккаунту _B_, гарантируется, что сообщение с меньшим _lt_ будет обработано раньше:

Если `msg1_lt < msg2_lt` => `tx1_lt < tx2_lt`.

Если `msg1_lt < msg2_lt` => `tx1_lt < tx2_lt`.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_5.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_5_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Для каждого блока мы можем определить _lt_-диапазон, который начинается с первой транзакции и заканчивается _lt_ последнего события в блоке (сообщения или транзакции). Блоки упорядочены так же, как и другие события в TON, поэтому если один блок зависит от другого, он имеет более высокое _lt_. Дочерний блок в шарде имеет более высокое _lt_, чем его родитель. _lt_ мастерчейн-блока выше, чем _lts_ каждого вложенного шард-блока, поскольку мастер-блок зависит от вложенных шард-блоков. Каждый шард-блок содержит упорядоченную ссылку на последний мастер-блок (на момент создания шард-блока), поэтому _lt_ шард-блока выше, чем _lt_ мастер-блока на который они ссылаются.

Для каждого блока мы можем определить _lt_-диапазон, который начинается с первой транзакции и заканчивается _lt_ последнего события в блоке (сообщения или транзакции). Блоки упорядочены так же, как и другие события в TON, поэтому если один блок зависит от другого, он имеет более высокое _lt_. Дочерний блок в шарде имеет более высокое _lt_, чем его родитель. _lt_ мастерчейн-блока выше, чем _lts_ каждого вложенного шард-блока, поскольку мастер-блок зависит от вложенных шард-блоков. Каждый шард-блок содержит упорядоченную ссылку на последний мастер-блок (на момент создания шард-блока), поэтому _lt_ шард-блока выше, чем _lt_ мастер-блока на который они ссылаются.

## Доставка сообщений

К счастью, TON работает таким образом, что любое внутреннее сообщение будет обязательно получено целевым аккаунтом. Сообщение не может потеряться где-то между источником и получателем. С внешними сообщениями дело обстоит немного иначе, поскольку их принятие в блок происходит по усмотрению валидатора. Однако, как только сообщение будет принято в очередь входящих сообщений, оно будет доставлено.

### Порядок доставки

Предположим, что существует два контракта – _A_ и _B_. _A_ получает внешнее сообщение, которое запускает отправку двух внутренних сообщений контракту _B_, назовем их сообщения _1_ и _2_. В этом простом случае мы можем на 100% быть уверены, что сообщение _1_ будет обработано _B_ раньше, чем _2_ поскольку оно имеет меньшее _lt_.

Предположим, что существует два контракта – _A_ и _B_. _A_ получает внешнее сообщение, которое запускает отправку двух внутренних сообщений контракту _B_, назовем их сообщения _1_ и _2_. В этом простом случае мы можем на 100% быть уверены, что сообщение _1_ будет обработано _B_ раньше, чем _2_ поскольку оно имеет меньшее _lt_.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-1.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-1-dark.png?raw=true',
  }}
/>
</div>
<br></br>

Это простой случай, когда у нас только два контракта. Как наша система работает в более сложных случаях?

### Несколько смарт-контрактов

Для большей наглядности предположим, что наши контракты отправляют обратно сообщения `msg1'` и `msg2'` после `msg1` и `msg2`, выполненных контрактами `B` и `C`. В результате `tx2'` и `tx1'` будет применено к контракту `A`.
Есть две возможные трассировки для этих транзакций,

Для большей наглядности предположим, что наши контракты отправляют обратно сообщения `msg1'` и `msg2'` после `msg1` и `msg2`, выполненных контрактами `B` и `C`. В результате `tx2'` и `tx1'` будет применено к контракту `A`.
Есть две возможные трассировки для этих транзакций,

1. Первый возможный порядок – `tx1'_lt < tx2'_lt`:

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_6.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_6_dark.png?raw=true',
  }}
/>
</div>
<br></br>

2. Второй возможный порядок – `tx2'_lt < tx1'_lt`:

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/message_delivery_7.png?raw=true',
    dark: '/img/docs/message-delivery/message_delivery_7_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Тоже самое происходит и в обратном случае, когда два контракта _B_ и _C_ отправляют сообщение одному контракту _A_. Даже если сообщение `B -> A` было отправлено раньше, чем `C -> A`, мы не можем знать какое из них будет доставлено первым. Маршрут `B -> A` может потребовать большего количества переходов по цепочке шардов.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-3.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-3_dark.png?raw=true',
  }}
/>
</div>
<br></br>

Возможных сценариев взаимодействия смарт-контрактов может быть множество и в любом сценарии с более чем 2 контрактами порядок доставки сообщений может быть произвольным. Единственная гарантия заключается в том, что сообщения от любого контракта _A_ к любому контракту _B_ будут обрабатываться в порядке их логического времени. Некоторые примеры приведены ниже.

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-5.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-5_dark.png?raw=true',
  }}
/>
</div>
<br></br>

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-6.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-6-dark.png?raw=true',
  }}
/>
</div>
<br></br>

<br></br>
<div class="text--center">
<ThemedImage
  alt=""
  sources={{
    light: '/img/docs/message-delivery/msg-delivery-6.png?raw=true',
    dark: '/img/docs/message-delivery/msg-delivery-6-dark.png?raw=true',
  }}
/>
</div>
<br></br>

## Заключение

Асинхронная структура блокчейна TON создает трудности с гарантией доставки сообщений. Логическое время помогает установить порядок событий и транзакций, но не гарантирует порядок доставки сообщений между несколькими смарт-контрактами из-за различий маршрутов в цепочках шардов. Несмотря на эти сложности, TON обеспечивает внутреннюю доставку сообщений, поддерживая надежность сети. Разработчики должны адаптироваться к этим нюансам, чтобы использовать весь потенциал TON для создания инновационных децентрализованных приложений.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/non-bounceable-messages.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/non-bounceable-messages.md
================================================
# Невозвращаемые сообщения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

export const Highlight = ({children, color}) => (
<span
style={{
backgroundColor: color,
borderRadius: '2px',
color: '#fff',
padding: '0.2rem',
}}>
{children} </span>
);

Почти все внутренние сообщения, отправляемые между смарт-контрактами, должны быть возвратными, т. е. иметь установленный бит "возврата". Затем, если целевой смарт-контракт не существует или если он выдает необработанное исключение при обработке этого сообщения, сообщение будет "возвращено" обратно с остатком исходного значения (за вычетом всех комиссий за передачу сообщений и газа). Тело возвращенного сообщения будет содержать 32 бита `0xffffffff`, за которыми следуют 256 бит из исходного сообщения, но с очищенным флагом "возврата»"и установленным флагом "возврата". Поэтому все смарт-контракты должны проверять флаг "возвращено" всех входящих сообщений и либо молча принимать их (немедленно завершая с нулевым кодом выхода), либо выполнять специальную обработку для определения того, какой исходящий запрос не был выполнен. Запрос, содержащийся в теле возвращенного сообщения, никогда не должен выполняться.

:::info
Запрос, содержащийся в теле возвращенного сообщения <Highlight color="#186E8A">никогда не должен выполняться</Highlight>.
:::

В некоторых случаях необходимо использовать `non-bounceable internal messages`. Например, новые аккаунты не могут быть созданы без отправки им хотя бы одного невозвращаемого внутреннего сообщения. Если это сообщение не содержит `StateInit` с кодом и данными нового смарт-контракта, не имеет смысла указывать непустое тело во внутреннем сообщении, которое не может быть возвращено.

:::tip
Рекомендуется - `не разрешать` конечному пользователю (например, кошельку) отправлять не подлежащие оплате сообщения, содержащие большие суммы (например, более пяти Toncoin), или предупреждать их, если они это делают. "Лучшей идеей" будет сначала отправить небольшую сумму, затем инициализировать новый смарт-контракт, а затем отправить большую сумму.
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/sending-messages.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/message-management/sending-messages.md
================================================
# Отправка сообщений

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Составление, анализ и отправка сообщений лежат на пересечении [схем TL-B](/v3/documentation/data-formats/tlb/tl-b-language), [фаз транзакций и TVM](/v3/documentation/tvm/tvm-overview).

Действительно, FunC предоставляет функцию [send_raw_message](/v3/documentation/smart-contracts/func/docs/stdlib#send_raw_message), которая ожидает сериализованное сообщение в качестве аргумента.

Поскольку TON — это комплексная система с широким функционалом, сообщения, которым необходимо поддерживать весь этот функционал, могут показаться довольно сложными. Однако большая часть этого функционала не используется в обычных сценариях, и сериализацию сообщений в большинстве случаев можно упростить до:

```func
  cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_slice(message_body)
  .end_cell();
```

Поэтому разработчику не стоит беспокоиться; если что-то в этом документе покажется непонятным при первом прочтении, это нормально. Просто поймите общую идею.

Иногда в документации может встречаться слово **`gram`**, в основном в примерах кода; это просто устаревшее название **toncoin**.

Давайте разберемся!

## Типы сообщений

Существует три типа сообщений:

- внешние — сообщения, отправляемые извне блокчейна в смарт-контракт внутри блокчейна. Такие сообщения должны быть явно приняты смарт-контрактами во время так называемого `credit_gas`. Если сообщение не принято, узел не должен принимать его в блок или передавать его другим узлам.
- внутренние — сообщения, отправляемые из одной сущности блокчейна в другую. Такие сообщения, в отличие от внешних, могут нести некоторое количество TON и окупать себя. Таким образом, смарт-контракты, получающие такие сообщения, могут не принять их. В этом случае газ будет вычтен из стоимости сообщения.
- логи — сообщения, отправляемые из сущности блокчейна во внешний мир. Как правило, не существует механизма отправки таких сообщений из блокчейна. Фактически, хотя все узлы в сети имеют консенсус относительно того, было ли создано сообщение или нет, нет никаких правил относительно того, как их обрабатывать. Логи могут быть напрямую отправлены в `/dev/null`, записаны на диск, сохранены в индексированной базе данных или даже отправлены не блокчейн-средствами (электронная почта/telegram/смс), все это остается на усмотрение данного узла.

## Макет сообщения

Начнем с внутреннего макета сообщения.

Схема TL-B, описывающая сообщения, которые могут быть отправлены смарт-контрактами, выглядит следующим образом:

```tlb
message$_ {X:Type} info:CommonMsgInfoRelaxed 
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = MessageRelaxed X;
```

Давайте сформулируем это словами. Сериализация любого сообщения состоит из трех полей: info (своего рода заголовок, который описывает источник, адресата и другие метаданные), init (поле, которое требуется только для инициализации сообщений) и body (полезная нагрузка сообщения).

`Maybe` и `Either` и другие типы выражений означают следующее:

- когда у нас есть поле `info:CommonMsgInfoRelaxed`, это означает, что сериализация `CommonMsgInfoRelaxed` внедряется непосредственно в ячейку сериализации.
- когда у нас есть поле `body:(Either X ^X)`, это означает, что когда мы (де)сериализуем некоторый тип `X`, мы сначала ставим один бит `either`, который равен `0`, если `X` сериализуется в ту же ячейку, или `1`, если он сериализуется в отдельную ячейку.
- когда у нас есть поле `init:(Maybe (Either StateInit ^StateInit))`, это означает, что мы сначала ставим `0` или `1` в зависимости от того, пусто это поле или нет; и если он не пустой, мы сериализуем `Either StateInit ^StateInit` (опять же, ставим один бит `either`, который равен `0`, если `StateInit` сериализуется в ту же ячейку, или `1`, если он сериализуется в отдельную ячейку).

Макет `CommonMsgInfoRelaxed` выглядит следующим образом:

```tlb
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
```

Давайте пока сосредоточимся на `int_msg_info`.
Он начинается с 1-битного префикса `0`, затем идут три 1-битных флага, а именно, отключена ли мгновенная маршрутизация гиперкуба (в настоящее время всегда true), следует ли отклонять сообщение, если во время его обработки возникли ошибки, является ли само сообщение результатом отклонения. Затем сериализуются адреса источника и назначения, за которыми следует значение сообщения и четыре целых числа, связанных с платой за пересылку сообщения и временем.

Если сообщение отправляется из смарт-контракта, некоторые из этих полей будут перезаписаны на правильные значения. В частности, валидатор перезапишет `bounced`, `src`, `ihr_fee`, `fwd_fee`, `created_lt` и `created_at`. Это означает две вещи: во-первых, другой смарт-контракт во время обработки сообщения может доверять этим полям (отправитель не может подделать исходный адрес, флаг `bounced` и т. д.); и во-вторых, во время сериализации мы можем поместить в эти поля любые допустимые значения (в любом случае эти значения будут перезаписаны).

Прямая сериализация сообщения будет выглядеть следующим образом:

```func
  var msg = begin_cell()
    .store_uint(0, 1) ;; tag
    .store_uint(1, 1) ;; ihr_disabled
    .store_uint(1, 1) ;; allow bounces
    .store_uint(0, 1) ;; not bounced itself
    .store_slice(source)
    .store_slice(destination)
    ;; serialize CurrencyCollection (see below)
    .store_coins(amount)
    .store_dict(extra_currencies)
    .store_coins(0) ;; ihr_fee
    .store_coins(fwd_value) ;; fwd_fee 
    .store_uint(cur_lt(), 64) ;; lt of transaction
    .store_uint(now(), 32) ;; unixtime of transaction
    .store_uint(0,  1) ;; no init-field flag (Maybe)
    .store_uint(0,  1) ;; inplace message body flag (Either)
    .store_slice(msg_body)
  .end_cell();
```

Однако вместо пошаговой сериализации всех полей разработчики обычно используют сокращения. Итак, давайте рассмотрим, как можно отправлять сообщения из смарт-контракта на примере из [elector-code](https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/elector-code.fc#L153).

```func
() send_message_back(addr, ans_tag, query_id, body, grams, mode) impure inline_ref {
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(ans_tag, 32)
    .store_uint(query_id, 64);
  if (body >= 0) {
    msg~store_uint(body, 32);
  }
  send_raw_message(msg.end_cell(), mode);
}
```

Сначала он помещает значение `0x18` в 6 бит, что помещается в `0b011000`. Что это?

- Первый бит - `0` — префикс 1 бит, который указывает, что это `int_msg_info`.

- Затем идут 3 бита `1`, `1` и `0`, что означает, что мгновенная маршрутизация гиперкуба отключена, сообщения могут быть отклонены, и это сообщение не является результатом самого отклонения.

- Затем должен быть адрес отправителя, однако, поскольку он в любом случае будет перезаписан с тем же эффектом, любой допустимый адрес может быть сохранен там. Самая короткая сериализация допустимого адреса — это `addr_none`, и она сериализуется как двухбитная строка `00`.

Таким образом, `.store_uint(0x18, 6)` — это оптимизированный способ сериализации тега и первых 4 полей.

Следующая строка сериализует адрес назначения.

Затем мы должны сериализовать значения. Обычно значение сообщения — это объект `CurrencyCollection` со следующей схемой:

```tlb
nanograms$_ amount:(VarUInteger 16) = Grams;

extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
                 = ExtraCurrencyCollection;

currencies$_ grams:Grams other:ExtraCurrencyCollection 
           = CurrencyCollection;
```

Эта схема означает, что в дополнение к значению TON сообщение может содержать словарь дополнительных *дополнительных валют*. Однако в настоящее время мы можем пренебречь этим и просто предположить, что значение сообщения сериализуется как "количество nanotons как переменное целое число" и "`0` - пустой бит словаря".

Действительно, в коде выборщика выше мы сериализуем количество монет через `.store_coins(toncoins)`, но затем просто помещаем строку нулей длиной, равной `1 + 4 + 4 + 64 + 32 + 1 + 1`. Что это такое?

- Первый бит обозначает пустой словарь дополнительных валют.
- Затем у нас есть два 4-битных поля. Они кодируют 0 как `VarUInteger 16`. Фактически, поскольку `ihr_fee` и `fwd_fee` будут перезаписаны, мы также можем поставить там нули.
- Затем мы помещаем ноль в поля `created_lt` и `created_at`. Эти поля также будут перезаписаны; Однако, в отличие от комиссий, эти поля имеют фиксированную длину и, таким образом, кодируются как строки, длиной 64 и 32 бита.
- *(мы уже сериализовали заголовок сообщения и перешли в init/body в этот момент)*
- Следующий нулевой бит означает, что поля `init` нет.
- Последний нулевой бит означает, что msg_body будет сериализован на месте.
- После этого кодируется тело сообщения (с произвольной компоновкой).

Таким образом, вместо индивидуальной сериализации 14 параметров мы выполняем 4 примитива сериализации.

## Полная схема

Полная схема компоновки сообщения и компоновка всех составляющих полей (а также схема ВСЕХ объектов в TON) представлены в [block.tlb](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb).

## Размер сообщения

:::info размер ячейки
Обратите внимание, что любая [ячейка](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage) может содержать до `1023` бит. Если вам нужно сохранить больше данных, вы должны разбить их на части и сохранить в ссылочных ячейках.
:::

Если, например, размер тела вашего сообщения составляет 900 бит, вы не можете сохранить его в той же ячейке, что и заголовок сообщения.
Действительно, в дополнение к полям заголовка сообщения общий размер ячейки будет превышать 1023 бит, и во время сериализации возникнет исключение `переполнение ячейки`. В этом случае вместо `0`, что означает "установить флаг в теле сообщения (либо)", должно быть `1`, а тело сообщения должно храниться в ссылочной ячейке.

С этими вещами следует обращаться осторожно, поскольку некоторые поля имеют переменные размеры.

Например, `MsgAddress` может быть представлен четырьмя конструкторами: `addr_none`, `addr_std`, `addr_extern`, `addr_var` с длиной от 2 бит (для `addr_none`) до 586 бит (для `addr_var` в самой большой форме). То же самое относится к количеству nanoton, которое сериализуется как `VarUInteger 16`. Это означает, что 4 бита указывают на длину байта целого числа, а затем указывают предыдущие байты для самого целого числа. Таким образом, 0 nanoton будут сериализованы как `0b0000` (4 бита, которые кодируют строку байтов нулевой длины, а затем ноль байтов), а 100.000.000 ТОНН (или 10000000000000000000000 nanoton) будут сериализованы как `0b10000000000101100011010001010111100010111000101000000000000000` (`0b1000` обозначает 8 байтов, а затем сами 8 байтов).

:::info размер сообщения

Дополнительные параметры конфигурации и их значения можно найти [здесь](/v3/documentation/network/configs/blockchain-configs#param-43)
:::

## Режимы сообщений

Как вы могли заметить, мы отправляем сообщения с `send_raw_message`, который, помимо потребления самого сообщения, также принимает режим. Этот режим используется для определения режима отправки сообщений, включая необходимость отдельной оплаты топлива и способ обработки ошибок. Когда виртуальная машина TON (TVM) анализирует и обрабатывает сообщения, она выполняет дифференцированную обработку в зависимости от значения режима. Легко спутать то, что значение параметра режима имеет две переменные, а именно режим и флаг. Режим и флаг имеют разные функции:

- режим: определяет базовое поведение при отправке сообщения, например, следует ли переносить баланс, следует ли ждать результатов обработки сообщения и т. д. Различные значения режима представляют разные характеристики отправки, и разные значения можно комбинировать для удовлетворения конкретных требований отправки.
- флаг: как дополнение к режиму, он используется для настройки определенного поведения сообщения, например, отдельной оплаты комиссий за перевод или игнорирования ошибок обработки. Флаг добавляется к режиму для создания окончательного режима отправки сообщения.

При использовании функции `send_raw_message` важно выбрать соответствующую комбинацию режима и флага для ваших нужд. Чтобы выяснить, какой режим лучше всего подходит для ваших нужд, взгляните на следующую таблицу:

| Режим | Описание                                                                                                               |
| :---- | :--------------------------------------------------------------------------------------------------------------------- |
| `0`   | Обычное сообщение                                                                                                      |
| `64`  | Перенести все оставшееся значение входящего сообщения в дополнение к значению, изначально указанному в новом сообщении |
| `128` | Перенести весь оставшийся баланс текущего смарт-контракта вместо значения, изначально указанного в сообщении           |

| Флаг  | Описание                                                                                                                                           |
| :---- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| `+1`  | Платите комиссию за перевод отдельно от стоимости сообщения                                                                                        |
| `+2`  | Игнорируйте некоторые ошибки, возникающие при обработке этого сообщения на этапе действия (см. примечание ниже) |
| `+16` | В случае сбоя действия - транзакция аннулируется. Если используется `+2`, это не влияет ни на что.                 |
| `+32` | Текущий аккаунт должен быть уничтожен, если его итоговый баланс равен нулю (часто используется с режимом 128)                   |

:::info флаг +2

1. Недостаточно Toncoin:
 - Недостаточно стоимости для перевода с сообщением (вся стоимость входящего сообщения была израсходована).
 - Недостаточно средств для обработки сообщения.
 - Недостаточно стоимости, прикрепленной к сообщению, для оплаты комиссий за пересылку.
 - Недостаточно дополнительной валюты для отправки с сообщением.
 - Недостаточно средств для оплаты исходящего внешнего сообщения.
2. Сообщение слишком большое (проверьте [размер сообщения](#message-size) для получения дополнительной информации).
3. Сообщение имеет слишком большую глубину Меркла.

Однако он не игнорирует ошибки в следующих сценариях:

1. Сообщение имеет недопустимый формат.
2. Режим сообщения включает как 64, так и 128 модификаций.
3. Исходящее сообщение имеет недопустимые библиотеки в StateInit.
4. Внешнее сообщение не является обычным или включает флаг +16 или +32 или оба
 :::

:::info флаг +16

В противном случае он обработает фазу `credit` **перед** фазой `storage`.

Проверьте [исходный код с проверкой флага `bounce-enable`](https://github.com/ton-blockchain/ton/blob/master/validator/impl/collator.cpp#L2810)
:::

:::warning

1. **Флаг +16** - не использовать во внешних сообщениях (например, на кошельках), так как нет отправителя, который мог бы получить отклоненное сообщение.
2. **Флаг +2** - важно во внешних сообщениях (например, на кошельках).
 :::

### Пример с вариантами использования

Давайте рассмотрим пример, чтобы сделать его более понятным. Представим ситуацию, когда у нас на балансе смарт-контракта 100 Toncoin, и мы получаем внутреннее сообщение с 50 Toncoin и отправляем сообщение с 20 Toncoin, общая комиссия составляет 3 Toncoin.

`ВАЖНО`: Результат случаев ошибки описывается, когда произошла ошибка.

| Кейс                                                                                                                                                                                                                                                                                                                         | Режим и флаги                  | Код                          | Результат                                                                                                  |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------- | :--------------------------- | :--------------------------------------------------------------------------------------------------------- |
| Отправить обычное сообщение                                                                                                                                                                                                                                                                                                  | `mode` = 0, no `flag`          | `send_raw_message(msg, 0)`   | `balance` - 100 + 50 - 20 = 130, `send` - 20 - 3 = 17                                                      |
| Отправить обычное сообщение, если при обработке действия произошла ошибка, не откатывать транзакцию и игнорировать ее                                                                                                                                                                                                        | `mode` = 0, `flag` = 2         | `send_raw_message(msg, 2)`   | `balance` - 100 + 50, `send` - 0                                                                           |
| Отправить обычное сообщение, если при обработке действия произошла ошибка - откатить сообщение в дополнение к откату транзакции                                                                                                                                                                                              | `mode` = 0, `flag` = 16        | `send_raw_message(msg, 16)`  | `balance` - 100 + 50 = 167 + 17 (отклонено), `send` - 20 - 3 = `bounce` message with 17 |
| Отправить обычное сообщение и оплатить комиссию за перевод отдельно                                                                                                                                                                                                                                                          | `mode` = 0, `flag` = 1         | `send_raw_message(msg, 1)`   | `balance` - 100 + 50 - 20 - 3 = 127, `send` - 20                                                           |
| Отправить обычное сообщение и оплатить комиссию за перевод отдельно, если при обработке действия произошла ошибка - откатить сообщение в дополнение к откату транзакции                                                                                                                                                      | `mode` = 0, `flags` = 1 + 16   | `send_raw_message(msg, 17)`  | `balance` - 100 + 50 - 20 - 3 = 127 + `20 (отклонено)`, `send` - 20 = `bounce` сообщение с 20              |
| Перенести всю оставшуюся стоимость входящего сообщения в дополнение к изначально указанной стоимости в новом сообщении                                                                                                                                                                                                       | `mode` = 64, `flag` = 0        | `send_raw_message(msg, 64)`  | `balance` - 100 - 20 = 80, `send` - 20 + 50 - 3 = 67                                                       |
| Перенести всю оставшуюся стоимость входящего сообщения в дополнение к изначально указанной стоимости в новом сообщении и оплатить комиссию за перевод отдельно                                                                                                                                                               | `mode` = 64, `flag` = 1        | `send_raw_message(msg, 65)`  | `balance` - 100 - 20 - 3 = 77, `send` - 20 + 50 = 70                                                       |
| Перенести всю оставшуюся стоимость входящего сообщения в дополнение к стоимости, изначально указанной в новом сообщении, и отдельно оплатить комиссию за перевод, если произошла ошибка при обработке действия - отклонить сообщение в дополнение к откату транзакции                                                        | `mode` = 64, `flags` = 1 + 16  | `send_raw_message(msg, 81)`  | `balance` - 100 - 20 - 3 = 77 + `70 (отклонено)`, `send` - 20 + 50 = `bounce` сообщение с 70               |
| Отправить все полученные токены вместе с балансом контракта                                                                                                                                                                                                                                                                  | `mode` = 128, `flag` = 0       | `send_raw_message(msg, 128)` | `balance` - 0, `send` - 100 + 50 - 3 = 147                                                                 |
| Отправить все полученные токены вместе с балансом контракта, если произошла ошибка при обработке действия - отклонить сообщение в дополнение к откату транзакции                                                                                                                                                             | `mode` = 128, `flag` = 16      | `send_raw_message(msg, 144)` | `balance` - 0 + `147 (отклонено)`, `send` - 100 + 50 - 3 = `bounce` сообщение с 147                        |
| Отправить все полученные токены вместе с балансом контракта и уничтожить смарт-контракт                                                                                                                                                                                                                                      | `mode` = 128, `flag` = 32      | `send_raw_message(msg, 160)` | `balance` - 0, `send` - 100 + 50 - 3 = 147                                                                 |
| Отправить все полученные токены вместе с балансом контракта и уничтожить смарт-контракт, если произошла ошибка при обработке действия - отклонить сообщение в дополнение к откату транзакции. `ВАЖНО: Избегайте такого поведения, поскольку возврат средств будет осуществляться на уже удаленный контракт.` | `mode` = 128, `flag` = 32 + 16 | `send_raw_message(msg, 176)` | `balance` - 0 + `147 (отклонено)`, `send` - 100 + 50 - 3 = `bounce` сообщение с 147                        |




================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/overview.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/overview.mdx
================================================
import Button from '@site/src/components/button'

# Введение

Создание, разработка и деплой смарт-контрактов на блокчейне TON реализуется с помощью [виртуальной машины TON (TVM)](/v3/documentation/smart-contracts/overview#ton-virtual-machine-tvm) и одного из следующих языков программирования:

* [Tact](/v3/documentation/smart-contracts/overview#-tact)
* [FunC](/v3/documentation/smart-contracts/overview#-func)

## Быстрый старт: ваш первый смарт-контракт

Давайте напишем и задеплоим ваш первый смарт-контракт с помощью фреймворка _Blueprint_.

Blueprint — это среда разработки для написания, тестирования и развертывания смарт-контрактов.
Чтобы создать новый демо проект, воспользуйтесь следующей командой:

```bash
npm create ton@latest
```

<Button href="/v3/documentation/smart-contracts/getting-started/javascript" colorType="primary" sizeType={'sm'}>

Подробнее

</Button>

<Button href="https://stepik.org/course/176754/" colorType={'secondary'} sizeType={'sm'}>

Курс по блокчейну TON

</Button>

## Начало работы

### Увлекательные и простые уроки

Начните свой путь с нашими руководствами для начинающих:

- [TON Hello World: пошаговое руководство по написанию вашего первого смарт-контракта](https://helloworld.tonstudio.io/02-contract/)
- Обучающие материалы TON
  - [🚩 Задача 1: Простое развертывание NFT](https://github.com/romanovichim/TONQuest1)
  - [🚩 Задача 2: Контракт чат-бота](https://github.com/romanovichim/TONQuest2)
  - [🚩 Задача 3: Торговый автомат жетонов](https://github.com/romanovichim/TONQuest3)
  - [🚩 Задача 4: Лотерея/Розыгрыш](https://github.com/romanovichim/TONQuest4)
  - [🚩 Задача 5: Создайте пользовательский интерфейс для взаимодействия с контрактом за 5 минут](https://github.com/romanovichim/TONQuest5)
  - [🚩 Задача 6: Анализ продаж NFT на маркетплейсе Getgems](https://github.com/romanovichim/TONQuest6)
- [Плейлист по TON разработке](https://www.youtube.com/playlist?list=PLOIvUFGfwP93tZI_WnaLyJsZlskU4ao92)

### Курс TON

:::tip
Перед началом курса, убедитесь, что вы хорошо понимаете основы технологии блокчейна. Если у вас есть пробелы в знаниях, мы настоятельно рекомендуем пройти курс [**Основы блокчейна с TON**](https://stepik.org/course/201294/promo) ([версия RU](https://stepik.org/course/202221/), [версия CHN](https://stepik.org/course/200976/)).
:::

Мы с гордостью представляем **Курс по блокчейну TON** – всеобъемлющее руководство по блокчейну TON. Курс ориентирован на разработчиков, которые хотят научиться создавать смарт-контракты и децентрализованные приложения на блокчейне TON.

Он состоит из **девяти модулей** и охватывает основы блокчейна TON, жизненный цикл разработки смарт-контрактов, язык программирования FunC и виртуальную машину TON (TVM).

<Button href="https://stepik.org/course/176754/promo"
        colorType={'primary'} sizeType={'sm'}>

Курс по блокчейну TON

</Button>

<Button href="https://stepik.org/course/201638/promo"
        colorType={'secondary'} sizeType={'sm'}>

CHN версия

</Button>

<Button href="https://stepik.org/course/201855/promo"
        colorType={'secondary'} sizeType={'sm'}>

RU версия

</Button>

### Подробные руководства

Для тех, кто предпочитает детали и нюансы, посетите:

- [Как работать со смарт-контрактами кошелька](/v3/guidelines/smart-contracts/howto/wallet)

## Примеры смарт-контрактов

Изучите готовые примеры смарт-контрактов и инструменты, предоставляемые сообществом TON.

:::info небольшой совет
Мы советуем сосредоточиться на смарт-контрактах, написанных на FunC (.fc). Зачастую это более удачный выбор, нежели чем сразу начинать работу на низкоуровневом языке Fift (.fif).
:::

Стандартными примерами смарт-контрактов на TON являются стандартные кошельки, выборщики (которые управляют валидацией на TON), а также мультиподписные кошельки. Ниже представлены общедоступные примеры реализации, которые могут служить хорошими ориентирами при обучении.

<Button href="/v3/documentation/smart-contracts/contracts-specs/examples" colorType={'primary'} sizeType={'sm'}>

Общедоступные примеры

</Button>

## Лучшие практики смарт-контрактов

TON предлагает по-настоящему безграничные возможности. Узнайте, как максимально использовать их, придерживаясь следующих рекомендаций:

- [Руководства по смарт-контрактам](/v3/guidelines/smart-contracts/guidelines)

## Виртуальная машина TON (TVM)

Ознакомьтесь с движком, который управляет вашими смарт-контрактами.

- [Обзор TVM](/v3/documentation/tvm/tvm-overview)

## Языки программирования

### 📘 FunC

Специальный язык для смарт-контрактов TON.

<Button href="/v3/documentation/smart-contracts/func/overview" colorType={'primary'} sizeType={'sm'}>

Обзор FunC

</Button>

### 📒 Tact

Tact — это новый язык программирования для блокчейна TON, ориентированный на эффективность и простоту разработки. Он хорошо подходит для сложных смарт-контрактов, быстрого онбординга и создания прототипов.

Создано [TON Studio](https://tonstudio.io), развивается совместно с сообществом.

<Button href="https://tact-lang.org/"
        colorType={'primary'} sizeType={'sm'}>

Официальный сайт

</Button>

<Button href="https://docs.tact-lang.org/"
        colorType={'secondary'} sizeType={'sm'}>

Документация Tact

</Button>

<Button href="https://tact-by-example.org/"
        colorType="secondary" sizeType={'sm'}>

Примеры Tact

</Button>

### 📗 Tolk

Новый язык для написания смарт-контрактов в TON. Думайте о Tolk как о «**FunC следующего поколения**»

:::caution
В стадии активной разработки.
:::

<Button href="/v3/documentation/smart-contracts/tolk/overview" colorType={'primary'} sizeType={'sm'}>

Обзор Tolk

</Button>

### 📕 Fift (продвинутый)

:::caution продвинутый уровень
Только для смелых!
:::

<Button href="/v3/documentation/smart-contracts/fift/overview" colorType={'primary'} sizeType={'sm'}>

Обзор Fift

</Button>

## Инструменты сообщества

- [MyLocalTON](/v3/guidelines/nodes/running-nodes/running-a-local-ton) — MyLocalTON используется для запуска частного блокчейна TON в вашей локальной среде.
- [tonwhales.com/tools/boc](https://tonwhales.com/tools/boc) — BOC-парсер
- [tonwhales.com/tools/introspection-id](https://tonwhales.com/tools/introspection-id) — генератор crc32
- [@orbs-network/ton-access](https://www.orbs.com/ton-access/) — децентрализованный шлюз API

## Внеклассное чтение

Отточите свои навыки с помощью этих образовательных ресурсов от сообщества TON.

- [Руководства по смарт-контрактам](/v3/guidelines/smart-contracts/guidelines)
- [Путь обучения TON FunC](https://blog.ton.org/func-journey) ([версия RU](https://github.com/romanovichim/TonFunClessons_ru))
- [Обучающие видео на YouTube](https://www.youtube.com/@TONDevStudy) [[RU версия]](https://www.youtube.com/@WikiMar)

## Дополнительные ресурсы

- [Что такое блокчейн? Что такое смарт-контракт? Что такое газ?](https://blog.ton.org/what-is-blockchain)
- [Понимание комиссий за транзакции](/v3/guidelines/smart-contracts/fee-calculation)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm.mdx
================================================
# Парадигма бесконечного шардинга

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Понимание разделенного слияния в блокчейне TON

Блокчейн TON (The Open Network) представляет инновационные концепции масштабируемости и эффективности блокчейна. Одной из таких концепций является функциональность разделения и объединения, которая является неотъемлемой частью его архитектуры блокчейна. В этой короткой статье рассматриваются ключевые аспекты разделения и объединения в блокчейне TON с упором на его роль в парадигме бесконечного шардинга (Infinite Sharding Paradigm - ISP).

#### Парадигма бесконечного шардинга (ISP) и ее применение

ISP лежит в основе дизайна блокчейна TON, рассматривая каждый аккаунт как часть своего отдельного "аккаунтчейна". Затем эти аккаунтчейны объединяются в блоки шардчейна для эффективности. Состояние шардчейна включает в себя состояния всех его аккаунтчейнов. Таким образом, блок шардчейна по сути представляет собой набор виртуальных блоков аккаунтов, назначенных ему.

- **ShardState**: приближенно как Hashmap(n, AccountState), где n — это длина бит account_id.
- **ShardBlock**: приближенно как Hashmap(n, AccountBlock).

Каждый шардчейн или, точнее, каждый блок шардчейна идентифицируется комбинацией `workchain_id` и двоичного префикса `s` из account_id.

## Алгоритм принятия решения о разделении или слиянии

Валидаторы решают, разделять или сливать шарды, следующим образом:

1. Для каждого блока вычисляются размер блока, расход газа и изменение lt.
2. Используя эти значения, блоки можно считать перегруженными или недогруженными.
3. Каждый шард хранит историю недогрузки и перегрузки. Если достаточное количество недавних блоков были недогружены или перегружены, устанавливается флаг `want_merge` или `want_split`.
4. Валидаторы объединяют или разделяют шарды, используя эти флаги.

### 1. Оценка текущего состояния блока

Каждый блок имеет следующие параметры. Они используются для определения перегрузки и недогрузки.

1. _Оценка размера блока_ - не фактический размер блока, а оценка, рассчитанная во время сопоставления.
2. _Потребление газа_ - общее количество газа, потребленного во всех транзакциях (за исключением специальных транзакций ticktock и mint/recover).
3. _Lt delta_ - разница между началом и концом lt блока.

### 2. Ограничения блоков и классификация

Ограничения блоков загружаются из [параметров конфигурации 22 и 23](/v3/documentation/network/configs/blockchain-configs#param-22-and-23).
Каждый из трех параметров имеет три ограничения: недогрузка, мягкое и жесткое:

1. _Размер блока_: `128/256/512 KiB`.
2. _Потребление газа_: `2M/10M/20M` в бейсчейне, `200K/1M/2.5M` в мастерчейне.
3. _Lt delta_: `1000/5000/10000`.
   Также есть средний предел, который равен `(soft + hard) / 2`.

Мы классифицируем три параметра (размер, газ и lt delta) по категориям:

- `0` - не достигнут предел допустимой нагрузки.
- `1` - превышен предел допустимой нагрузки.
- `2` - превышен мягкий предел.
- `3` - превышен средний предел.
- `4` - превышен жесткий предел.

Классификация блоков - максимальная ("Классификация по размеру", "Классификация по газу", "Классификация по lt delta\\`). Например: если классификация по размеру равна 2, классификация по газу равна 3, классификация по lt delta равна 1, то итоговая классификация блока равна 3.

- Если классификация блока равна 0 (недостаточная нагрузка), блок склонен к объединению со своим родственным блоком.
- Когда классификация блока 2 (достигнут мягкий предел), коллатор прекращает обработку внутренних сообщений. Блок склонен к разделению.
- Когда классификация блока 3 (достигнут средний предел), коллатор прекращает обработку внешних сообщений.

### 3. Определение перегрузки или недогрузки

После классификации блока коллатор проверяет условия перегрузки и недогрузки.
Также учитывается размер очереди исходящих сообщений и статус обработки очереди отправки.

- Если класс блока ≥ `2` (мягкий) и размер очереди сообщений ≤ `SPLIT_MAX_QUEUE_SIZE = 100000`, то блок перегружен.
- Если достигнут предел для общего количества обработанных сообщений из очереди отправки и размер очереди сообщений ≤ `SPLIT_MAX_QUEUE_SIZE = 100000`, то блок перегружен.
- Если класс блока равен `0` (недогрузка) и размер очереди сообщений ≤ `MERGE_MAX_QUEUE_SIZE = 2047`, то блок недогружен.
- Если размер очереди сообщений ≥ `FORCE_SPLIT_QUEUE_SIZE = 4096` и ≤ `SPLIT_MAX_QUEUE_SIZE = 100000`, то блок перегружен.

### 4. Решение о разделении или слиянии

Каждый блок хранит историю недогрузки и перегрузки — это 64-битная маска статуса недогрузки/перегрузки последних 64 блоков.
Она используется для принятия решения о разделении или слиянии.

История недогрузки и перегрузки имеет вес, который рассчитывается следующим образом:
`one_bits(mask & 0xffff) * 3 + one_bits(mask & 0xffff0000) * 2 + one_bits(mask & 0xffff00000000) - (3 + 2 + 1) * 16 * 2 / 3`
(здесь `one_bits` - это количество `1`-битов в маске, а младшие биты соответствуют самым последним блокам).

Когда история недогрузки или перегрузки имеет неотрицательный вес, устанавливается флаг `want_merge` или `want_split`.

### 5. Окончательное решение

Валидаторы решают разделить или объединить шарды, используя флаги `want_split` и `want_merge` и [параметры конфигурации воркчейна](/v3/documentation/network/configs/blockchain-configs#param-12).

- Если шард имеет глубину < `min_split`, то он разделится.
- Если шард имеет глубину > `max_split`, то он объединится.
- Шарды с глубиной `min_split` не могут объединяться, шарды с глубиной `max_split` не могут разделяться.
- Если блок имеет флаг `want_split`, шард разделится.
- Если у блока и его дочернего элемента есть флаг `want_merge`, шарды объединятся.

Шарды разделяются и объединяются через `split_merge_delay = 100` секунд после принятия решения.

## Сообщения и мгновенная маршрутизация гиперкуба (мгновенная маршрутизация гиперкуба)

В парадигме бесконечного шардинга каждый аккаунт (или смарт-контракт) рассматривается так, как если бы он сам находился в отдельном шардчейне.
Взаимодействие между аккаунтами происходит исключительно посредством отправки сообщений, что является частью модели субъекта, где аккаунты выступают в качестве субъектов. Эффективная система обмена сообщениями между шардчейнами имеет решающее значение для работы блокчейна TON.
Особенностью TON является мгновенная маршрутизация гиперкуба, которая обеспечивает быструю доставку и обработку сообщений между шардчейнами, гарантируя, что сообщения, созданные в блоке одного шардчейна, обрабатываются в следующем блоке целевого шардчейна, независимо от их количества в системе.

## Пример шардинга

![](/img/docs/blockchain-fundamentals/shardchains.jpg)

На представленной графической схеме:

- Шарды воркчейна разделены по времени и обозначены пунктирной линией.
- Блоки 222, 223 и 224 относятся к блоку мастерчейна с seqno=102. Здесь 222 находится в одном шарде, а 223 и 224 — в другом.
- Если происходит событие разделения или слияния, затронутые шарды приостанавливаются до следующего блока мастерчейна.

Подводя итог, можно сказать, что разделение и слияние в блокчейне TON — это сложный, но эффективный механизм, который повышает масштабируемость и взаимодействие в сети блокчейнов. Он иллюстрирует подход TON к решению общих проблем блокчейнов, подчеркивая эффективность и глобальную согласованность.

## Подробности шардинга

#### Разделенные и неразделенные части шардчейна

Блок и состояние шардчейна делятся на две части:

1. **Разделенная часть**: соблюдает форму провайдера (ISP), содержащую специфические данные аккаунтов.
2. **Неразделенная часть**: включает данные, относящиеся к взаимодействию блока с другими блоками и внешним миром.

#### Взаимодействие с другими блоками

Неразделенные части имеют решающее значение для обеспечения глобальной согласованности, сведенной к внутренним и внешним локальным условиям согласованности. Они важны для:

- Пересылки сообщений между шардчейнами.
- Транзакций с участием нескольких шардчейнов.
- Гарантий доставки и проверки начального состояния блока по сравнению с его предшественником.

#### Входящие и исходящие сообщения

Ключевые компоненты неразделенной части блока шардчейна включают:

- **InMsgDescr**: Описания всех сообщений, импортированных в блок (т. е. либо обработанных транзакцией, включенной в блок, либо перенаправленных в выходную очередь, в случае транзитного сообщения, перемещающегося по пути, продиктованному `маршрутизацией гиперкуба`).
- **OutMsgDescr**: Описания всех сообщений, экспортированных или сгенерированных блоком (т. е. либо сообщения, сгенерированные транзакцией, включенной в блок, либо транзитные сообщения с пунктом назначения, не принадлежащим текущему шардчейну, перенаправленные из `InMsgDescr`).

#### Заголовок блока и подписи валидатора

Заголовок блока, еще один неразделенный компонент, содержит важную информацию, такую ​​как `workchain_id`, двоичный префикс `account_ids`, порядковый номер блока (определяемый как наименьшее неотрицательное целое число, большее порядковых номеров его предшественников), логическое время и генерацию unixtime. Он также содержит хэш непосредственного предшественника блока (или двух его непосредственных предшественников в случае предшествующего события слияния шардчейна), хэши его начального и конечного состояний (т. е. состояния шардчейна непосредственно перед и сразу после обработки текущего блока) и хэш самого последнего блока мастерчейна, известного на момент генерации блока шардчейна. Подписи валидатора добавляются к неподписанному блоку, образуя подписанный блок.

#### Исходящая очередь сообщений

`OutMsgQueue` в состоянии щардчейна является критической неразделенной частью. Она содержит недоставленные сообщения, включенные в `OutMsgDescr`, либо последним блоком шардчейна, ведущим к этому состоянию, либо одним из его предшественников.
Изначально каждое исходящее сообщение включается в `OutMsgQueue` и хранится там, пока они не будут обработаны или доставлены по назначению.

#### Механика разделения и слияния шардов

В контексте динамического шардинга конфигурации шардов могут меняться из-за событий разделения и слияния. Эти события синхронизируются с блоком мастерчейна. Например, если происходит разделение или слияние, затронутые шарды ждут следующего блока мастерчейна, прежде чем продолжить.

## См. также

- [Блочная компоновка](/v3/documentation/data-formats/tlb/block-layout)
- [Технические документы](/v3/documentation/whitepapers/overview)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/shards/shards-intro.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/shards/shards-intro.mdx
================================================
# Шарды

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Шардинг — это зрелая концепция, зародившаяся в [проектировании баз данных](https://en.wikipedia.org/wiki/Shard_(database_architecture)). Она предполагает разделение и распределение одного логического набора данных по нескольким базам данных, которые не имеют ничего общего и могут быть развернуты на нескольких серверах.
Проще говоря, шардинг обеспечивает горизонтальную масштабируемость — разделение данных на отдельные, независимые части, которые можно обрабатывать параллельно. Это ключевая концепция перехода мира от данных к [большим данным](https://en.wikipedia.org/wiki/Big_data).
Когда наборы данных становятся слишком большими для обработки традиционными средствами, нет другого способа масштабирования, кроме как разбить их на более мелкие части.

Механизм шардинга в блокчейне TON позволяет обрабатывать большое количество транзакций.
Блокчейн TON состоит из одного мастерчейна и до 2<sup>32</sup> воркчейнов. Каждый воркчейн — это отдельная цепочка со своими правилами. Каждый воркчейн может быть дополнительно разделен на 2<sup>60</sup> шардчейнов или субшардов, содержащих часть состояния воркчейна. В настоящее время в TON работает только один воркчейн — Бейсчейн.
Основная идея шардирования в TON заключается в том, что когда аккаунт A отправляет сообщение аккаунту B, а аккаунт C отправляет сообщение аккаунту D, обе эти операции могут выполняться асинхронно.

По умолчанию в бейсчейне (`workchain=0`) есть только один шард с номером шарда `0x800000000000000000` (или `10000000000000000000000000000000000000000000000000000000000000000000000` в двоичном представлении). Мастерчейн (`workchain=-1`) всегда имеет один и только один шард.

## Мастерчейн

Мастерчейн — это основная цепочка, которая хранит конфигурацию сети и конечное состояние всех воркчейнов. Вы можете понять это так, что мастерчейн является основным каталогом, единым источником информации для всех шардов экосистемы.

Он несет основную информацию о протоколе, включая текущие настройки, список активных валидаторов и их доли, активные воркчейны и связанные шардчейны. Самое главное, он ведет учет последних хэшей блоков для всех воркчейнов и шардчейнов, обеспечивая консенсус всей сети.

## Воркчейн

Мастерчейн разделяется на отдельные цепочки, называемые воркчейнами. Воркчейны — это настраиваемые блокчейны, адаптированные под определенные транзакции или варианты использования, работающие параллельно в сети TON.

## Уникальность

При проектировании блокчейна TON были приняты два ключевых решения, которые делают его уникальным среди других блокчейнов, использующих шардинг.

Во-первых, TON обеспечивает динамическую сегментацию блокчейна в зависимости от нагрузки на сеть. Когда количество транзакций увеличивается до критического уровня, блокчейн автоматически разделяется на два отдельных шарда.
Если нагрузка на одну из частей продолжает расти, она снова разделяется пополам, и этот процесс продолжается по мере необходимости. Если количество транзакций уменьшается, шарды могут снова объединяться.
Эта адаптивная модель позволяет создавать столько шардов, сколько необходимо в данный момент времени.

Второе решение, отличающее TON, — это принцип нефиксированного количества шардов. В отличие от систем типа Ethereum 2.0, которые поддерживают фиксированное количество шардов (64 шарда), TON позволяет добавлять все больше и больше шардов в зависимости от потребностей сети, с теоретическим пределом в 2<sup>60</sup> шардов на воркчейн.
Это число настолько велико, что практически безгранично, и позволяет предоставить более 100 миллионов шардов каждому человеку на Земле и при этом иметь запас. Такой подход — единственный способ удовлетворить динамические требования к масштабированию, которые трудно предсказать заранее.

![](/img/docs/blockchain-fundamentals/scheme.png)

## Разделение

В блокчейне TON последовательность транзакций одного аккаунта (например, `Tx1 -> Tx2 -> Tx3 -> ...`) называется цепочкой транзакций аккаунта или <b>AccountChain</b>. Это подчеркивает, что речь идет о последовательности транзакций, связанных с одним аккаунтом.
Несколько таких <b>AccountChains</b>, объединенных в один шард, образуют <b>ShardChain</b>. <b>ShardChain</b> (далее именуемый шардом) отвечает за хранение и обработку всех транзакций в шарде, где каждая цепочка транзакций определяется определенной группой аккаунтом.

Эти группы аккаунтов обозначаются общим двоичным префиксом, который служит критерием для их кластеризации в одном шарде.
Этот префикс появляется в идентификаторе шарда, который представлен 64-битным целым числом и имеет следующую структуру: `<binary prefix>100000...`. Например, шард с идентификатором `1011100000...` содержит все аккаунты, начинающиеся с префикса `1011`.

Когда количество транзакций в каком-либо шарде растет, этот шард разделяется на два шарда. Новые шарды получают следующие идентификаторы: `<parent prefix>01000...` и `<parent prefix>11000...` и становятся ответственными за аккаунты, начинающиеся с `<parent prefix>0` и `<parent prefix>1` соответственно. Последовательности блоков в шардах идут непрерывно, начиная с последней родительской последовательности плюс 1. После разделения шарды идут независимо и могут иметь разные последовательности.

Простой пример:
![](/img/docs/blockchain-fundamentals/shardchains-split.jpg)

Блок мастерчейна содержит информацию о шардах в своем заголовке. После того, как блок шарда появляется в заголовке мастерчейна, его можно считать завершенным (его нельзя откатить).

Реальный пример:

- Блок мастерчейна `seqno=34607821` имеет 2 шарда: `(0,40000000000000000,40485798)` и `(0,c0000000000000000,40485843)` (https://toncenter.com/api/v2/shards?seqno=34607821).
- Шард `shard=4000000000000000` был разделен на `shard=2000000000000000` и ​​`shard=60000000000000000`, а блок мастерчейна `seqno=34607822` получает 3 шарда: `(0,c000000000000000,40485844)`, `(0,2000000000000000,40485799)` и `(0,600000000000000,40485799)`. Обратите внимание, что оба новых шарда имеют одинаковые последовательности, но разные идентификаторы шардов (https://toncenter.com/api/v2/shards?seqno=34607822).
- Новые шарды идут независимо и после 100 блоков мастерчейна (в блоке мастерчейна `seqno=34607921`) один шард имеет последний блок `(0,2000000000000000,40485901)`, а другой `(0,6000000000000000,40485897)` (https://toncenter.com/api/v2/shards?seqno=34607921).

## Объединение

Если нагрузка на шарды снижается, они могут объединиться обратно:

- Два шарда могут объединиться, если у них есть общий родитель, и, следовательно, их идентификаторы шардов равны `<parent prefix>010...` и `<parent prefix110...`. Объединенный шард будет иметь идентификатор шарда `<parent prefix>10...` (например, `10010...` + `10110...` = `1010...`). Первый блок объединенного шарда будет иметь `seqno=max(seqno1, seqno2) + 1`.

Простой пример:
![](/img/docs/blockchain-fundamentals/shardchains-merge.jpg)

Реальный пример:

- В блоке мастерчейна `seqno=34626306` два из пяти шардов с последними блоками `(0,a0000000000000000,40492030)` и `(0,e0000000000000000,40492216)` объединены в один с блоком `(0,c0000000000000000,40492217)` (https://toncenter.com/api/v2/shards?seqno=34626306 и https://toncenter.com/api/v2/shards?seqno=34626307).

## См. также

- [Парадигма бесконечного шардинга](/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm)
- [Технические документы](/v3/documentation/whitepapers/overview)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/changelog.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/changelog.md
================================================
# История Tolk

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Когда будут выпущены новые версии Tolk, они будут упомянуты здесь.

## v0.7

1. Под капотом: рефакторинг внутренних компонентов компилятора; ядро ​​семантического анализа на уровне AST
2. Под капотом: переписываем систему типов с Хиндли-Милнера на статическую типизацию

## v0.7

1. Под капотом: рефакторинг внутренних компонентов компилятора; ядро ​​семантического анализа на уровне AST
2. Под капотом: переписываем систему типов с Хиндли-Милнера на статическую типизацию
3. Понятные и читаемые сообщения об ошибках при несоответствии типов
4. Универсальные функции `fun f<T>(...)` и их экземпляры, такие как `f<int>(...)`
5. Тип `bool`; приведение типа через `value as T`

## v0.6

Первый публичный релиз. Вот некоторые заметки о его происхождении:

## Как появился Tolk

В общем, вместо того, чтобы объединить v0.5.0 и продолжить разработку FunC, мы решили **разветвить** его.
Чтобы оставить FunC нетронутым, как есть. Как всегда. И разработать новый язык, движимый свежим и новым именем.

Несколько месяцев я работал над Tolk в частном порядке. Я реализовал огромный список изменений.
И дело не только в синтаксисе. Например, у Tolk есть внутреннее представление AST, полностью отсутствующее в FunC.

На TON Gateway 1-2 ноября в Дубае я выступил с речью, в которой представил Tolk публике, и мы опубликовали ее в тот же день. Видео доступно [на YouTube](https://www.youtube.com/watch?v=Frq-HUYGdbI).

Вот самый первый pull request: ["Язык Tolk: следующее поколение FunC"](https://github.com/ton-blockchain/ton/pull/1345).

Первая версия языка Tolk — v0.6, метафора FunC v0.5, которая упустила шанс появиться.

Первая версия языка Tolk — v0.6, метафора FunC v0.5, которая упустила шанс появиться.

## Значение названия "Tolk"

В английском языке это созвучно с *talk*. Потому что, вообще, зачем нам нужен язык? Он нам нужен, чтобы *разговаривать* с компьютерами.

Во всех славянских языках корень *толк* и фраза *иметь толк* означают "иметь смысл", "иметь глубокие внутренние чувства".

Но на самом деле **TOLK** — это аббревиатура.
Вы знаете, что TON — это **The Open Network**.
По аналогии, TOLK — это **The Open Language K**.

Что такое К, спросите вы? Наверное, "кот" — ник Николая Дурова? Или Коля? Котенок? Ядро (Kernel)? Кит? Знание (Knowledge)?
Правильный ответ — ничего из этого. Эта буква ничего не значит. Она открытая.
*The Open Letter K*

Что такое К, спросите вы? Наверное, "кот" — ник Николая Дурова? Или Коля? Котенок? Ядро (Kernel)? Кит? Знание (Knowledge)?
Правильный ответ — ничего из этого. Эта буква ничего не значит. Она открытая.
*The Open Letter K*



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/overview.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/overview.mdx
================================================
---
title: Общие сведения
---

import Button from '@site/src/components/button'

# Язык Tolk: общие сведения

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

**Tolk** — это новый язык для написания смарт-контрактов в TON. Представьте себе Tolk как «**следующее поколение FunC**».
Компилятор Tolk — это буквально ответвление компилятора FunC, представляющее знакомый синтаксис, похожий на TypeScript, но оставляющее все низкоуровневые оптимизации нетронутыми.

```tolk
import "storage.tolk"

fun loadData() {
    ctxCounter = getContractData().beginParse().loadUint(32);
}

fun onInternalMessage(msgValue: int, msgFull: cell, msgBody: slice) {
    var cs = msgFull.beginParse();
    var flags = cs.loadMessageFlags();
    if (isMessageBounced(flags)) {
        return;
    }
    ...
}

get currentCounter(): int {
    loadData(); // fills global variables
    return ctxCounter;
}
```

<details>
  <summary><b>См. ту же логику, реализованную с помощью FunC</b></summary>

```func
#include "storage.fc";

() load_data() impure {
  slice cs = get_data().begin_parse();
  ctx_counter = cs~load_uint(32);
}

() recv_internal(int msg_value, cell msg_full, slice msg_body) impure {
  slice cs = msg_full.begin_parse();
  int flags = cs.load_uint(4);
  if (flags & 1) {
    return ();
  }
  ...
}

int currentCounter() method_id {
  load_data(); ;; fills global variables
  return ctx_counter;
}
```

</details>

<Button href="https://github.com/ton-blockchain/convert-func-to-tolk" colorType={'primary'} sizeType={'sm'}>
Попробуйте конвертер FunC → Tolk
</Button>
<Button href="/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short" colorType={'secondary'} sizeType={'sm'}>
Прочитайте "Различия Tolk и FunC"
</Button>
<div style={{height: '2em'}}></div>

## Мотивация, стоящая за Tolk

FunC потрясающий.
Он действительно низкоуровневый и побуждает программиста думать о внутренностях компилятора.
Он дает полный контроль над ассемблером TVM, позволяя программисту сделать свой контракт максимально эффективным.
Если вы привыкнете к нему, он вам понравится.

Но есть проблема.
FunC — это "функциональный C", и он для ниндзя.
Если вы увлекаетесь Lisp и Haskell, вы будете счастливы.
Но если вы разработчик JavaScript / Go / Kotlin, его синтаксис для вас необычен, что приводит к случайным ошибкам.
Борьба с синтаксисом может снизить вашу мотивацию к изучению TON.

Представьте, что если бы был язык, тоже умный, тоже низкоуровневый, но не функциональный и не похожий на C?
Оставив всю красоту и сложность внутри, что если бы он был больше похож на популярные языки на первый взгляд?

Вот что такое Tolk.

## Переход с FunC на Tolk

Если вы знаете FunC и хотите попробовать новый синтаксис, вот ваш путь:

1. Прочитайте [Сравнение Tolk и FunC: коротко](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short).
2. С помощью blueprint создайте новый контракт Tolk (например, счетчик) и поэкспериментируйте. Помните, что почти все функции stdlib переименованы в ~~подробные~~ понятные имена. Вот [сопоставление](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).
3. Попробуйте [конвертер](https://github.com/ton-blockchain/convert-func-to-tolk) для ваших существующих контрактов или один из [контрактов FunC](/v3/documentation/smart-contracts/contracts-specs/examples). Помните, что контракты, написанные на Tolk с нуля, определенно будут выглядеть лучше, чем автоматически преобразованные. Например, использование логических операторов вместо побитовых значительно повышает читабельность кода.

## Как попробовать Tolk, если вы не знаете FunC

:::tip В настоящее время эта документация предполагает, что вы знаете FunC
В документации описываются различия "Tolk и FunC".
Позже она будет адаптирована для новичков. Более того, FunC в конечном итоге станет устаревшим, и все фрагменты кода во всей документации будут переписаны на Tolk.
:::

Если вы новичок в TON, ваш путь таков:

1. Покопайтесь в [этой документации](/v3/documentation/smart-contracts/overview), чтобы получить базовые знания о разработке в TON. Независимо от того, какой язык вы будете использовать, вам нужно знать о ячейках, срезах, асинхронной природе TON в конце концов.
2. Сталкиваясь с фрагментами FunC, вы все равно можете использовать FunC или попытаться выразить то же самое в Tolk. Если синтаксис FunC для вас необычен, не волнуйтесь: цель Tolk — как раз исправить эту проблему.
3. Как только вы поймете, что происходит, попробуйте использовать Tolk с [blueprint](https://github.com/ton-org/blueprint).

## Инструменты вокруг языка Tolk

Исходные данные компилятора Tolk являются частью [репозитория] `ton-blockchain` (https://github.com/ton-blockchain/ton).
Помимо компилятора, у нас есть:

1. [tolk-js](https://github.com/ton-blockchain/tolk-js) — оболочка WASM для компилятора Tolk.
2. [Плагин JetBrains IDE](https://github.com/ton-blockchain/intellij-ton) поддерживает Tolk, помимо FunC, Fift, TL/B и Tact.
3. [Расширение VS Code](https://github.com/ton-blockchain/tolk-vscode), включающее поддержку языка Tolk.
4. [Конвертер из FunC в Tolk](https://github.com/ton-blockchain/convert-func-to-tolk) — конвертирует файл `.fc` в файл `.tolk` с помощью одной команды `npx`.
5. Язык Tolk доступен в [blueprint](https://github.com/ton-org/blueprint).

## Готов ли Tolk к работе?

Компилятор Tolk, ответвление компилятора FunC, считается готовым к производству, хотя на данный момент он является несколько экспериментальным.

Могут существовать необнаруженные ошибки, потенциально унаследованные от FunC или связанные с характеристиками TVM.
В любом случае, независимо от того, какой язык вы используете, вы должны покрывать свои контракты тестами для достижения высокой надежности.

## Дорожная карта

Первая выпущенная версия Tolk — v0.6, подчеркивающая [отсутствие](/v3/documentation/smart-contracts/tolk/changelog#how-tolk-was-born) FunC v0.5.

Вот некоторые (но не все и никак не упорядоченные) моменты, которые необходимо изучить:

- улучшения системы типов: допустимость значений Null, целые числа фиксированного размера, типы объединений, словари
- структуры и обобщения
- автоматическая упаковка структур в/из ячеек, возможно, интегрированная с обработчиками сообщений
- методы для структур, обобщенные для охвата встроенных типов
- более простая отправка сообщений
- лучший опыт для общих вариантов использования (жетонов, nft и т. д.)
- оптимизация газа и стека, встраивание AST
- расширение и поддержка stdlib
- своего рода ABI (как проводники "видят" байт-код)
- управление газом и сборами в целом

Следующей стратегической целью для **Tolk v1.0** являются **структуры с автоматической сериализацией в ячейки**.
Это устранит необходимость ручных манипуляций с конструкторами и срезами, что позволит декларативно описывать данные и сообщения.
С этим тесно связан **ABI (интерфейс) контрактов**.
Хорошо спроектированные структуры на самом деле составляют большую часть ABI.

## Проблемы и контакты

Если вы столкнулись с проблемой, свяжитесь с сообществом разработчиков в [TON Dev Chats](https://t.me/addlist/1r5Vcb8eljk5Yzcy) или создайте issues на GitHub.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-detail.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-detail.mdx
================================================
# Сравнение Tolk и FunC: подробно

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Ниже очень большой список. У кого-нибудь хватит терпения дочитать его до конца?..

:::tip Есть краткая версия
Здесь: [Сравнение Tolk и FunC: коротко](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short)
:::

<h3 className="cmp-func-tolk-header">
  ✅ Классические комментарии :)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{';; комментарий'}</code></td>
    <td><code>{'// комментарий'}</code></td>
  </tr>
  <tr>
    <td><code>{'{- многострочный комментарий -}'}</code></td>
    <td><code>{'/* многострочный комментарий */'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
✅ `2+2` — это 4, а не идентификатор. Идентификаторы могут быть только буквенно-цифровыми
</h3>

В FunC почти любой символ может быть частью идентификатора.
Например, `2+2` (без пробела) — это идентификатор.
Вы даже можете объявить переменную с таким именем.

В Tolk пробелы не обязательны. `2+2` — это 4, как и ожидалось. `3+~x` это `3 + (~ x)` и так далее.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'return 2+2;  ;; неопределенная функция `2+2`'}</code></td>
    <td><code>{'return 2+2;  // 4'}</code></td>
  </tr>
  </tbody>
</table>

Точнее, идентификатор может начинаться с <code style={{display: 'inline-block'}}>{'[a-zA-Z$_]'}</code>
и продолжиться с <code style={{display: 'inline-block'}}>{'[a-zA-Z0-9$_]'}</code>. Обратите внимание, что `?`, `:` и другие не являются допустимыми символами, `found?` и `op::increase` не являются допустимыми идентификаторами.

Вы можете использовать обратные кавычки, чтобы окружить идентификатор, и тогда он может содержать любые символы (аналогично Kotlin и некоторым другим языкам). Его потенциальное применение — разрешить использовать ключевые слова в качестве идентификаторов, например, в случае генерации кода по схеме.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'const op::increase = 0x1234;'}</code></td>
    <td><code>{'const OP_INCREASE = 0x1234;'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: ';; even 2%&!2 is valid<br>int 2+2 = 5;'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '// don\'t do like this :)<br>var \`2+2\` = 5;'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ По умолчанию нечеткий, компилятор не будет отбрасывать вызовы пользовательских функций
</h3>

FunC имеет спецификатор функции `impure`. При его отсутствии функция рассматривается как чистая. Если ее результат не используется, ее вызов был удален компилятором.

Хотя такое поведение документировано, оно очень неожиданно для новичков.
Например, различные функции, которые ничего не возвращают (например, выдают исключение при несовпадении), молча удаляются. Эту ситуацию портит тот факт, что FunC не проверяет и не валидирует тело функции,
разрешая нечеткие операции внутри чистых функций.

В Tolk все функции по умолчанию являются нечистыми. Вы можете пометить функцию как чистую с помощью аннотации,
и тогда в ее теле будут запрещены нечистые операции (исключения, изменение глобальных параметров, вызов нечистых функций и т. д.).

<h3 className="cmp-func-tolk-header">
  ✅ Новый синтаксис функций: ключевое слово `fun`, атрибуты `@`, типы справа (как в TypeScript, Kotlin, Python и т. д.)
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'cell parse_data(slice cs) { }'}</code></td>
    <td><code>{'fun parse_data(cs: slice): cell { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell, int) load_storage() { }'}</code></td>
    <td><code>{'fun load_storage(): (cell, int) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'() main() { ... }'}</code></td>
    <td><code>{'fun main() { ... }'}</code></td>
  </tr>
  </tbody>
</table>

Типы переменных — также справа:

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'slice cs = ...;'}</code></td>
    <td><code>{'var cs: slice = ...;'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cell c, int n) = parse_data(cs);'}</code></td>
    <td><code>{'var (c: cell, n: int) = parse_data(cs);'}</code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

Модификаторы `inline` и другие — с аннотациями:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>int f(cell s) inline {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline<br>fun f(s: cell): int {'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() load_data() impure inline_ref {'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@inline_ref<br>fun load_data() {'}}></code></td>
  </tr>
  <tr>
    <td><code>{'global int stake_at;'}</code></td>
    <td><code>{'global stake_at: int;'}</code></td>
  </tr>
  </tbody>
</table>

`forall` — таким образом:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'forall X -> tuple cons(X head, tuple tail)'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'fun cons&amp;lt;X&amp;gt;(head: X, tail: tuple): tuple'}}></code></td>
  </tr>
  </tbody>
</table>

реализация `asm` — как в FunC, но при правильном выравнивании выглядит красивее:

```tolk
@pure
fun third<X>(t: tuple): X
    asm "THIRD";

@pure
fun iDictDeleteGet(dict: cell, keyLen: int, index: int): (cell, slice, int)
    asm(index dict keyLen) "DICTIDELGET NULLSWAPIFNOT";

@pure
fun mulDivFloor(x: int, y: int, z: int): int
    builtin;
```

Также есть атрибут `@deprecated`, не влияющий на компиляцию, но для человека и IDE.

<h3 className="cmp-func-tolk-header">
  ✅ `get` вместо `method_id`
</h3>

В FunC `method_id` (без аргументов) фактически объявляет get-метод. В Tolk используется простой синтаксис:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int seqno() method_id { ... }'}</code></td>
    <td><code>{'get seqno(): int { ... }'}</code></td>
  </tr>
  </tbody>
</table>

Допустимы как `get methodName()`, так и `get fun methodName()`.

Для `method_id(xxx)` (на практике встречается редко, но допустимо) есть атрибут:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: '<br>() after_code_upgrade(cont old_code) impure method_id(1666)'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: '@method_id(1666)<br>fun afterCodeUpgrade(oldCode: continuation)'}}></code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
✅ Важно объявить типы параметров (хотя необязательно для локальных переменных)
</h3>

```tolk
// not allowed
fun do_smth(c, n)
// types are mandatory
fun do_smth(c: cell, n: int)
```

Если типы параметров обязательны, возвращаемый тип не является обязательным (это часто очевидно из-за многословности). Если он опущен, он выводится автоматически:

```tolk
fun x() { ... }  // auto infer from return statements
```

Для локальных переменных типы также необязательны:

```tolk
var i = 10;                      // ok, int
var b = beginCell();             // ok, builder
var (i, b) = (10, beginCell());  // ok, two variables, int and builder

// types can be specified manually, of course:
var b: builder = beginCell();
var (i: int, b: builder) = (10, beginCell());
```

<h3 className="cmp-func-tolk-header">
✅ Переменные не могут быть повторно объявлены в той же области
</h3>

```tolk
var a = 10;
...
var a = 20;  // error, correct is just `a = 20`
if (1) {
    var a = 30;  // it's okay, it's another scope
}
```

Как следствие, частичное переназначение не допускается:

```tolk
var a = 10;
...
var (a, b) = (20, 30);  // error, releclaration of a
```

Обратите внимание, что это не проблема для `loadUint()` и других методов. В FunC они возвращали измененный объект, поэтому шаблон `var (cs, int value) = cs.load_int(32)` был довольно распространен. В Tolk такие методы изменяют объект: `var value = cs.loadInt(32)`, поэтому повторное объявление вряд ли понадобится.

```tolk
fun send(msg: cell) {
    var msg = ...;  // error, redeclaration of msg

    // solution 1: intruduce a new variable
    var msgWrapped = ...;
    // solution 2: use `redef`, though not recommended
    var msg redef = ...;
```

<h3 className="cmp-func-tolk-header">
✅ Изменения в системе типов
</h3>

Система типов FunC основана на Хиндли-Милнере. Это распространенный подход для функциональных языков, где типы выводятся из использования посредством унификации.

В Tolk v0.7 система типов переписана с нуля.
Чтобы добавить логические значения, целые числа фиксированной ширины, допустимость значений NULL, структуры и обобщения, нам нужна статическая система типов (например, TypeScript или Rust).
Поскольку Хиндли-Милнер будет конфликтовать с методами структур, бороться с надлежащими обобщениями и станет совершенно непрактичным для типов объединений (несмотря на заявления, что он был "разработан для типов объединений").

У нас есть следующие типы:

- `int`, `bool`, `cell`, `slice`, `builder`, нетипизированный `tuple`
- типизированный кортеж `[T1, T2, ...]`
- тензор `(T1, T2, ...)`
- вызываемые `fun(TArgs) -> TResult`
- `void` (каноничнее называть `unit`, но `void` надежнее)
- `self`, для создания цепочечных методов, описанных ниже; на самом деле это не тип, он может встречаться только вместо возвращаемого типа функции

Система типов подчиняется следующим правилам:

- типы переменных могут быть указаны вручную или выведены из объявлений и никогда не изменяются после объявления
- параметры функции должны быть строго типизированы
- возвращаемые типы функции, если не указаны, выводятся из операторов return, аналогично TypeScript; в случае рекурсии (прямой или косвенной) возвращаемый тип должен быть явно объявлен где-то
- поддерживаются универсальные функции

<h3 className="cmp-func-tolk-header">
  ✅ Понятные и читаемые сообщения об ошибках при несоответствии типов
</h3>

В FunC из-за Хиндли-Милнера ошибки несоответствия типов очень трудно понять:

```
error: previous function return type (int, int)
cannot be unified with implicit end-of-block return type (int, ()):
cannot unify type () with int
```

В языке Tolk они удобочитаемы для человека:

```
1) can not assign `(int, slice)` to variable of type `(int, int)`
2) can not call method for `builder` with object of type `int`
3) can not use `builder` as a boolean condition
4) missing `return`
...
```

<h3 className="cmp-func-tolk-header">
  ✅ Тип <code>bool</code>, приводящий <code>boolVar к int</code>
</h3>

Внутри себя **`bool` по-прежнему -1 и 0 на уровне TVM**, но с точки зрения системы типов `bool` и `int` теперь различны.

Операторы сравнения `== / >= /...` возвращают `bool`. Логические операторы `&& ||` возвращают `bool`. Константы `true` и `false` имеют тип `bool`.
Многие функции stdlib теперь возвращают `bool`, а не `int` (имея -1 и 0 во время выполнения):

```tolk
var valid = isSignatureValid(...);    // bool
var end = cs.isEndOfSlice();          // bool
```

Оператор `!x` поддерживает как `int`, так и `bool`. Условие `if` и подобные принимает как `int` (!= 0), так и `bool`.
Логические `&&` и `||` принимают как `bool`, так и `int`, сохраняя совместимость с такими конструкциями, как `a && b`, где `a` и `b` являются целыми числами (!= 0).

Арифметические операторы ограничены целыми числами, для bool разрешены только побитовые и логические:

```tolk
valid && end;    // ok
valid & end;     // ok, bitwise & | ^ also work if both are bools
if (!end)        // ok

if (~end)        // error, use !end
valid + end;     // error
8 & valid;       // error, int & bool not allowed
```

Обратите внимание, что логические операторы `&& ||` (отсутствуют в FunC) всегда используют представление asm IF/ELSE.
В будущем для оптимизации их можно будет автоматически заменить на `& |`, когда это безопасно (например: `a > 0 && a < 10`).
Чтобы вручную оптимизировать потребление газа, вы по-прежнему можете использовать `& |` (разрешено для bool), но помните, что они не являются сокращенными.

**`bool` можно привести к `int` с помощью оператора `as`**:

```tolk
var i = boolValue as int;  // -1 / 0
```

Нет никаких преобразований во время выполнения. `bool` гарантированно равен -1/0 на уровне TVM, поэтому это приведение только к типу.
Но, как правило, если вам нужно такое приведение, вероятно, вы делаете что-то неправильно (если только вы не делаете сложную побитовую оптимизацию).

<h3 className="cmp-func-tolk-header">
  ✅ Универсальные функции и экземпляры, такие как <code>f&amp;lt;int&amp;gt;(...)</code>
</h3>

В FunC были функции "forall":

```func
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
```

Tolk представляет правильно сделанные универсальные функции. Их синтаксис напоминает основные языки:

```tolk
fun tuplePush<T>(mutate self: tuple, value: T): void
    asm "TPUSH";
```

Когда вызывается `f<T>`, `T` обнаруживается (в большинстве случаев) по предоставленным аргументам:

```tolk
t.tuplePush(1);     // detected T=int
t.tuplePush(cs);    // detected T=slice
t.tuplePush(null);  // error, need to specify "null of what type"
```

Также поддерживается синтаксис `f<int>(...)`:

```tolk
t.tuplePush<int>(1);     // ok
t.tuplePush<int>(cs);    // error, can not pass slice to int
t.tuplePush<int>(null);  // ok, null is "null of type int"
```

Пользовательские функции также могут быть универсальными:

```tolk
fun replaceLast<T>(mutate self: tuple, value: T) {
    val size = self.tupleSize();
    self.tupleSetAt(value, size - 1);
}
```

Вызов `replaceLast<int>` и `replaceList<slice>` приведет к ДВУМ сгенерированным функциям asm (fift).
На самом деле, они в основном напоминают "шаблонные" функции. При каждом уникальном вызове тело функции полностью клонируется под новым именем.

Может быть несколько общих параметров:

```tolk
fun replaceNulls<T1, T2>(tensor: (T1, T2), v1IfNull: T1, v2IfNull: T2): (T1, T2) {
    var (a, b) = tensor;
    return (a == null ? v1IfNull : a, b == null ? v2IfNull : b);
}
```

Общий параметр `T` может быть чем-то сложным.

```tolk
fun duplicate<T>(value: T): (T, T) {
    var copy: T = value;
    return (value, copy);
}

duplicate(1);         // duplicate<int>
duplicate([1, cs]);   // duplicate<[int, slice]>
duplicate((1, 2));    // duplicate<(int, int)>
```

Или даже функции, это тоже работает:

```tolk
fun callAnyFn<TObj, TResult>(f: fun(TObj) -> TResult, arg: TObj) {
    return f(arg);
}

fun callAnyFn2<TObj, TCallback>(f: TCallback, arg: TObj) {
    return f(arg);
}
```

Обратите внимание, что хотя общие `T` в основном определяются по аргументам, есть не столь очевидные крайние случаи, когда `T` не зависит от аргументов:

```tolk
fun tupleLast<T>(self: tuple): T
    asm "LAST";

var last = t.tupleLast();    // error, can not deduce T
```

Чтобы сделать это допустимым, `T` должно быть указано извне:

```tolk
var last: int = t.tupleLast();       // ok, T=int
var last = t.tupleLast<int>();       // ok, T=int
var last = t.tupleLast() as int;     // ok, T=int

someF(t.tupleLast());       // ok, T=(paremeter's declared type)
return t.tupleLast();       // ok if function specifies return type
```

Также обратите внимание, что `T` для функций asm должен занимать 1 слот стека (иначе тело asm не сможет обработать его должным образом), тогда как для пользовательской функции `T` может иметь любую форму.

В будущем, когда будут реализованы структуры и универсальные структуры, вся мощь универсальных функций вступит в игру.

<h3 className="cmp-func-tolk-header">
  ✅ Другое наименование для recv_internal / recv_external
</h3>

```tolk
fun onInternalMessage
fun onExternalMessage
fun onTickTock
fun onSplitPrepare
fun onSplitInstall
```

Все типы параметров и их порядок переименования остаются прежними, меняется только наименование. Также доступен `fun main`.

<h3 className="cmp-func-tolk-header">
  ✅ #include → import. Строгий импорт
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'#include "another.fc";'}</code></td>
    <td><code>{'import "another.tolk"'}</code></td>
  </tr>
  </tbody>
</table>

В Tolk вы не можете использовать символ из `a.tolk` без импорта этого файла. Другими словами, "импортируйте то, что используете".

Все функции stdlib доступны из коробки, загрузка stdlib и `#include "stdlib.fc"` не требуется. См. ниже о встроенной stdlib.

По-прежнему существует глобальная область именования. Если `f` объявлено в двух разных файлах, это ошибка. Мы "мпортируем" целый файл, видимость по каждому файлу отсутствует, а ключевое слово `export` теперь поддерживается, но, вероятно, будет поддерживаться в будущем.

<h3 className="cmp-func-tolk-header">
  ✅ #pragma → параметры компилятора
</h3>

В FunC "экспериментальные" функции, такие как `allow-post-modifications`, включались прагмой в файлах .fc (что приводило к проблемам, когда некоторые файлы ее содержали, а некоторые нет). На самом деле, это не прагма для файла, а параметр компиляции.

В Tolk все прагмы были удалены. `allow-post-modification` и `compute-asm-ltr` были объединены в исходники Tolk (как будто они всегда были включены в FunC). Вместо прагм теперь есть возможность передавать экспериментальные параметры.

На данный момент введена одна экспериментальная опция — `remove-unused-functions`, которая не включает неиспользуемые символы в вывод Fift.

`#pragma version xxx` была заменена на `tolk xxx` (без >=, просто строгая версия). Хорошей практикой является указание используемой версии компилятора. Если она не совпадает, Tolk выведет предупреждение.

```tolk
tolk 0.6
```

<h3 className="cmp-func-tolk-header">
  ✅ Позднее разрешение символов. Представление AST
</h3>

В FunC (как и в С) вы не можете получить доступ к функции, объявленной ниже:

```func
int b() { a(); }   ;; error
int a() { ... }    ;; since it's declared below
```

Чтобы избежать ошибки, программист должен сначала создать предварительное объявление. Причина в том, что разрешение символов выполняется прямо во время разбора.

Компилятор Tolk разделяет эти два шага. Сначала он выполняет разбор, а затем разрешение символов. Поэтому фрагмент выше не будет ошибочным.

Звучит просто, но внутренне это очень большая работа. Чтобы сделать это доступным, я ввел промежуточное представление AST, полностью отсутствующее в FunC. Это существенный момент будущих модификаций и выполнения семантического анализа кода.

<h3 className="cmp-func-tolk-header">
  ✅ ключевое слово `null`
</h3>

Создание значений null и проверка переменных на null теперь выглядит очень красиво.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'a = null()'}</code></td>
    <td><code>{'a = null'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (null?(a))'}</code></td>
    <td><code>{'if (a == null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ null?(b))'}</code></td>
    <td><code>{'if (b != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'if (~ cell_null?(c))'}</code></td>
    <td><code>{'if (c != null)'}</code></td>
  </tr>
  </tbody>
</table>

Обратите внимание, что это НЕ означает, что язык Tolk допускает значение null. Нет, вы все равно можете присвоить `null` целочисленной переменной — как в FunC, просто синтаксически приятно. Настоящая возможность допуска значения null будет доступна когда-нибудь, после упорной работы над системой типов.

<h3 className="cmp-func-tolk-header">
  ✅ ключевые слова `throw` и `assert`
</h3>

Tolk значительно упрощает работу с исключениями.

Если в FunC есть `throw()`, `throw_if()`, `throw_arg_if()` и то же самое для unless, то в Tolk есть только два примитива: `throw` и `assert`.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'throw(excNo)'}</code></td>
    <td><code>{'throw excNo'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_arg(arg, excNo)'}</code></td>
    <td><code>{'throw (excNo, arg)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_unless(excNo, condition)'}</code></td>
    <td><code>{'assert(condition, excNo)'}</code></td>
  </tr>
  <tr>
    <td><code>{'throw_if(excNo, condition)'}</code></td>
    <td><code>{'assert(!condition, excNo)'}</code></td>
  </tr>
  </tbody>
</table>

Обратите внимание, что `!condition` возможно, так как доступно логическое НЕ, см. ниже.

Существует длинный (многословный) синтаксис `assert(condition, excNo)`:

```tolk
assert(condition) throw excNo;
// with possibility to include arg to throw
```

Кроме того, Tolk меняет местами аргументы `catch`: это `catch (excNo, arg)`, оба необязательны (так как arg, скорее всего, пуст).

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'try { } catch (_, _) { }'}</code></td>
    <td><code>{'try { } catch { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (_, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo) { }'}</code></td>
  </tr>
  <tr>
    <td><code>{'try { } catch (arg, excNo) { }'}</code></td>
    <td><code>{'try { } catch(excNo, arg) { }'}</code></td>
  </tr>
  </tbody>
</table>

<h3 className="cmp-func-tolk-header">
  ✅ `do ... until` → `do ... while`
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'do { ... } until (~ condition);'}</code></td>
    <td><code>{'do { ... } while (condition);'}</code></td>
  </tr>
  <tr>
    <td><code>{'do { ... } until (condition);'}</code></td>
    <td><code>{'do { ... } while (!condition);'}</code></td>
  </tr>
  </tbody>
</table>

Обратите внимание, что `!condition` возможно, так как доступно логическое НЕ, см. ниже.

<h3 className="cmp-func-tolk-header">
  ✅ Приоритет операторов стал идентичен C++ / JavaScript
</h3>

В FunC такой код `if (slices_equal() & status == 1)` анализируется как `if( (slices_equal()&status) == 1 )`. Это является причиной различных ошибок в реальных контрактах.

В Tolk `&` имеет более низкий приоритет, идентичный C++ и JavaScript.

Более того, Tolk выдает ошибки при потенциально неправильном использовании операторов, чтобы полностью исключить такие ошибки:

```tolk
if (flags & 0xFF != 0)
```

приведет к ошибке компиляции (похоже на gcc/clang):

```
& has lower precedence than ==, probably this code won't work as you expected.  Use parenthesis: either (... & ...) to evaluate it first, or (... == ...) to suppress this error.
```

Следовательно, код следует переписать:

```tolk
// either to evaluate it first (our case)
if ((flags & 0xFF) != 0)
// or to emphasize the behavior (not our case here)
if (flags & (0xFF != 0))
```

Я также добавил диагностику для распространенной ошибки в операторах сдвига битов: `a << 8 + 1` эквивалентно `a << 9`, вероятно, неожиданно.

```
int result = a << 8 + low_mask;

error: << has lower precedence than +, probably this code won't work as you expected.  Use parenthesis: either (... << ...) to evaluate it first, or (... + ...) to suppress this error.
```

Операторы `~% ^% /% ~/= ^/= ~%= ^%= ~>>= ^>>=` больше не существуют.

<h3 className="cmp-func-tolk-header">
  ✅ Неизменяемые переменные, объявленные через `val`
</h3>

Как в Kotlin: `var` для изменяемых, `val` для неизменяемых, необязательно с указанием типа. В FunC нет аналога `val`.

```tolk
val flags = msgBody.loadMessageFlags();
flags &= 1;         // error, modifying an immutable variable

val cs: slice = c.beginParse();
cs.loadInt(32);     // error, since loadInt() mutates an object
cs.preloadInt(32);  // ok, it's a read-only method
```

Параметры функции изменяемы, но поскольку они копируются по значению, вызываемые аргументы не изменяются. Точно так же, как в FunC, просто для ясности.

```tolk
fun some(x: int) {
    x += 1;
}

val origX = 0;
some(origX);      // origX remains 0

fun processOpIncrease(msgBody: slice) {
    val flags = msgBody.loadInt(32);
    ...
}

processOpIncrease(msgBody);  // by value, not modified
```

В Tolk функция может объявлять параметры `mutate`. Это обобщение функций тильды FunC `~`, читайте ниже.

<h3 className="cmp-func-tolk-header">
  ✅ Удалены устаревшие параметры командной строки
</h3>

Флаги командной строки `-A`, `-P` и другие были удалены. Поведение по умолчанию

```
/path/to/tolk {inputFile}
```

более чем достаточно. Используйте `-v` для печати версии и выхода. Используйте `-h` для всех доступных флагов командной строки.

Можно передать только один входной файл, другие следует `import`.

<h3 className="cmp-func-tolk-header">
  ✅ функции stdlib переименованы в ~~verbose~~ понятные имена, стиль camelCase
</h3>

Все наименования в стандартной библиотеке были пересмотрены. Теперь функции именуются с использованием более длинных, но понятных имен.

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'cur_lt()<br>car(l)<br>get_balance().pair_first()<br>raw_reserve(count)<br>dict~idict_add?(...)<br>dict~udict::delete_get_max()<br>t~tpush(triple(x, y, z))<br>s.slice_bits()<br>~dump(x)<br>...'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'getLogicalTime()<br>listGetHead(l)<br>getMyOriginalBalance()<br>reserveToncoinsOnBalance(count)<br>dict.iDictSetIfNotExists(...)<br>dict.uDictDeleteLastAndGet()<br>t.tuplePush([x, y, z])<br>s.getRemainingBitsCount()<br>debugPrint(x)<br>...'}}></code></td>
  </tr>
  </tbody>
</table>

Бывший "stdlib.fc" был разделен на несколько файлов: common.tolk, tvm-dicts.tolk и другие.

Продолжение здесь: [Tolk vs FunC: стандартная библиотека](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib).

<h3 className="cmp-func-tolk-header">
  ✅ stdlib теперь встроен, а не загружается с GitHub
</h3>

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <ol style={{margin: 0}}>
        <li>Загрузить stdlib.fc с GitHub</li>
        <li>Сохранить в свой проект</li>
        <li>`#include "stdlib.fc";`</li>
        <li>Использовать стандартные функции</li>
      </ol>
    </td>
    <td>
      <ol style={{margin: 0}}>
        <li>Использовать стандартные функции</li>
      </ol>
    </td>
  </tr>
  </tbody>
</table>

В Tolk stdlib — часть дистрибутива. Стандартная библиотека неотделима, поскольку сохранение тройки "язык, компилятор, stdlib" вместе — единственный правильный способ поддерживать цикл выпуска.

Это работает таким образом. Компилятор Tolk знает, как найти стандартную библиотеку. Если пользователь установил пакет apt, исходники stdlib также были загружены и существуют на жестком диске, поэтому компилятор находит их по системным путям. Если пользователь использует оболочку WASM, они предоставляются tolk-js. И так далее.

Стандартная библиотека разделена на несколько файлов: `common.tolk` (наиболее распространенные функции), `gas-payments.tolk` (расчет платы за газ), `tvm-dicts.tolk` и другие. Функции из `common.tolk` доступны всегда (компилятор неявно импортирует их). Другие файлы необходимо импортировать явно:

```tolk
import "@stdlib/tvm-dicts"   // ".tolk" optional

...
var dict = createEmptyDict();
dict.iDictSet(...);
```

Помните правило "импортируйте то, что используете", оно также применяется к файлам `@stdlib/...` (за исключением "common.tolk").

Плагин JetBrains IDE автоматически обнаруживает папку stdlib и вставляет необходимые импорты по мере ввода текста.

<h3 className="cmp-func-tolk-header">
  ✅ Логические операторы `&& ||`, логические не `!`
</h3>

В FunC есть только побитовые операторы `~ & | ^`. Разработчики, делающие первые шаги, думая "ладно, никаких логических, я буду использовать побитовые таким же образом", часто делают ошибки, так как поведение операторов совершенно иное:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>`a & b`</th>
    <th>`a && b`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>иногда, идентичны:</td></tr>
  <tr>
    <td><code>{'0 & X = 0'}</code></td>
    <td><code>{'0 & X = 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'-1 & X = -1'}</code></td>
    <td><code>{'-1 & X = -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>но обычно нет:</td></tr>
  <tr>
    <td><code>{'1 & 2 = 0'}</code></td>
    <td><code>{'1 && 2 = -1 (true)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>`~ found`</th>
    <th>`!found`</th>
  </tr>
  </thead>
  <tbody>
  <tr><td colSpan={2}>иногда, идентичны:</td></tr>
  <tr>
    <td><code>{'true (-1) → false (0)'}</code></td>
    <td><code>{'-1 → 0'}</code></td>
  </tr>
  <tr>
    <td><code>{'false (0) → true (-1)'}</code></td>
    <td><code>{'0 → -1'}</code></td>
  </tr>
  <tr><td colSpan={2}>но обычно нет:</td></tr>
  <tr>
    <td><code>{'1 → -2'}</code></td>
    <td><code>{'1 → 0 (false)'}</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>условие & f()</code></th>
    <th><code>условие && f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> вызывается всегда</td>
    <td><code className="inline">f()</code> вызывается только при выполнении <code className="inline">условия</code></td>
  </tr>
  </tbody>
</table>

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th><code>условие | f()</code></th>
    <th><code>условие || f()</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code className="inline">f()</code> вызывается всегда</td>
    <td><code className="inline">f()</code> вызывается только если <code className="inline">условие</code> ложно</td>
  </tr>
  </tbody>
</table>

Tolk поддерживает логические операторы. Они ведут себя так же, как вы привыкли (правый столбец). На данный момент `&&` и `||` иногда создают неоптимальный код Fift, но в будущем компилятор Tolk станет умнее в этом случае. Это незначительно, просто используйте их, как в других языках.

<table className="cmp-func-tolk-table different-col-widths">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'if (~ found?)'}</code></td>
    <td><code>{'if (!found)'}</code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'if (~ found?) {<br>    if (cs~load_int(32) == 0) {<br>        ...<br>    }<br>}'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'if (!found && cs.loadInt(32) == 0) {<br>    ...<br>}'}}></code></td>
  </tr>
  <tr>
    <td><code>{'ifnot (cell_null?(signatures))'}</code></td>
    <td><code>{'if (signatures != null)'}</code></td>
  </tr>
  <tr>
    <td><code>{'elseifnot (eq_checksum)'}</code></td>
    <td><code>{'else if (!eqChecksum)'}</code></td>
  </tr>
  </tbody>
</table>

Ключевые слова `ifnot` и `elseifnot` были удалены, так как теперь у нас есть логическое НЕ (для оптимизации, Компилятор Tolk генерирует `IFNOTJMP`, кстати). Ключевое слово `elseif` было заменено на традиционное `else if`.

Помните, что логическое `true`, преобразованное `как int`, равно -1, а не 1. Это представление TVM.

<h3 className="cmp-func-tolk-header">
  ✅ Никаких методов тильды `~`, вместо них ключевое слово `mutate`
</h3>

Это изменение настолько велико, что описано на отдельной странице: [Изменчивость Tolk](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability).

<hr />

<h3>Сравнение потребления газа в Tolk и FunC</h3>

:::caution TLDR
Потребление газа Tolk может быть немного выше, поскольку оно исправляет непредвиденную перетасовку аргументов в FunC. На практике оно незначительно.
В будущем компилятор Tolk станет достаточно умным, чтобы переупорядочивать аргументы, ориентируясь на меньшее количество манипуляций со стеком, но все еще избегая проблемы перетасовки.
:::

Компилятор FunC может неожиданно перетасовать аргументы при вызове функции сборки:

```
some_asm_function(f1(), f2());
```

Иногда `f2()` может быть вызвана до `f1()`, и это неожиданно.
Чтобы исправить это поведение, можно указать `#pragma compute-asm-ltr`, заставляя аргументы всегда вычисляться в порядке ltr.
Это было экспериментальным и поэтому отключено по умолчанию.

Эта прагма переупорядочивает аргументы в стеке, что часто приводит к большему количеству манипуляций со стеком, чем без нее.
Другими словами, in исправляет неожиданное поведение, но увеличивает расход газа.

Tolk помещает аргументы в стек точно так же, как если бы эта прагма была включена.
Таким образом, его потребление газа иногда выше, чем в FunC, если вы не использовали эту прагму.
Конечно, в Tolk нет проблемы перемешивания.

В будущем компилятор Tolk станет достаточно умным, чтобы переупорядочивать аргументы, ориентируясь на меньшее количество манипуляций со стеком,
но все еще избегая проблемы перемешивания.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-short.md
================================================
# Сравнение Tolk и FunC: коротко

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Tolk гораздо больше похож на TypeScript и Kotlin, чем на C и Lisp.
Но он по-прежнему дает вам полный контроль над ассемблером TVM, поскольку внутри него есть ядро ​​FunC.

1. Функции объявляются через `fun`, get-методы через `get`, переменные через `var` (и `val` для неизменяемых), типы указываются справа; типы параметров являются обязательными; возвращаемый тип может быть опущен (автоматически выводится), а также для локальных переменных; спецификаторы `inline` и другие являются атрибутами `@`

```tolk
global storedV: int;

fun parseData(cs: slice): cell {
    var flags: int = cs.loadMessageFlags();
    ...
}

@inline
fun sum(a: int, b: int) {   // auto inferred int
    val both = a + b;       // same
    return both;
}

get currentCounter(): int { ... }
```

2. Нет `impure`, это по умолчанию, компилятор не будет отбрасывать вызовы пользовательских функций
3. Не `recv_internal` и `recv_external`, а `onInternalMessage` и `onExternalMessage`
4. `2+2` это 4, а не идентификатор; идентификаторы буквенно-цифровые; используйте обозначение `const OP_INCREASE` вместо `const op::increase`
5. Поддерживаются логические операторы AND `&&`, OR `||`, NOT `!`
6. Улучшения синтаксиса:
   - `;; comment` → `// comment`
   - `{- comment -}` → `/* comment */`
   - `#include` → `import`, со строгим правилом "импортируйте то, что используете"
   - `~ found` → `!found` (только для true/false, очевидно) (true равно -1, как в FunC)
   - `v = null()` → `v = null`
   - `null?(v)` → `v == null`, то же самое для `builder_null?` и других
   - `~ null?(v)` → `c != null`
   - `throw(excNo)` → `throw excNo`
   - `catch(_, _)` → `catch`
   - `catch(_, excNo)` → `catch(excNo)`
   - `throw_unless(excNo, cond)` → `assert(cond, excNo)`
   - `throw_if(excNo, cond)` → `assert(!cond, excNo)`
   - `return ()` → `return`
   - `do ... until (cond)` → `do ... while (!cond)`
   - `elseif` → `else if`
   - `ifnot (cond)` → `if (!cond)`
7. Функцию можно вызывать, даже если она объявлена ​​ниже; предварительные объявления не нужны; компилятор сначала выполняет синтаксический анализ, а затем выполняет разрешение символов; теперь исходный код представлен в формате AST
8. Функции stdlib переименованы в ~~подробные~~ понятные названия в стиле camelCase; теперь они встроены, а не загружены с GitHub; они разделены на несколько файлов; общие функции доступны всегда, более конкретные доступны с помощью `import "@stdlib/tvm-dicts"`, IDE предложит вам; вот [сопоставление](/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib)
9. Нет методов тильды `~`; `cs.loadInt(32)` изменяет срез и возвращает целое число; `b.storeInt(x, 32)` изменяет конструктор; `b = b.storeInt()` также работает, так как он не только изменяет, но и возвращает; сцепленные методы работают идентично JS, они возвращают `self`; все работает точно так же, как и ожидалось, похоже на JS; нет накладных расходов во время выполнения, точно такие же инструкции Fift; пользовательские методы создаются легко; тильды `~` вообще нет в Tolk; [подробнее здесь](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability)
10. Понятные и читаемые сообщения об ошибках при несоответствии типов
11. Поддержка типа `bool`

#### Инструментарий

- Существует плагин JetBrains
- Расширение VS Code [существует](https://github.com/ton-blockchain/tolk-vscode)
- Обертка WASM для blueprint [существует](https://github.com/ton-blockchain/tolk-js)
- И даже конвертер из FunC в Tolk [существует](https://github.com/ton-blockchain/convert-func-to-tolk)

#### Что делать дальше

[Сравнение Tolk и FunC: в деталях](/v3/documentation/smart-contracts/tolk/tolk-vs-func/in-detail)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability.mdx
================================================
---
title: "Сравнение Tolk и FunC: изменчивость"
---

# Изменчивость в Tolk по сравнению с функциями тильда в FunC

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::tip TLDR

- нет методов тильда `~`
- `cs.loadInt(32)` изменяет срез и возвращает целое число
- `b.storeInt(x, 32)` изменяет конструктор
- `b = b.storeInt()` также работает, поскольку он не только изменяет, но и возвращает
- связанные методы работают аналогично JS, они возвращают `self`
- все работает точно так же, как и ожидалось, похоже на JS
- нет накладных расходов на выполнение, точно такие же инструкции Fift
- пользовательские методы создаются легко
- тильда "~" вообще не существует в Tolk
  :::

Это радикальное изменение. Если в FunC есть `.methods()` и `~methods()`, то в Tolk есть только точка, единственный способ вызвать `.method()`. Метод может _изменить_ объект, а может и нет. В отличие от "короткого" списка, это поведенческое и семантическое отличие от FunC.

Цель состоит в том, чтобы иметь вызовы, идентичные JS и другим языкам:

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int flags = cs~load_uint(32);'}</code></td>
    <td><code>{'var flags = cs.loadUint(32);'}</code></td>
  </tr>
  <tr>
    <td><code>{'(cs, int flags) = cs.load_uint(32);'}</code></td>
    <td><code>{'var flags = cs.loadUint(32);'}</code></td>
  </tr>
  <tr>
    <td><code>{'(slice cs2, int flags) = cs.load_uint(32);'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'var cs2 = cs;<br>var flags = cs2.loadUint(32);'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'slice data = get_data()<br>             .begin_parse();<br>int flag = data~load_uint(32);'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'val flag = getContractData()<br>           .beginParse()<br>           .loadUint(32);'}}></code></td>
  </tr>
  <tr>
    <td><code>{'dict~udict_set(...);'}</code></td>
    <td><code>{'dict.uDictSet(...);'}</code></td>
  </tr>
  <tr>
    <td><code>{'b~store_uint(x, 32);'}</code></td>
    <td><code>{'b.storeInt(x, 32);'}</code></td>
  </tr>
  <tr>
    <td><code>{'b = b.store_int(x, 32);'}</code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'b.storeInt(x, 32);<br><br>// также работает<br>b = b.storeUint(32);'}}></code></td>
  </tr>
  <tr>
    <td><code dangerouslySetInnerHTML={{__html: 'b = b.store_int(x, 32)<br>     .store_int(y, 32);'}}></code></td>
    <td><code dangerouslySetInnerHTML={{__html: 'b.storeInt(x, 32)<br> .storeInt(y, 32);<br><br>// b = ...; также работает'}}></code></td>
  </tr>
  </tbody>
</table>

Чтобы сделать это доступным, Tolk предлагает концепцию изменяемости, которая является обобщением того, что означает тильда в FunC.

<h3 className="cmp-func-tolk-header">
  По умолчанию все аргументы копируются по значению (идентично FunC)
</h3>

```tolk
fun someFn(x: int) {
    x += 1;
}

var origX = 0;
someFn(origX);  // origX remains 0
someFn(10);     // ok, just int
origX.someFn(); // still allowed (but not recommended), origX remains 0
```

То же самое касается ячеек, срезов и всего остального:

```tolk
fun readFlags(cs: slice) {
    return cs.loadInt(32);
}

var flags = readFlags(msgBody);  // msgBody is not modified
// msgBody.loadInt(32) will read the same flags
```

Это означает, что при вызове функции вы уверены, что исходные данные не изменяются.

<h3 className="cmp-func-tolk-header">
Ключевое слово `mutate` и функции изменения
</h3>

Но если вы добавите ключевое слово `mutate` к параметру, переданный аргумент будет изменен. Чтобы избежать неожиданных изменений, вы должны указать `mutate` при его вызове, а также:

```tolk
fun increment(mutate x: int) {
    x += 1;
}

// it's correct, simple and straightforward
var origX = 0;
increment(mutate origX);  // origX becomes 1

// these are compiler errors
increment(origX);         // error, unexpected mutation
increment(10);            // error, not lvalue
origX.increment();        // error, not a method, unexpected mutation
val constX = getSome();
increment(mutate constX); // error, it's immutable, since `val`
```

То же самое для срезов и любых других типов:

```tolk
fun readFlags(mutate cs: slice) {
    return cs.loadInt(32);
}

val flags = readFlags(mutate msgBody);
// msgBody.loadInt(32) will read the next integer
```

Это обобщение. Функция может иметь несколько параметров mutate:

```tolk
fun incrementXY(mutate x: int, mutate y: int, byValue: int) {
    x += byValue;
    y += byValue;
}

incrementXY(mutate origX, mutate origY, 10);   // both += 10
```

_Вы можете спросить — это просто передача по ссылке? По сути, это так, но поскольку "ref" — это перегруженный термин в TON (у ячеек и срезов есть ссылки), было выбрано ключевое слово `mutate`._

<h3 className="cmp-func-tolk-header">
Параметр `self`, превращающий функцию в метод
</h3>

Когда первый параметр называется `self`, он подчеркивает, что функция (все еще глобальная) является методом и должна вызываться через точку.

```tolk
fun assertNotEq(self: int, throwIfEq: int) {
    if (self == throwIfEq) {
        throw 100;
    }
}

someN.assertNotEq(10);
10.assertNotEq(10);      // also ok, since self is not mutating
assertNotEq(someN, 10);  // still allowed (but not recommended)
```

`self`, без `mutate`, является **неизменяемым** (в отличие от всех других параметров). Думайте об этом как о "методе, доступном только для чтения".

```tolk
fun readFlags(self: slice) {
    return self.loadInt(32);  // error, modifying immutable variable
}

fun preloadInt32(self: slice) {
    return self.preloadInt(32);  // ok, it's a read-only method
}
```

Объединяя `mutate` и `self`, мы получаем методы изменяемости.

<h3 className="cmp-func-tolk-header">
`mutate self` — это метод, вызываемый через точку, изменяющий объект
</h3>

Следующим образом:

```tolk
fun readFlags(mutate self: slice) {
    return self.loadInt(32);
}

val flags = msgBody.readFlags(); // pretty obvious

fun increment(mutate self: int) {
    self += 1;
}

var origX = 10;
origX.increment();    // 11
10.increment();       // error, not lvalue

// even this is possible
fun incrementWithY(mutate self: int, mutate y: int, byValue: int) {
    self += byValue;
    y += byValue;
}

origX.incrementWithY(mutate origY, 10);   // both += 10
```

Если вы посмотрите на stdlib, вы заметите, что многие функции на самом деле являются `mutate self`, то есть они являются методами, изменяющими объект. Кортежи, словари и т. д. В FunC они обычно вызывались через тильду.

```tolk
@pure
fun tuplePush<X>(mutate self: tuple, value: X): void
    asm "TPUSH";

t.tuplePush(1);
```

<h3 className="cmp-func-tolk-header">
  `return self` делает метод доступным для цепочки
</h3>

Точно как `return self` в Python или `return this` в JavaScript. Это то, что делает методы типа `storeInt()` и другие, цепочечными.

```tolk
fun storeInt32(mutate self: builder, x: int): self {
    self.storeInt(x, 32);
    return self;

    // this would also work as expected (the same Fift code)
    // return self.storeInt(x, 32);
}

var b = beginCell().storeInt(1, 32).storeInt32(2).storeInt(3, 32);
b.storeInt32(4);     // works without assignment, since mutates b
b = b.storeInt32(5); // and works with assignment, since also returns
```

Обратите внимание на возвращаемый тип, это `self`. В настоящее время вам следует указать его. Если оставить пустым, компиляция завершится неудачей. Возможно, в будущем это будет правильным.

<h3 className="cmp-func-tolk-header">
`mutate self` и функции asm
</h3>

Хотя для пользовательских функций это очевидно, может быть интересно, как сделать функцию `asm` с таким поведением? Чтобы ответить на этот вопрос, мы должны заглянуть под капот, как работает изменение внутри компилятора.

Когда функция имеет параметры `mutate`, она фактически неявно возвращает их, и они неявно присваиваются аргументам. Это лучше сделать на примере:

```tolk
// actually returns (int, void)
fun increment(mutate x: int): void { ... }

// actually does: (x', _) = increment(x); x = x'
increment(mutate x);

// actually returns (int, int, (slice, cell))
fun f2(mutate x: int, mutate y: int): (slice, cell) { ... }

// actually does: (x', y', r) = f2(x, y); x = x'; y = y'; someF(r)
someF(f2(mutate x, mutate y));

// when `self`, it's exactly the same
// actually does: (cs', r) = loadInt(cs, 32); cs = cs'; flags = r
flags = cs.loadInt(32);
```

Итак, функция `asm` должна поместить `self'` в стек перед своим возвращаемым значением:

```tolk
// "TPUSH" pops (tuple) and pushes (tuple')
// so, self' = tuple', and return an empty tensor
// `void` is a synonym for an empty tensor
fun tuplePush<X>(mutate self: tuple, value: X): void
    asm "TPUSH";

// "LDU" pops (slice) and pushes (int, slice')
// with asm(-> 1 0), we make it (slice', int)
// so, self' = slice', and return int
fun loadMessageFlags(mutate self: slice): int
    asm(-> 1 0) "4 LDU";
```

Обратите внимание, что для возврата self вам не нужно делать ничего особенного, просто указать тип возвращаемого значения. Остальное сделает компилятор.

```tolk
// "STU" pops (int, builder) and pushes (builder')
// with asm(op self), we put arguments to correct order
// so, self' = builder', and return an empty tensor
// but to make it chainable, `self` instead of `void`
fun storeMessageOp(mutate self: builder, op: int): self
    asm(op self) "32 STU";
```

Маловероятно, что вам придется делать такие трюки. Скорее всего, вы просто напишете обертки вокруг существующих функций:

```tolk
// just do like this, without asm, it's the same effective

@inline
fun myLoadMessageFlags(mutate self: slice): int {
    return self.loadUint(4);
}

@inline
fun myStoreMessageOp(mutate self: builder, flags: int): self {
    return self.storeUint(32, flags);
}
```

<h3 className="cmp-func-tolk-header">
Нужно ли мне `@inline` для простых функций/методов?
</h3>

Пока что лучше сделать это, да. В большинстве приведенных выше примеров `@inline` было опущено для ясности. В настоящее время без `@inline` это будет отдельное продолжение TVM с переходами в и из неё. С `@inline` функция будет сгенерирована, но встроена Fift (как спецификатор `inline` в FunC).

В будущем Tolk будет автоматически определять простые функции и выполнять встраивание true самостоятельно, на уровне AST. Такие функции даже не будут сгенерированы в Fift. Компилятор будет решать лучше, чем человек, встраивать ли, делать ссылку и т. д. Но Tolk понадобится некоторое время, чтобы стать таким умным :) На данный момент пожалуйста указывайте атрибуn `@inline`.

<h3 className="cmp-func-tolk-header">
Но `self` — это не метод, это все еще функция! Я чувствую, что меня обманули
</h3>

Абсолютно. Как и FunC, Tolk имеет только глобальные функции (начиная с v0.6). Нет классов/структур с методами. Нет методов `hash()` для `slice` и `hash()` для `cell`. Вместо этого есть функции `sliceHash()` и `cellHash()`, которые можно вызывать как функции или через точку (предпочтительно):

```tolk
fun f(s: slice, c: cell) {
    // not like this
    s.hash();
    c.hash();
    // but like this
    s.sliceHash();
    c.cellHash();
    // since it's the same as
    sliceHash(s);
    cellHash(s);
}
```

В будущем, после гигантской работы над системой типов, полностью переработав ядро ​​FunC внутри, Tolk, возможно, получит возможность объявлять структуры с помощью реальных методов, достаточно обобщенных, чтобы охватывать встроенные типы. Но для этого потребуется долгий путь.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/tolk/tolk-vs-func/stdlib.md
================================================
# Tolk и FunC: стандартная библиотека

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

FunC обладает богатой [стандартной библиотекой] (/v3/documentation/smart-contracts/func/docs/stdlib),
известной как файл *"stdlib.fc "*. Она довольно низкоуровневая и содержит множество `asm`функций, названия которых очень похожи на команды TVM.

Tolk также имеет стандартную библиотеку, основанную на библиотеке FunC. Три основных отличия:

1. Она разделена на несколько файлов: `common.tolk`, `tvm-dicts.tolk` и другие. Функции из `common.tolk` доступны всегда. Функции из других файлов доступны после импорта:

```tolk
import "@stdlib/tvm-dicts"

beginCell()          // available always
createEmptyDict()    // available due to import
```

2. Вам не нужно загружать ее с GitHub, она является частью дистрибутива Tolk.
3. Почти все функции FunC были переименованы в ~~подробные~~ понятные названия. Это позволяет лучше понимать, что происходит, при написании контрактов или чтении примеров.

## Список переименованных функций

Если столбец "Требуемый импорт" пуст - функция доступна без импорта.

Обратите внимание, что некоторые функции были удалены, так как их можно выразить синтаксически или они были крайне редко используемы на практике.

| Название в FunC                                                                                 | Название в Tolk                         | Необходимый импорт |
| ----------------------------------------------------------------------------------------------- | --------------------------------------- | ------------------ |
| empty_tuple                                                                | createEmptyTuple                        |                    |
| tpush                                                                                           | tuplePush                               |                    |
| first                                                                                           | tupleFirst                              |                    |
| at                                                                                              | tupleAt                                 |                    |
| touch                                                                                           | stackMoveToTop                          | tvm-lowlevel       |
| impure_touch                                                               | *(удалено)*          |                    |
| single                                                                                          | *(удалено)*          |                    |
| unsingle                                                                                        | *(удалено)*          |                    |
| pair                                                                                            | *(удалено)*          |                    |
| unpair                                                                                          | *(удалено)*          |                    |
| triple                                                                                          | *(удалено)*          |                    |
| untriple                                                                                        | *(удалено)*          |                    |
| tuple4                                                                                          | *(удалено)*          |                    |
| untuple4                                                                                        | *(удалено)*          |                    |
| second                                                                                          | *(удалено)*          |                    |
| third                                                                                           | *(удалено)*          |                    |
| fourth                                                                                          | *(удалено)*          |                    |
| pair_first                                                                 | *(удалено)*          |                    |
| pair_second                                                                | *(удалено)*          |                    |
| triple_first                                                               | *(удалено)*          |                    |
| triple_second                                                              | *(удалено)*          |                    |
| triple_third                                                               | *(удалено)*          |                    |
| minmax                                                                                          | minMax                                  |                    |
| my_address                                                                 | getMyAddress                            |                    |
| get_balance                                                                | getMyOriginalBalanceWithExtraCurrencies |                    |
| cur_lt                                                                     | getLogicalTime                          |                    |
| block_lt                                                                   | getCurrentBlockLogicalTime              |                    |
| cell_hash                                                                  | cellHash                                |                    |
| slice_hash                                                                 | sliceHash                               |                    |
| string_hash                                                                | stringHash                              |                    |
| check_signature                                                            | isSignatureValid                        |                    |
| check_data_signature                                  | isSliceSignatureValid                   |                    |
| compute_data_size                                     | calculateCellSizeStrict                 |                    |
| slice_compute_data_size          | calculateSliceSizeStrict                |                    |
| compute_data_size?                                    | calculateCellSize                       |                    |
| slice_compute_data_size?         | calculateSliceSize                      |                    |
| ~dump                                                                           | debugPrint                              |                    |
| ~strdump                                                                        | debugPrintString                        |                    |
| dump_stack                                                                 | debugDumpStack                          |                    |
| get_data                                                                   | getContractData                         |                    |
| set_data                                                                   | setContractData                         |                    |
| get_c3                                                                     | getTvmRegisterC3                        | tvm-lowlevel       |
| set_c3                                                                     | setTvmRegisterC3                        | tvm-lowlevel       |
| bless                                                                                           | transformSliceToContinuation            | tvm-lowlevel       |
| accept_message                                                             | acceptExternalMessage                   |                    |
| set_gas_limit                                         | setGasLimit                             |                    |
| buy_gas                                                                    | *(удалено)*          |                    |
| commit                                                                                          | commitContractDataAndActions            |                    |
| divmod                                                                                          | divMod                                  |                    |
| moddiv                                                                                          | modDiv                                  |                    |
| muldiv                                                                                          | mulDivFloor                             |                    |
| muldivr                                                                                         | mulDivRound                             |                    |
| muldivc                                                                                         | mulDivCeil                              |                    |
| muldivmod                                                                                       | mulDivMod                               |                    |
| begin_parse                                                                | beginParse                              |                    |
| end_parse                                                                  | assertEndOfSlice                        |                    |
| load_ref                                                                   | loadRef                                 |                    |
| preload_ref                                                                | preloadRef                              |                    |
| load_int                                                                   | loadInt                                 |                    |
| load_uint                                                                  | loadUint                                |                    |
| preload_int                                                                | preloadInt                              |                    |
| preload_uint                                                               | preloadUint                             |                    |
| load_bits                                                                  | loadBits                                |                    |
| preload_bits                                                               | preloadBits                             |                    |
| load_grams                                                                 | loadCoins                               |                    |
| load_coins                                                                 | loadCoins                               |                    |
| skip_bits                                                                  | skipBits                                |                    |
| first_bits                                                                 | getFirstBits                            |                    |
| skip_last_bits                                        | removeLastBits                          |                    |
| slice_last                                                                 | getLastBits                             |                    |
| load_dict                                                                  | loadDict                                |                    |
| preload_dict                                                               | preloadDict                             |                    |
| skip_dict                                                                  | skipDict                                |                    |
| load_maybe_ref                                        | loadMaybeRef                            |                    |
| preload_maybe_ref                                     | preloadMaybeRef                         |                    |
| cell_depth                                                                 | getCellDepth                            |                    |
| slice_refs                                                                 | getRemainingRefsCount                   |                    |
| slice_bits                                                                 | getRemainingBitsCount                   |                    |
| slice_bits_refs                                       | getRemainingBitsAndRefsCount            |                    |
| slice_empty?                                                               | isEndOfSlice                            |                    |
| slice_data_empty?                                     | isEndOfSliceBits                        |                    |
| slice_refs_empty?                                     | isEndOfSliceRefs                        |                    |
| slice_depth                                                                | getSliceDepth                           |                    |
| equal_slice_bits                                      | isSliceBitsEqual                        |                    |
| builder_refs                                                               | getBuilderRefsCount                     |                    |
| builder_bits                                                               | getBuilderBitsCount                     |                    |
| builder_depth                                                              | getBuilderDepth                         |                    |
| begin_cell                                                                 | beginCell                               |                    |
| end_cell                                                                   | endCell                                 |                    |
| store_ref                                                                  | storeRef                                |                    |
| store_uint                                                                 | storeUint                               |                    |
| store_int                                                                  | storeInt                                |                    |
| store_slice                                                                | storeSlice                              |                    |
| store_grams                                                                | storeCoins                              |                    |
| store_coins                                                                | storeCoins                              |                    |
| store_dict                                                                 | storeDict                               |                    |
| store_maybe_ref                                       | storeMaybeRef                           |                    |
| store_builder                                                              | storeBuilder                            |                    |
| load_msg_addr                                         | loadAddress                             |                    |
| parse_addr                                                                 | parseAddress                            |                    |
| parse_std_addr                                        | parseStandardAddress                    |                    |
| parse_var_addr                                        | *(удалено)*          |                    |
| config_param                                                               | getBlockchainConfigParam                |                    |
| raw_reserve                                                                | reserveToncoinsOnBalance                |                    |
| raw_reserve_extra                                     | reserveExtraCurrenciesOnBalance         |                    |
| send_raw_message                                      | sendRawMessage                          |                    |
| set_code                                                                   | setContractCodePostponed                |                    |
| rand                                                                                            | randomRange                             |                    |
| get_seed                                                                   | randomGetSeed                           |                    |
| set_seed                                                                   | randomSetSeed                           |                    |
| randomize                                                                                       | randomizeBy                             |                    |
| randomize_lt                                                               | randomizeByLogicalTime                  |                    |
| dump                                                                                            | debugPrint                              |                    |
| strdump                                                                                         | debugPrintString                        |                    |
| dump_stk                                                                   | debugDumpStack                          |                    |
| empty_list                                                                 | createEmptyList                         | lisp-lists         |
| cons                                                                                            | listPrepend                             | lisp-lists         |
| uncons                                                                                          | listSplit                               | lisp-lists         |
| list_next                                                                  | listNext                                | lisp-lists         |
| car                                                                                             | listGetHead                             | lisp-lists         |
| cdr                                                                                             | listGetTail                             | lisp-lists         |
| new_dict                                                                   | createEmptyDict                         | tvm-dicts          |
| dict_empty?                                                                | dictIsEmpty                             | tvm-dicts          |
| idict_set_ref                                         | iDictSetRef                             | tvm-dicts          |
| udict_set_ref                                         | uDictSetRef                             | tvm-dicts          |
| idict_get_ref                                         | iDictGetRefOrNull                       | tvm-dicts          |
| idict_get_ref?                                        | iDictGetRef                             | tvm-dicts          |
| udict_get_ref?                                        | uDictGetRef                             | tvm-dicts          |
| idict_set_get_ref                | iDictSetAndGetRefOrNull                 | tvm-dicts          |
| udict_set_get_ref                | iDictSetAndGetRefOrNull                 | tvm-dicts          |
| idict_delete?                                                              | iDictDelete                             | tvm-dicts          |
| udict_delete?                                                              | uDictDelete                             | tvm-dicts          |
| idict_get?                                                                 | iDictGet                                | tvm-dicts          |
| udict_get?                                                                 | uDictGet                                | tvm-dicts          |
| idict_delete_get?                                     | iDictDeleteAndGet                       | tvm-dicts          |
| udict_delete_get?                                     | uDictDeleteAndGet                       | tvm-dicts          |
| udict_set                                                                  | uDictSet                                | tvm-dicts          |
| idict_set                                                                  | iDictSet                                | tvm-dicts          |
| dict_set                                                                   | sDictSet                                | tvm-dicts          |
| udict_add?                                                                 | uDictSetIfNotExists                     | tvm-dicts          |
| udict_replace?                                                             | uDictSetIfExists                        | tvm-dicts          |
| idict_add?                                                                 | iDictSetIfNotExists                     | tvm-dicts          |
| idict_replace?                                                             | iDictSetIfExists                        | tvm-dicts          |
| udict_set_builder                                     | uDictSetBuilder                         | tvm-dicts          |
| idict_set_builder                                     | iDictSetBuilder                         | tvm-dicts          |
| dict_set_builder                                      | sDictSetBuilder                         | tvm-dicts          |
| udict_add_builder?                                    | uDictSetBuilderIfNotExists              | tvm-dicts          |
| udict_replace_builder?                                | uDictSetBuilderIfExists                 | tvm-dicts          |
| idict_add_builder?                                    | iDictSetBuilderIfNotExists              | tvm-dicts          |
| idict_replace_builder?                                | iDictSetBuilderIfExists                 | tvm-dicts          |
| udict_delete_get_min             | uDictDeleteFirstAndGet                  | tvm-dicts          |
| idict_delete_get_min             | iDictDeleteFirstAndGet                  | tvm-dicts          |
| dict_delete_get_min              | sDictDeleteFirstAndGet                  | tvm-dicts          |
| udict_delete_get_max             | uDictDeleteLastAndGet                   | tvm-dicts          |
| idict_delete_get_max             | iDictDeleteLastAndGet                   | tvm-dicts          |
| dict_delete_get_max              | sDictDeleteLastAndGet                   | tvm-dicts          |
| udict_get_min?                                        | uDictGetFirst                           | tvm-dicts          |
| udict_get_max?                                        | uDictGetLast                            | tvm-dicts          |
| udict_get_min_ref?               | uDictGetFirstAsRef                      | tvm-dicts          |
| udict_get_max_ref?               | uDictGetLastAsRef                       | tvm-dicts          |
| idict_get_min?                                        | iDictGetFirst                           | tvm-dicts          |
| idict_get_max?                                        | iDictGetLast                            | tvm-dicts          |
| idict_get_min_ref?               | iDictGetFirstAsRef                      | tvm-dicts          |
| idict_get_max_ref?               | iDictGetLastAsRef                       | tvm-dicts          |
| udict_get_next?                                       | uDictGetNext                            | tvm-dicts          |
| udict_get_nexteq?                                     | uDictGetNextOrEqual                     | tvm-dicts          |
| udict_get_prev?                                       | uDictGetPrev                            | tvm-dicts          |
| udict_get_preveq?                                     | uDictGetPrevOrEqual                     | tvm-dicts          |
| idict_get_next?                                       | iDictGetNext                            | tvm-dicts          |
| idict_get_nexteq?                                     | iDictGetNextOrEqual                     | tvm-dicts          |
| idict_get_prev?                                       | iDictGetPrev                            | tvm-dicts          |
| idict_get_preveq?                                     | iDictGetPrevOrEqual                     | tvm-dicts          |
| udict::delete_get_min | uDictDeleteFirstAndGet                  | tvm-dicts          |
| idict::delete_get_min | iDictDeleteFirstAndGet                  | tvm-dicts          |
| dict::delete_get_min  | sDictDeleteFirstAndGet                  | tvm-dicts          |
| udict::delete_get_max | uDictDeleteLastAndGet                   | tvm-dicts          |
| idict::delete_get_max | iDictDeleteLastAndGet                   | tvm-dicts          |
| dict::delete_get_max  | sDictDeleteLastAndGet                   | tvm-dicts          |
| pfxdict_get?                                                               | prefixDictGet                           | tvm-dicts          |
| pfxdict_set?                                                               | prefixDictSet                           | tvm-dicts          |
| pfxdict_delete?                                                            | prefixDictDelete                        | tvm-dicts          |

## Список добавленных функций

В стандартной библиотеке Tolk есть некоторые функции, которые отсутствовали в FunC, но довольно часто используются для решения повседневных задач.

Поскольку Tolk активно развивается, а его стандартная библиотека изменяется, лучше ориентироваться на папку `tolk-stdlib/`
в исходниках [здесь](https://github.com/ton-blockchain/ton/tree/master/crypto/smartcont/tolk-stdlib).
Кроме функций, были добавлены некоторые константы, такие как: `SEND_MODE_*`, `RESERVE_MODE_*` и другие.

Когда FunC станет устаревшим, документация о стандартной библиотеке Tolk будет полностью переписана.

И помните, что все вышеупомянутые функции на самом деле являются обёртками над ассемблером TVM. Если чего-то не хватает, вы можете легко обернуть любую инструкцию TVM самостоятельно.

## Некоторые функции стали мутирующими, не возвращая копию

<table className="cmp-func-tolk-table">
  <thead>
  <tr>
    <th>FunC</th>
    <th>Tolk</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>{'int flags = cs~load_uint(32);'}</code></td>
    <td><code>{'var flags = cs.loadUint(32);'}</code></td>
  </tr>
  <tr>
    <td><code>{'dict~udict_set(...);'}</code></td>
    <td><code>{'dict.uDictSet(...);'}</code></td>
  </tr>
  <tr>
    <td>...</td>
    <td>...</td>
  </tr>
  </tbody>
</table>

Большинство функций FunC, которые на практике использовались с тильдой `~`, теперь мутируют объект. См. примеры выше.

Например, если вы использовали `dict~udict_set(…)`, просто используйте `dict.uDictSet(…)`, и все будет в порядке.
Но если вы использовали `dict.udict_set(…)`, чтобы получить копию, вам нужно будет выразить это другим способом.

[Подробнее о мутабельности](/v3/documentation/smart-contracts/tolk/tolk-vs-func/mutability).

## Как работает встроенная stdlib под капотом

Как упоминалось ранее, все стандартные функции доступны "из коробки".
Да, для нестандартных функций потребуется `import` (это сделано намеренно), но при этом внешние загрузки не нужны.

Это работает следующим образом.

Первое, что делает компилятор Tolk при запуске - ищет папку stdlib, выполняя поиск по предопределённым путям относительно исполняемого бинарного файла
Например, если вы запускаете компилятор Tolk из установленного пакета (например, `/usr/bin/tolk`), он найдёт stdlib в `/usr/share/ton/smartcont`.
Если у вас нестандартная установка, вы можете указать переменную окружения `TOLK_STDLIB`. Это стандартная практика для компиляторов.

Обертка WASM [tolk-js](https://github.com/ton-blockchain/tolk-js) также содержит stdlib.
Таким образом, при использовании tolk-js или blueprint все функции stdlib доступны "из коробки".

Плагины IDE (как JetBrains и VS Code) также автоматически находят stdlib для автозавершения кода.
Если вы используете blueprint, он автоматически устанавливает tolk-js, и, соответственно, в структуре файлов вашего проекта появляется папка `node_modules/@ton/tolk-js/`.
Внутри находятся файлы `common.tolk`, `tvm-dicts.tolk` и другие.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/accept-message-effects.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/accept-message-effects.md
================================================
# Принятие сообщений и их эффекты

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

`accept_message` и `set_gas_limit` могут вызывать неочевидные эффекты, когда вы строго следуете указаниям в [справочнике stdlib](/v3/documentation/smart-contracts/func/docs/stdlib#accept_message).

## Внешние сообщения

Внешние сообщения обрабатываются следующим образом:

- `gas_limit` устанавливается на `gas_credit` (ConfigParam 20 и ConfigParam 21), что равно 10 тыс. газа.
- Во время расходования этих кредитов контракт должен вызвать `accept_message` для `set_gas_limit`, указав, что он готов платить сборы за обработку сообщения.
- Если `gas_credit` достигнут или вычисления завершены, а `accept_message` не вызван, сообщение будет полностью отброшено (как будто его никогда и не было).
- В противном случае будет установлен новый лимит газа, равный `contract_balance/gas_price` (в случае `accept_message`) или пользовательскому числу (в случае `set_gas_limit`); после завершения транзакции из баланса контракта будут вычтены полные сборы за вычисления (таким образом, `gas_credit` действительно является **кредитом**, а не бесплатным газом).

Обратите внимание, что если после `accept_message` возникнет какая-либо ошибка (либо в ComputePhase, либо в ActionPhase), транзакция будет записана в блокчейн, а сборы будут вычтены из баланса контракта. Однако хранилище не будет обновлено, и действия не будут применены, как в случае любой транзакции с ошибкой кода выхода.

В результате, если контракт принимает внешнее сообщение, а затем выдает исключение из-за ошибки в данных сообщения или отправки неправильно сериализованного сообщения, он оплатит обработку, но не будет иметь возможности предотвратить повторное воспроизведение сообщения. **Одно и то же сообщение будет приниматься контрактом снова и снова, пока не израсходует весь баланс.**

## Внутреннее сообщение

По умолчанию, когда контракт получает внутреннее сообщение, лимит газа устанавливается на `message_balance`/`gas_price`. Другими словами, сообщение оплачивает его обработку. Используя `accept_message`/`set_gas_limit`, контракт может изменить лимит газа во время выполнения.

Обратите внимание, что ручные настройки лимитов газа не влияют на поведение отклонения; сообщения будут возвращены, если они отправлены в режиме отклонения и содержат достаточно денег для оплаты их обработки и создания сообщений о отклонении.

:::info пример

Если в том же примере стоимость вычисления составляет 0,5 (вместо 0,005), возврата не будет (баланс сообщения будет `0,1 - 0,5 - 0,001 = -0,401`, то есть возврата не будет), а баланс контракта будет `1 + 0,1 - 0,5` = `0,6` TON.
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/fees-low-level.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/fees-low-level.md
================================================
# Обзор низкоуровневых комиссий

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::caution
This section describes instructions and manuals for interacting with TON at a low level.

Здесь вы найдете **сырые формулы** для расчета комиссий и сборов в TON.

Однако большинство из них **уже реализованы через коды операций**! Поэтому вы **используете их вместо ручных вычислений**
:::

В этом документе дается общее представление о комиссиях за транзакции в TON и, в частности, о комиссиях за вычисления для кода FunC. Также есть [подробная спецификация в техническом документе TVM](https://ton.org/tvm.pdf).

## Транзакции и фазы

Как было описано в [обзоре TVM](/v3/documentation/tvm/tvm-overview), выполнение транзакции состоит из нескольких фаз. Во время этих фаз могут вычитаться соответствующие комиссии. Существует [обзор высокоуровневых комиссий](/v3/documentation/smart-contracts/transaction-fees/fees).

## Плата за хранение

Валидаторы TON взимают плату за хранение со смарт-контрактов.

Плата за хранение взимается с `balance` смарт-контракта на **фазе хранения** **любой** транзакции в связи с оплатой за хранение в зависимости от состояния аккаунта
(включая код и данные смарт-контракта, если они есть) до настоящего времени. Даже если [контракт получил 1 nanoton](https://retracer.ton.org/?tx=1805820dccd7ffd70d6cee6cb581e60ee2f91f7f3eeb20ed00c08dc9fcd6a08b), он погасит всю задолженность с момента последней оплаты. В результате смарт-контракт может быть заморожен. **Только уникальные ячейки хеша учитываются для комиссий за хранение и пересылку, т. е. 3 одинаковые ячейки хеша считаются как одна**. В частности, это [дедуплицирует](/v3/documentation/data-formats/tlb/library-cells) данные: если в разных ветвях есть несколько эквивалентных подячеек, их содержимое сохраняется только один раз.

Важно помнить, что в TON вы платите как за выполнение смарт-контракта, так и за **используемое хранилище** (см. [статью @thedailyton](https://telegra.ph/Commissions-on-TON-07-22)), `storage_fee` зависит от размера вашего контракта: количества ячеек и суммы битов из этих ячеек. Это означает, что вам придется платить комиссию за хранение за наличие кошелька TON (даже если он очень-очень маленький).

Если вы не использовали свой кошелек TON в течение значительного периода времени (1 год), *вам придется заплатить значительно большую комиссию, чем обычно, поскольку кошелек платит комиссию за отправку и получение транзакций*.

:::info **Примечание**:
Когда сообщение возвращается из контракта, контракт выплачивает свою текущую `storage_fee`
:::

### Формула

Вы можете приблизительно рассчитать плату за хранение для смарт-контрактов, используя эту формулу:

```cpp
storage_fee = ceil(
                  (account.bits * bit_price
                  + account.cells * cell_price)
               * time_delta / 2 ^ 16)

```

Давайте рассмотрим каждое значение более подробно:

- `storage_fee` — цена за хранение для `time_delta` секунд
- `account.cells` — количество ячеек, используемых смарт-контрактом
- `account.bits` — количество бит, используемых смарт-контрактом
- `cell_price` — цена одной ячейки
- `bit_price` — цена одного бита

И `cell_price`, и `bit_price` можно получить из конфигурации сети [параметр 18](/v3/documentation/network/configs/blockchain-configs#param-18).

Текущие значения:

- Воркчейн.
  ```cpp
  bit_price_ps:1
  cell_price_ps:500
  ```
- Мастерчейн.
  ```cpp
  mc_bit_price_ps:1000
  mc_cell_price_ps:500000
  ```

### Пример калькулятора

Вы можете использовать этот скрипт JS для расчета стоимости хранения 1 МБ в воркчейне на 1 год

```js live
// Welcome to LIVE editor!
// feel free to change any variables
// Source code uses RoundUp for the fee amount, so does the calculator

function storageFeeCalculator() {
  const size = 1024 * 1024 * 8; // 1MB in bits
  const duration = 60 * 60 * 24 * 365; // 1 Year in secs

  const bit_price_ps = 1;
  const cell_price_ps = 500;

  const pricePerSec =
    size * bit_price_ps + +Math.ceil(size / 1023) * cell_price_ps;

  let fee = Math.ceil((pricePerSec * duration) / 2 ** 16) * 10 ** -9;
  let mb = (size / 1024 / 1024 / 8).toFixed(2);
  let days = Math.floor(duration / (3600 * 24));

  let str = `Storage Fee: ${fee} TON (${mb} MB for ${days} days)`;

  return str;
}
```

## Плата за вычисления

### Газ

Все затраты на вычисления номинированы в единицах газа. Цена единиц газа определяется этой [конфигурацией цепи](/v3/documentation/network/configs/blockchain-configs#param-20-and-21) (Конфигурация 20 для мастерчейна и Конфигурация 21 для бейсчейна) и может быть изменена только по консенсусу валидаторов. Обратите внимание, что в отличие от других систем, пользователь не может устанавливать собственную цену на газ, и нет рынка комиссий.

Текущие настройки в бейсчейне следующие: 1 единица газа стоит 400 nanoton.

### Стоимость инструкций TVM

На самом низком уровне (выполнение инструкций TVM) стоимость газа для большинства примитивов
равна *базовой цене газа*, вычисляемой как `P_b := 10 + b + 5r`,
где `b` — длина инструкции в битах, а `r` — количество ссылок на ячейки, включенных в инструкцию.

Помимо этих основных сборов, появляются следующие сборы:

| Инструкция                  | Цена газа | Описание                                                                                                                                                                                                                |
| --------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Создание ячейки             | **500**   | Операция преобразования строителя в ячейку.                                                                                                                                                             |
| Анализ ячейки в первый раз  | **100**   | Операция преобразования ячеек в срезы первый раз в ходе текущей транзакции.                                                                                                                             |
| Повторный анализ ячейки     | **25**    | Операция преобразования ячеек в срезы, которая уже была проанализирована в ходе той же транзакции.                                                                                                      |
| Вызов исключения            | **50**    |                                                                                                                                                                                                                         |
| Операция с кортежем         | **1**     | Эта цена будет умножена на количество элементов кортежа.                                                                                                                                                |
| Неявный переход             | **10**    | Оплачивается, когда выполняются все инструкции в текущей ячейке продолжения. Однако в этой ячейке продолжения есть ссылки, и поток выполнения переходит к первой ссылке.                |
| Неявный обратный переход    | **5**     | Он оплачивается, когда все инструкции в текущем продолжении выполнены, и поток выполнения возвращается к продолжению, из которого было вызвано только что завершенное продолжение.                      |
| Перемещение элементов стека | **1**     | Цена за перемещение элементов стека между продолжениями. Будет взиматься соответствующая цена газа за каждый элемент. Однако перемещение первых 32 элементов бесплатно. |

### Плата за газ для FunC конструкций

Почти все функции FunC, используемые в этой статье, определены в [контракте stdlib.fc стейблкоина](https://github.com/ton-blockchain/stablecoin-contract) (на самом деле stdlib.fc с новыми кодами операций в настоящее время **находится в стадии разработки** и **еще не представлен в репозиториях основной сети**, но вы можете использовать `stdlib.fc` из исходного кода [стейблкоина](https://github.com/ton-blockchain/ton) в качестве ссылки), который сопоставляет функции FunC с инструкциями ассемблера Fift. В свою очередь, инструкции ассемблера Fift сопоставляются с инструкциями битовой последовательности в [asm.fif](https://github.com/ton-blockchain/ton/blob/master/crypto/fift/lib/Asm.fif). Поэтому, если вы хотите понять, сколько именно будет стоить вызов инструкции, вам нужно найти представление `asm` в `stdlib.fc`, затем найти битовую последовательность в `asm.fif` и вычислить длину инструкции в битах.

Однако, как правило, сборы, связанные с длиной бит, незначительны по сравнению с сборами, связанными с анализом и созданием ячеек, а также переходами и просто количеством выполненных инструкций.

Поэтому, если вы пытаетесь оптимизировать свой код, начните с оптимизации архитектуры, уменьшения количества операций анализа/создания ячеек, а затем с уменьшения количества переходов.

### Операции с ячейками

Просто пример того, как правильная работа ячеек может существенно снизить затраты на газ.

Давайте представим, что вы хотите добавить некоторую закодированную полезную нагрузку к исходящему сообщению. Простая реализация будет следующей:

```cpp
slice payload_encoding(int a, int b, int c) {
  return
    begin_cell().store_uint(a,8)
                .store_uint(b,8)
                .store_uint(c,8)
    .end_cell().begin_parse();
}

() send_message(slice destination) impure {
  slice payload = payload_encoding(1, 7, 12);
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(destination)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0x33bbff77, 32) ;; op-code (see smart-contract guidelines)
    .store_uint(cur_lt(), 64)  ;; query_id (see smart-contract guidelines)
    .store_slice(payload)
  .end_cell();
  send_raw_message(msg, 64);
}
```

В чем проблема с этим кодом? `payload_encoding` для генерации битовой строки среза, сначала создайте ячейку с помощью `end_cell()` (+500 единиц газа). Затем проанализируйте ее `begin_parse()` (+100 единиц газа). Тот же код можно написать без этих ненужных операций, изменив некоторые часто используемые типы:

```cpp
;; we add asm for function which stores one builder to the another, which is absent from stdlib
builder store_builder(builder to, builder what) asm(what to) "STB";

builder payload_encoding(int a, int b, int c) {
  return
    begin_cell().store_uint(a,8)
                .store_uint(b,8)
                .store_uint(c,8);
}

() send_message(slice destination) impure {
  builder payload = payload_encoding(1, 7, 12);
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(destination)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0x33bbff77, 32) ;; op-code (see smart-contract guidelines)
    .store_uint(cur_lt(), 64)  ;; query_id (see smart-contract guidelines)
    .store_builder(payload)
  .end_cell();
  send_raw_message(msg, 64);
}
```

Передавая битовую строку в другой форме (строитель вместо среза), мы существенно снижаем стоимость вычислений за счет очень небольшого изменения кода.

### Inline и inline_refs

По умолчанию, когда у вас есть функция FunC, она получает свой собственный `id`, хранящийся в отдельном листе словаря id->function, и когда вы вызываете ее где-то в программе, происходит поиск функции в словаре и последующий переход. Такое поведение оправдано, если ваша функция вызывается из многих мест в коде, и, таким образом, переходы позволяют уменьшить размер кода (сохраняя тело функции один раз). Однако, если функция используется только один или два раза, часто гораздо дешевле объявить эту функцию как `inline` или `inline_ref`. Модификатор `inline` помещает тело функции прямо в код родительской функции, в то время как `inline_ref` помещает код функции в ссылку (переход к ссылке все еще намного дешевле, чем поиск и переход к записи словаря).

### Словари

Словари в TON представлены как деревья (точнее, DAG) ячеек. Это означает, что если вы ищете, читаете или пишете в словарь, вам нужно разобрать все ячейки соответствующей ветви дерева. Это означает, что

- а) операции со словарями не фиксированы в стоимости газа (так как размер и количество узлов в ветви зависят от данного словаря и ключа)
- б) целесообразно оптимизировать использование словаря, используя специальные инструкции, такие как `replace` вместо `delete` и `add`
- в) разработчик должен знать об операциях итерации (таких как next и prev), а также об операциях `min_key`/`max_key`, чтобы избежать ненужной итерации по всему словарю

### Операции со стеком

Обратите внимание, что FunC манипулирует записями стека под капотом. Это означает, что код:

```cpp
(int a, int b, int c) = some_f();
return (c, b, a);
```

будет транслироваться в несколько инструкций, которые изменяют порядок элементов в стеке.

Когда количество записей стека значительно (10+), и они активно используются в разных порядках, расходы на операции со стеком могут стать существенными.

## Плата за пересылку

Внутренние сообщения определяют `ihr_fee` в Toncoin, которая вычитается из стоимости, прикрепленной к сообщению, и присуждается валидаторам целевого шардчейна, если они включают сообщение через механизм IHR. `fwd_fee` — это исходная общая плата за пересылку, уплачиваемая с использованием механизма HR; она автоматически вычисляется из [24 и 25 параметров конфигурации](/v3/documentation/network/configs/blockchain-configs#param-24-and-25) и размера сообщения на момент его генерации. Обратите внимание, что общая стоимость, переносимая вновь созданным внутренним исходящим сообщением, равна сумме стоимости, `ihr_fee` и `fwd_fee`. Эта сумма вычитается из баланса исходного аккаунта. Из этих компонентов только значение `ihr_fee` зачисляется на целевой аккаунт при доставке сообщения. `fwd_fee` собирается валидаторами на пути HR от источника до пункта назначения, а `ihr_fee` либо собирается валидаторами целевого шардчейна (если сообщение доставляется через IHR), либо зачисляется на конечный аккаунт.

### IHR

:::tip
На данный момент (ноябрь 2024 г.) [IHR](/v3/documentation/smart-contracts/shards/infinity-sharding-paradigm#messages-and-instant-hypercube-routing-instant-hypercube-routing) не реализован, и если вы установите `ihr_fee` на ненулевое значение, оно всегда будет добавлено к значению сообщения при получении. На данный момент нет практических причин делать это.
:::

### Формула

```cpp
// In_msg and Ext_msg are using the same method of calculation
// It is called import_fee or in_fwd_fee for the Ext_msg
// https://github.com/ton-blockchain/ton/blob/7151ff26279fef6dcfa1f47fc0c5b63677ae2458/crypto/block/transaction.cpp#L2071-L2090

// bits in the root cell of a message are not included in msg.bits (lump_price pays for them)
msg_fwd_fees = (lump_price
             + ceil(
                (bit_price * msg.bits + cell_price * msg.cells) / 2^16)
             );

ihr_fwd_fees = ceil((msg_fwd_fees * ihr_price_factor) / 2^16);

total_fwd_fees = msg_fwd_fees + ihr_fwd_fees; // ihr_fwd_fees - is 0 for external messages
```

:::info ВАЖНО

`fwd_fee` = `msg_fwd_fees` - `action_fee` = 266669 nanoton = 0,000266669 TON
:::

## Плата за действие

Плата за действие вычитается из баланса исходного аккаунта во время обработки списка действий, которая происходит после фазы вычислений. Фактически, единственное действие, за которое вы платите плату за действие, это `SENDRAWMSG`. Другие действия, такие как `RAWRESERVE` или `SETCODE`, не влекут за собой никаких комиссий во время фазы действия.

```cpp
action_fee = floor((msg_fwd_fees * first_frac)/ 2^16);  //internal

action_fee = msg_fwd_fees;  //external
```

[`first_frac`](/v3/documentation/network/configs/blockchain-configs#param-24-and-25) является частью параметров 24 и 25 (для мастерчейна и воркчейна) блокчейна TON. В настоящее время оба установлены на значение 21845, что означает, что `action_fee` составляет примерно треть от `msg_fwd_fees`. В случае внешнего действия сообщения `SENDRAWMSG`, `action_fee` равен `msg_fwd_fees`.

:::tip
Remember that an action register can contain up to 255 actions, which means that all formulas related to `fwd_fee` and `action_fee` will be computed for each `SENDRAWMSG` action, resulting in the following sum:

```cpp
total_fees = sum(action_fee) + sum(total_fwd_fees);
```

:::

Начиная с четвертой [глобальной версии](https://github.com/ton-blockchain/ton/blob/master/doc/GlobalVersions.md) TON, если действие "отправить сообщение" не выполняется, аккаунт должен оплатить обработку ячеек сообщения, называемую `action_fine`.

```cpp
fine_per_cell = floor((cell_price >> 16) / 4)

max_cells = floor(remaining_balance / fine_per_cell)

action_fine = fine_per_cell * min(max_cells, cells_in_msg);
```

## Файл конфигурации платы

Все платы указаны в nanoton или nanoton, умноженных на 2^16, чтобы [сохранить точность при использовании целого числа](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#forward-fees) и могут быть изменены. Файл конфигурации отображает текущую стоимость платы.

- storage_fees = [p18](https://tonviewer.com/config#18)
- in_fwd_fees = [p24](https://tonviewer.com/config#24), [p25](https://tonviewer.com/config#25)
- computation_fees = [p20](https://tonviewer.com/config#20), [p21](https://tonviewer.com/config#21)
- action_fees = [p24](https://tonviewer.com/config#24), [p25](https://tonviewer.com/config#25)
- out_fwd_fees = [p24](https://tonviewer.com/config#24), [p25](https://tonviewer.com/config#25)

:::info
[A direct link to the mainnet live config file](https://tonviewer.com/config)

В образовательных целях пример старого
:::

## Ссылки

- На основе @thedailyton [статья](https://telegra.ph/Fees-calculation-on-the-TON-Blockchain-07-24) от 24.07\*

## См. также

- [Обзор комиссий TON](/v3/documentation/smart-contracts/transaction-fees/fees)
- [Транзакции и фазы](/v3/documentation/tvm/tvm-overview#transactions-and-phases)
- [Расчет комиссий](/v3/guidelines/smart-contracts/fee-calculation)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/fees.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/fees.md
================================================
# Комиссии за транзакции

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Каждый пользователь TON должен иметь в виду, что *комиссия зависит от многих факторов*.

## Газ

Все [вычислительные расходы](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#computation-fees) выражаются в единицах газа и фиксируются в определённом объёме газа.

Цена единицы газа определяется [конфигурацией сети](https://tonviewer.com/config#20) и может быть изменена только по консенсусу валидаторов. Обратите внимание, что, в отличие от других систем, пользователь не может задать собственную цену на газ, и рынка комиссий не существует.

Текущие настройки в basechain: 1 единица газа стоит 400 нанотон.

```cpp
1 gas = 26214400 / 2^16 nanotons = 0,000 000 4 TON
```

Текущие настройки в masterchain: 1 единица газа стоит 10 000 нанотон.

```cpp
1 gas = 655360000 / 2^16 nanotons = 0,000 01 TON
```

### Средняя стоимость транзакции

> **TLDR:** Сегодня базовая транзакция стоит около **~0.0025 TON**

Даже если цена TON увеличится в 100 раз, транзакции останутся ультрадешёвыми — около $0.01. узнайте, почему им это выгодно - [читайте, почему они заинтересованы в этом](#gas-changing-voting-process).

:::info
Текущее количество газа указано в [параметре 20](https://tonviewer.com/config#20) и [параметре 21](https://tonviewer.com/config#21) конфигурации сети для masterchain и basechain соответственно.
:::

### Процесс голосования за изменение газа

Комиссия за газ, как и многие другие параметры TON, настраивается и может быть изменена с помощью специального голосования в основной сети.

Для изменения любого параметра требуется 66% голосов валидаторов.

#### Может ли газ стоить дороже?

> *Значит ли это, что однажды цена на газ может вырасти в 1000 раз или больше?*

Технически да, но фактически нет.

Валидаторы получают небольшую плату за обработку транзакций, и повышение комиссий приведёт к снижению количества транзакций, что сделает процесс валидации менее выгодным.

### Как рассчитываются комиссии?

Комиссии в TON сложно рассчитать заранее, так как их размер зависит от времени выполнения транзакции, статуса аккаунта, содержимого и размера сообщения, настроек сети блокчейна и множества других переменных, которые нельзя определить до отправки транзакции.

Поэтому даже NFT-маркеты обычно берут дополнительное количество TON (*~1 TON*) и возвращают (*`1 - transaction_fee`*) позже.

:::info
Each contract should check incoming messages for the amount of TON attached to ensure it is enough to cover the fees.

Ознакомьтесь с обзором [обзором низкоуровневых комиссий](/v3/documentation/smart-contracts/transaction-fees/fees-low-level), чтобы узнать больше о формулах для расчета комиссий и [рассвете комиссий](/v3/guidelines/smart-contracts/fee-calculation), чтобы понять, как рассчитывать комиссии в контрактах FunC с использованием новых опкодов TVM.
:::

Давайте подробнее разберёмся, как комиссии работают в сети TON.

## Базовая формула расчёта комиссий

Комиссии в TON рассчитываются по следующей формуле:

```cpp
transaction_fee = storage_fees
                + in_fwd_fees // also named import_fee
                + computation_fees
                + action_fees
                + out_fwd_fees
```

```jsx live
// Welcome to LIVE editor!
// feel free to change any variables
// Check https://retracer.ton.org/?tx=b5e14a9c4a4e982fda42d6079c3f84fa48e76497a8f3fca872f9a3737f1f6262

function FeeCalculator() {
  // https://tonviewer.com/config#25
  const lump_price = 400000;
  const bit_price = 26214400;
  const cell_price = 2621440000;
  const ihr_price_factor = 98304;
  const first_frac = 21845;
  const nano = 10 ** -9;
  const bit16 = 2 ** 16;

  const ihr_disabled = 0; // First of all define is ihr gonna be counted

  let fwd_fee =
    lump_price + Math.ceil((bit_price * 0 + cell_price * 0) / bit16);

  if (ihr_disabled) {
    var ihr_fee = 0;
  } else {
    var ihr_fee = Math.ceil((fwd_fee * ihr_price_factor) / bit16);
  }

  let total_fwd_fees = fwd_fee + ihr_fee;
  let gas_fees = 0.0011976; // Gas fees out of scope here
  let storage_fees = 0.000000003; // And storage fees as well
  let total_action_fees = +((fwd_fee * first_frac) / bit16).toFixed(9);
  let import_fee =
    lump_price + Math.ceil((bit_price * 528 + cell_price * 1) / bit16);
  let total_fee =
    gas_fees + storage_fees + total_action_fees * nano + import_fee * nano;

  return (
    <div>
      <p> Total fee: {+total_fee.toFixed(9)} TON</p>
      <p> Action fee: {+(total_action_fees * nano).toFixed(9)} TON </p>
      <p> Fwd fee: {+(total_fwd_fees * nano).toFixed(9)} TON </p>
      <p> Import fee: {+(import_fee * nano).toFixed(9)} TON </p>
      <p> IHR fee: {+(ihr_fee * nano).toFixed(9)} TON </p>
    </div>
  );
}
```

## Элементы комиссии за транзакцию

- `storage_fees` - это сумма, которую вы платите за хранение смарт-контракта в блокчейне. Фактически, вы платите за каждую секунду хранения смарт-контракта в блокчейне.
  - *Пример*: ваш кошелёк TON - это тоже смарт-контракт, и он платит комиссию за хранение каждый раз, когда вы получаете или отправляете транзакцию. Подробнее о [расчёте комиссии за хранение](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#storage-fee).
- `in_fwd_fees` - это плата за импорт сообщений только из внешних источников, например, `external` сообщений. Каждый раз, когда вы совершаете транзакцию, её необходимо доставить валидаторам для обработки. Для обычных сообщений от контракта к контракту эта плата не взимается. Чтобы узнать больше о входящих сообщениях, прочтите [документацию TON Blockchain](https://docs.ton.org/tblkch.pdf).
  - *Пример*: каждая транзакция, которую вы совершаете через приложение-кошелёк (например, Tonkeeper), должна сначала распределиться между узлами валидации.
- `computation_fees` - это плата за выполнение кода в виртуальной машине. Чем больше код, тем выше плата.
  - *Пример*: каждый раз, когда вы отправляете транзакцию через кошелёк (который является смарт-контрактом), вы выполняете код вашего кошелька и платите за это.
- `action_fees` - это плата за отправку исходящих сообщений смарт-контрактом, обновление кода смарт-контракта, библиотек и т. д.
- `out_fwd_fees` - это плата за отправку сообщений за пределы блокчейна TON для взаимодействия с внешними сервисами (например, логами) и другими блокчейнами.

## FAQ

Вот самые часто задаваемые вопросы пользователями TON:

### Комиссия за отправку TON?

Средняя комиссия за отправку любого количества TON составляет 0.0055 TON.

### Комиссия за отправку Jettons?

Средняя комиссия за отправку любого количества пользовательских Jettons составляет 0.037 TON.

### Стоимость минта NFT?

Средняя комиссия за минт одного NFT составляет 0.08 TON.

### Стоимость хранения данных в TON?

Хранение 1 МБ данных в течение года в TON обойдётся в 6.01 TON. Учтите, что обычно вам не нужно хранить большие объёмы данных on-chain. Если вам необходимо децентрализованное хранение, воспользуйтесь [TON Storage](/v3/guidelines/web3/ton-storage/storage-daemon).

### Можно ли отправить транзакцию без газа?

В TON возможны транзакции без использования газа с помощью [wallet v5](/v3/documentation/smart-contracts/contracts-specs/wallet-contracts#preparing-for-gasless-transactions) - ретранслятора, который оплачивает комиссию за транзакцию.

### Как рассчитать?

В блокчейне TON есть статья о [расчете комиссий](/v3/guidelines/smart-contracts/fee-calculation).

## Ссылки

- Основано на [статье @thedailyton](https://telegra.ph/Commissions-on-TON-07-22), изначально написанной [menschee](https://github.com/menschee)\*

## См. также

- ["Обзор низкоуровневых комиссий"](/v3/documentation/smart-contracts/transaction-fees/fees-low-level) - ознакомьтесь с формулами для расчёта комиссий.
- [Функция смарт-контракта для расчета forward fees в FunC](https://github.com/ton-blockchain/token-contract/blob/main/misc/forward-fee-calc.fc)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/forward-fees.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/smart-contracts/transaction-fees/forward-fees.md
================================================
# Комиссии за пересылку

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В общем случае, если смарт-контракт хочет отправить запрос другому смарт-контракту, он должен заплатить за отправку внутреннего сообщения в смарт-контракт назначения (плата за пересылку сообщений), обработку этого сообщения в пункте назначения (плата за газ) и отправку ответа обратно, если требуется (плата за пересылку сообщений).

:::note
В большинстве случаев отправитель прикрепляет небольшое количество Toncoin (например, один Toncoin) к внутреннему сообщению (достаточное для оплаты обработки этого сообщения) и устанавливает его флаг "возврата" (т. е. отправляет внутреннее сообщение, допускающее возврат); получатель возвращает неиспользованную часть полученного значения с ответом (вычитая из него плату за пересылку сообщений). Обычно это достигается путем вызова `SENDRAWMSG` с `mode = 64` (см. Приложение A документации TON VM).
:::

Если получатель не может проанализировать полученное сообщение и завершает работу с ненулевым кодом завершения (например, из-за исключения десериализации необработанной ячейки), сообщение будет автоматически "возвращено" обратно отправителю, при этом флаг "отклонено" будет снят, а флаг "возвращено" установлен. Тело возвращенного сообщения будет содержать 32-битное значение `0xffffffffff`, за которым последует 256-битное значение исходного сообщения. Важно проверить флаг "возвращенного" входящих внутренних сообщений перед разбором поля `op` в смарт-контракте и обработкой соответствующего запроса (в противном случае существует риск того, что запрос, содержащийся в возвращенном сообщении, будет обработан его первоначальным отправителем как новый отдельный запрос). Если установлен флаг "отклонено", специальный код может определить, какой запрос завершился ошибкой (например, путем десериализации `op` и `query_id` из возвращенного сообщения) и предпринять соответствующие действия. Более простой смарт-контракт мог бы просто игнорировать все возвращенные сообщения (завершаться с нулевым кодом завершения, если установлен флаг "возвращено"). Обратите внимание, что флаг "отклонено" переписывается во время отправки, поэтому его невозможно подделать, и можно с уверенностью предположить, что если сообщение пришло с флагом "отклонено", то это результат отклонения какого-либо сообщения, отправленного получателем.

С другой стороны, получатель может успешно проанализировать входящий запрос и обнаружить, что запрошенный метод `op` не поддерживается или что выполнено другое условие ошибки. Затем следует отправить ответ с `op`, равным `0xffffffff` или другим подходящим значением, используя `SENDRAWMSG` с `mode = 64`, как указано выше.

В некоторых ситуациях отправитель хочет как передать отправителю некоторое значение, так и получить либо подтверждение, либо сообщение об ошибке. Например, смарт-контракт валидатора выборов получает запрос на участие в выборах вместе со ставкой в ​​качестве прикрепленного значения. В таких случаях имеет смысл прикрепить, скажем, один дополнительный Toncoin к предполагаемому значению. Если произошла ошибка (например, ставка не может быть принята по какой-либо причине), вся полученная сумма (за вычетом комиссии за обработку) должна быть возвращена отправителю вместе с сообщением об ошибке (например, с помощью `SENDRAWMSG` с `mode = 64`, как объяснялось ранее). В случае успеха создается сообщение с подтверждением и обратно отправляется ровно один Toncoin (с комиссией за передачу сообщения, вычитаемой из этого значения; это `mode = 1` для `SENDRAWMSG`).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/ton-documentation.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/ton-documentation.mdx
================================================
import Button from '@site/src/components/button'
import Player from '@site/src/components/player'

# Документация TON

Добро пожаловать в официальную документацию по разработке на TON Blockchain!

Здесь вы найдете всю необходимую информацию для разработки, тестирования и развертывания приложений на блокчейне TON.

Этот проект создается совместно с сообществом и имеет открытый исходный код. Мы всегда рады новым участникам. Всю документацию можно редактировать на GitHub. Инструкция и формат работы представлен по [ссылке](/v3/contribute).

- Серия _TON Hello World_ содержит подробные пошаговые руководства по кошелькам, смарт-контрактам, мини-приложениям, а также тестированию и отладке смарт-контрактов на TON
- _Начало работы с TON_ — пошаговое руководство и видеоуроки по работе с блокчейном TON

<Button href="https://helloworld.tonstudio.io/01-wallet/"
        colorType="primary" sizeType={'sm'}>

TON Hello World

</Button>

<Button href="/v3/guidelines/get-started-with-ton" colorType={'secondary'} sizeType={'sm'}>

Начало работы с TON

</Button>

### Основы блокчейна с TON

Этот курс познакомит вас с основами блокчейна, фокусируя внимание на получении практических навыков в экосистеме TON. Вы изучите, как функционирует блокчейн и как он применяется в различных областях.

<Button href="https://stepik.org/course/201294/promo"
        colorType={'primary'} sizeType={'sm'}>

Пройти курс по основам блокчейна (на английском)

</Button>

<Button href="https://stepik.org/course/200976/promo"
        colorType={'secondary'} sizeType={'sm'}>

На китайском

</Button>

<Button href="https://stepik.org/course/202221/promo"
        colorType={'secondary'} sizeType={'sm'}>

На русском

</Button>

### Курс по TON

Мы рады представить **курс по блокчейну TON** — полное руководство для разработчиков, желающих научиться создавать смарт-контракты и децентрализованные приложения на TON. Курс разработан в интерактивном формате, чтобы обучение было максимально увлекательным и полезным.

Он состоит из **9 модулей** и охватывает основы блокчейна TON, язык программирования FunC и виртуальную машину TON (TVM).

<Button href="https://stepik.org/course/176754/promo"
        colorType={'primary'} sizeType={'sm'}>

Пройти курс по блокчейну TON (на английском)

</Button>

<Button href="https://stepik.org/course/201638/promo"
        colorType={'secondary'} sizeType={'sm'}>

На китайском

</Button>

<Button href="https://stepik.org/course/201855/promo"
        colorType={'secondary'} sizeType={'sm'}>

На русском

</Button>

## Модули разработки

Если вы только начинаете разрабатывать на блокчейне TON, рекомендуем начать с основ и последовательно изучить следующие темы:

### Основные концепции

- [The Open Network](/v3/concepts/dive-into-ton/introduction) - Подробный обзор блокчейна TON
- [Блокчейн блокчейнов](/v3/concepts/dive-into-ton/ton-blockchain/blockchain-of-blockchains) - Простое и понятное описание блокчейна TON
- [Адреса смарт-контрактов](/v3/documentation/smart-contracts/addresses) - Подробное описание адресов
- [Ячейки как структура данных](/v3/concepts/dive-into-ton/ton-blockchain/cells-as-data-storage) - Подробное описание структур данных
- [TON Networking](/v3/concepts/dive-into-ton/ton-blockchain/ton-networking) - Подробный обзор одноранговых протоколов на TON
- [TON Virtual Machine (TVM)](/v3/documentation/tvm/tvm-overview) - Подробный обзор виртуальной машины TON
- [Транзакции и фазы](/v3/documentation/tvm/tvm-overview#transactions-and-phases) - Подробное описание транзакций и фаз
- [Транзакционные комиссии](/v3/documentation/smart-contracts/transaction-fees/fees) - Подробное описание комиссий за транзакции

### Инфраструктура

- [Типы узлов](/v3/documentation/infra/nodes/node-types) - Подробное описание типов узлов
- [Запуск полного узла](/v3/guidelines/nodes/running-nodes/full-node) - Детальное руководство по запуску узла
- [TON DNS и сайты](/v3/guidelines/web3/ton-dns/dns) - Подробное описание TON DNS и сайтов
- [TON Storage](/v3/guidelines/web3/ton-storage/storage-daemon) - Подробное описание TON Storage

### Дополнительные ресурсы

- [**FAQ**](/v3/documentation/faq) - Часто задаваемые вопросы
- [Документация по FunC](/v3/documentation/smart-contracts/func/overview)
- [Документация по Fift](/v3/documentation/smart-contracts/fift/overview)

## Разработка смарт-контрактов

Смарт-контракты — это строительные блоки децентрализованных приложений (DApps) на блокчейне TON. Если вы хотите разрабатывать собственные DApps, вам важно понимать, как работают смарт-контракты.

<Button href="/v3/documentation/smart-contracts/overview"
        colorType="primary" sizeType={'sm'}>

Вводная статья

</Button>

<Button href="/v3/documentation/smart-contracts/getting-started/javascript" colorType={'secondary'} sizeType={'sm'}>

Использование Blueprint

</Button>

<br></br><br></br>

Следующие ресурсы содержат ценную информацию для разработки смарт-контрактов TON:

- [TON Hello World: пошаговое руководство по написанию вашего первого смарт-контракта](https://helloworld.tonstudio.io/02-contract/) — доступное и краткое объяснение основ работы с JS
- [Как работать со смарт-контрактами кошелька](/v3/guidelines/smart-contracts/howto/wallet) — подробные и тщательные объяснения основ смарт-контрактов с использованием JS и GO
- [Изучите смарт-контракты на примерах](/v3/documentation/smart-contracts/contracts-specs/examples) (FunC, Fift)
- [Speed ​​Run TON](/v3/documentation/smart-contracts/contracts-specs/examples) — 6 интерактивных задач и пошаговых руководств для изучения разработки смарт-контрактов

## Разработка DApp

Децентрализованные приложения (DApps) — это приложения, которые работают в одноранговой сети компьютеров (например, в блокчейне TON), а не на одном сервере. Они напоминают традиционные веб-приложения, но функционируют на базе блокчейна. Это означает, что DApps децентрализованы, то есть не контролируются какой-либо одной организацией.

<Button href="/v3/guidelines/dapps/overview/" colorType={'primary'} sizeType={'sm'}>

Вводная статья

</Button>

### Разработка DeFi

- [TON Connect](/v3/guidelines/ton-connect/overview) — инструмент для интеграции и аутентификации DApps
- [Обработка платежей Off-chain](/v3/guidelines/dapps/asset-processing/payments-processing) — примеры и концепции
- [Работа с жетонами TON](/v3/guidelines/dapps/asset-processing/jettons) — примеры и концепции
- [Взаимозаменяемые (FT) / невзаимозаменяемые (NFT) токены](/v3/documentation/dapps/defi/tokens) — смарт-контракты, примеры, инструменты

Начните разработку DApps с подробного пошагового руководства:

- [TON Hello World: пошаговое руководство по созданию вашего первого веб-клиента](https://helloworld.tonstudio.io/03-client/)

### API и SDK

- [API](/v3/guidelines/dapps/apis-sdks/api-types)
- [SDK](/v3/guidelines/dapps/apis-sdks/sdk)

## Часто задаваемые вопросы

Ознакомьтесь с [ответами на часто задаваемые вопросы](/v3/documentation/faq).



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/changelog/tvm-upgrade-2023-07.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/changelog/tvm-upgrade-2023-07.md
================================================
# Обновление TVM 2023.07

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::tip
Это обновление [запущено](https://t.me/tonblockchain/223) в основной сети с декабря 2023 года.
:::

# c7

**c7** — это регистр, в котором хранится локальная контекстная информация, необходимая для выполнения контракта
(например, время, lt, конфигурации сети и т. д.).

**c7** кортеж расширен с 10 до 14 элементов:

- **10**: `cell` с кодом самого смарт-контракта.
- **11**: `[integer, maybe_dict]`: значение ТON входящего сообщения, дополнительные валюты.
- **12**: `integer`, сборы, собранные на этапе хранения.
- **13**: `tuple` с информацией о предыдущих блоках.

**10** В настоящее время код смарт-контракта представлен на уровне TVM только как исполняемое продолжение
и не может быть преобразован в ячейку. Этот код часто используется для авторизации соседнего контракта
того же типа, например jetton-wallet авторизует jetton-wallet. На данный момент нам нужно
явно хранить ячейку кода в хранилище, что делает хранилище и init_wrapper более громоздкими, чем они могли бы быть.
Использование **10** для кода совместимо с обновлением Everscale tvm.

**11** В настоящее время значение входящего сообщения представлено в стеке после инициализации TVM, поэтому при необходимости во время выполнения
нужно либо сохранить его в глобальной переменной, либо передать через локальные переменные
(на уровне funC это выглядит как дополнительный аргумент `msg_value` во всех функциях).
Поместив его в элемент **11**, мы повторим поведение баланса контракта: он представлен как в стеке, так и в c7.

**12** В настоящее время единственный способ рассчитать плату за хранение — это сохранить баланс в предыдущей транзакции,
как-то рассчитать потребление газа в предыдущей транзакции, а затем сравнить с текущим балансом за вычетом значения сообщения.
Между тем, часто требуется учитывать плату за хранение.

**13** В настоящее время нет способа извлечь данные о предыдущих блоках. Одной из ключевых особенностей TON является то, что каждый структура представляет собой дружественный к доказательству Меркла пакет (дерево) ячеек, более того, TVM также дружественна к ячейкам и доказательсву Меркла.
Таким образом, если мы включим информацию о блоках в контекст TVM, станет возможным реализовать множество не требующих доверия сценариев: контракт A может проверять транзакции по контракту B (без сотрудничества с B), можно восстановить разорванные цепочки сообщений (когда recovery-contract получает и проверяет доказательства того, что некоторая транзакция произошла, но была отменена), также требуется знание хэшей блоков мастерчейна для выполнения некоторых функций проверки onchain.

Идентификаторы блоков представлены в следующем формате:

```
[ wc:Integer shard:Integer seqno:Integer root_hash:Integer file_hash:Integer ] = BlockId;
[ last_mc_blocks:[BlockId0, BlockId1, ..., BlockId15]
  prev_key_block:BlockId ] : PrevBlocksInfo
```

Включены идентификаторы последних 16 блоков мастерчейна (или меньше, если seqno мастерчейна меньше 16), а также последний ключевой блок.
Включение данных о шардблоках может вызвать некоторые проблемы с доступностью данных (из-за событий слияния/разделения),
это не обязательно требуется (так как любое событие/данные могут быть подтверждены с помощью блоков мастерчейна), поэтому мы решили не включать их.

# Новые коды операций

Основное правило при выборе стоимости газа для новых кодов операций заключается в том, что она не должна быть меньше обычной (рассчитанной по длине кода операции) и должна занимать не более 20 нс на единицу газа.

## Коды операций для работы с новыми значениями c7

26 газа для каждого, за исключением `PREVMCBLOCKS` и `PREVKEYBLOCK` (34 газа).

| <br/>Синтаксис Fift   | <br/>Стек | <br/>Описание                                                                      |
| :-------------------- | :-------- | :--------------------------------------------------------------------------------- |
| `MYCODE`              | *`- c`*   | Извлекает код смарт-контракта из c7                                                |
| `INCOMINGVALUE`       | *`- t`*   | Извлекает значение входящего сообщения из c7                                       |
| `STORAGEFEES`         | *`- i`*   | Извлекает значение платы за фазу хранения из c7                                    |
| `PREVBLOCKSINFOTUPLE` | *`- t`*   | Извлекает PrevBlocksInfo: `[last_mc_blocks, prev_key_block]` из c7 |
| `PREVMCBLOCKS`        | *`- t`*   | Извлекает только `last_mc_blocks`                                                  |
| `PREVKEYBLOCK`        | *`- t`*   | Извлекает только `prev_key_block`                                                  |
| `GLOBALID`            | *`- i`*   | Извлекает `global_id` из 19 конфигурации сети                                      |

## Газ

| <br/>Синтаксис Fift | <br/>Стек | <br/>Описание                                                                                                                                |
| :------------------ | :-------- | :------------------------------------------------------------------------------------------------------------------------------------------- |
| `GASCONSUMED`       | *`- g_c`* | Возвращает газ, потребленный виртуальной машиной на данный момент (включая эту инструкцию).<br/>*26 газа* |

## Арифметика

Добавлены новые варианты [кода операции деления](/v3/documentation/tvm/instructions) (`A9mscdf`):
`d=0` берет одно дополнительное целое число из стека и добавляет его к промежуточному значению перед делением/rshift. Эти операции возвращают как частное, так и остаток (как `d=3`).

Также доступны тихие варианты (например, `QMULADDDIVMOD` или `QUIET MULADDDIVMOD`).

Если возвращаемые значения не вписываются в 257-разрядные целые числа или делитель равен нулю, при выполнении операции без прерывания возникает исключение переполнения целого числа. Операции без прерывания возвращают значение `NaN` вместо значения, которое не помещается (два `NaN`, если делитель равен нулю).

Стоимость газа равна 10 плюс длина опкода: 26 для большинства кодов операции, +8 для `LSHIFT#`/`RSHIFT#`, +8 для тихого режима.

| <br/>Синтаксис Fift   | <br/>Стек                                         |
| :-------------------- | :------------------------------------------------ |
| `MULADDDIVMOD`        | *`x y w z - q=floor((xy+w)/z) r=(xy+w)-zq`*       |
| `MULADDDIVMODR`       | *`x y w z - q=round((xy+w)/z) r=(xy+w)-zq`*       |
| `MULADDDIVMODC`       | *`x y w z - q=ceil((xy+w)/z) r=(xy+w)-zq`*        |
| `ADDDIVMOD`           | *`x w z - q=floor((x+w)/z) r=(x+w)-zq`*           |
| `ADDDIVMODR`          | *`x w z - q=round((x+w)/z) r=(x+w)-zq`*           |
| `ADDDIVMODC`          | *`x w y - q=ceil((x+w)/z) r=(x+w)-zq`*            |
| `ADDRSHIFTMOD`        | *`x w z - q=floor((x+w)/2^z) r=(x+w)-q*2^z`*      |
| `ADDRSHIFTMODR`       | *`x w z - q=round((x+w)/2^z) r=(x+w)-q*2^z`*      |
| `ADDRSHIFTMODC`       | *`x w z - q=ceil((x+w)/2^z) r=(x+w)-q*2^z`*       |
| `z ADDRSHIFT#MOD`     | *`x w - q=floor((x+w)/2^z) r=(x+w)-q*2^z`*        |
| `z ADDRSHIFTR#MOD`    | *`x w - q=round((x+w)/2^z) r=(x+w)-q*2^z`*        |
| `z ADDRSHIFTC#MOD`    | *`x w - q=ceil((x+w)/2^z) r=(x+w)-q*2^z`*         |
| `MULADDRSHIFTMOD`     | *`x y w z - q=floor((xy+w)/2^z) r=(xy+w)-q*2^z`*  |
| `MULADDRSHIFTRMOD`    | *`x y w z - q=round((xy+w)/2^z) r=(xy+w)-q*2^z`*  |
| `MULADDRSHIFTCMOD`    | *`x y w z - q=ceil((xy+w)/2^z) r=(xy+w)-q*2^z`*   |
| `z MULADDRSHIFT#MOD`  | *`x y w - q=floor((xy+w)/2^z) r=(xy+w)-q*2^z`*    |
| `z MULADDRSHIFTR#MOD` | *`x y w - q=round((xy+w)/2^z) r=(xy+w)-q*2^z`*    |
| `z MULADDRSHIFTC#MOD` | *`x y w - q=ceil((xy+w)/2^z) r=(xy+w)-q*2^z`*     |
| `LSHIFTADDDIVMOD`     | *`x w z y - q=floor((x*2^y+w)/z) r=(x*2^y+w)-zq`* |
| `LSHIFTADDDIVMODR`    | *`x w z y - q=round((x*2^y+w)/z) r=(x*2^y+w)-zq`* |
| `LSHIFTADDDIVMODC`    | *`x w z y - q=ceil((x*2^y+w)/z) r=(x*2^y+w)-zq`*  |
| `y LSHIFT#ADDDIVMOD`  | *`x w z - q=floor((x*2^y+w)/z) r=(x*2^y+w)-zq`*   |
| `y LSHIFT#ADDDIVMODR` | *`x w z - q=round((x*2^y+w)/z) r=(x*2^y+w)-zq`*   |
| `y LSHIFT#ADDDIVMODC` | *`x w z - q=ceil((x*2^y+w)/z) r=(x*2^y+w)-zq`*    |

## Операции со стеком

В настоящее время аргументы всех операций со стеком ограничены 256.
Это означает, что если стек становится глубже 256, становится трудно управлять глубокими элементами стека.
В большинстве случаев нет никаких причин для безопасности для этого ограничения, т. е. аргументы не ограничиваются, чтобы предотвратить слишком дорогие операции.
Для некоторых массовых операций со стеком, таких как `ROLLREV` (где время вычисления линейно зависит от значения аргумента), стоимость газа также линейно зависит от значения аргумента.

- Аргументы `PICK`, `ROLL`, `ROLLREV`, `BLKSWX`, `REVX`, `DROPX`, `XCHGX`, `CHKDEPTH`, `ONLYTOPX`, `ONLYX` теперь не ограничены.
- `ROLL`, `ROLLREV`, `REVX`, `ONLYTOPX` потребляют больше газа, когда аргументы большие: дополнительная стоимость газа составляет `max(arg-255,0)` (для аргумента меньше 256 потребление газа постоянно и соответствует текущему режиму)
- Для `BLKSWX` дополнительная стоимость составляет `max(arg1+arg2-255,0)` (это не соответствует текущему режиму, так как в настоящее время и `arg1`, и `arg2` ограничены 255).

## Хэши

В настоящее время в TVM доступны только две операции хэширования: вычисление хэша представления ячейки/среза и sha256 данных, но только до 127 байт (только столько данных помещается в одну ячейку).

Добавлено семейство операций `HASHEXT[A][R]_(HASH)`:

| <br/>Синтаксис Fift | <br/>Стек                | <br/>Описание                                                                                                 |
| :------------------ | :----------------------- | :------------------------------------------------------------------------------------------------------------ |
| `HASHEXT_(HASH)`    | *`s_1 ... s_n n - h`*    | Вычисляет и возвращает хэш объединения срезов (или сборщиков) `s_1...s_n`. |
| `HASHEXTR_(HASH)`   | *`s_n ... s_1 n - h`*    | То же самое, но аргументы приводятся в обратном порядке.                                      |
| `HASHEXTA_(HASH)`   | *`b s_1 ... s_n n - b'`* | Добавляет полученный хэш к строителю `b` вместо того, чтобы помещать его в стек.              |
| `HASHEXTAR_(HASH)`  | *`b s_n ... s_1 n - b'`* | Аргументы задаются в обратном порядке, добавляя хэш к строителю.                              |

Используются только биты из корневых ячеек `s_i`.

Каждый фрагмент `s_i` может содержать нецелое число байтов. Однако сумма битов всех фрагментов должна делиться на 8.
Обратите внимание, что TON использует порядок старших битов, поэтому при объединении двух фрагментов с нецелым числом байтов биты из первого фрагмента становятся старшими битами.

Расход газа зависит от количества хэшированных байтов и выбранного алгоритма. На каждый фрагмент потребляется дополнительно 1 единица газа.

Если параметр `[A]` не включен, результат хэширования будет возвращен в виде целого числа без знака, если оно соответствует 256 битам, или целого ряда целых чисел в противном случае.

Доступны следующие алгоритмы:

- `SHA256` - реализация openssl, 1/33 газа на байт, хеш составляет 256 бит.
- `SHA512` - реализация openssl, 1/16 газа на байт, хеш составляет 512 бит.
- `BLAKE2B` - реализация openssl, 1/19 газа на байт, хеш составляет 512 бит.
- `KECCAK256` - [реализация, совместимая с ethereum](http://keccak.noekeon.org/), 1/11 газа на байт, хеш составляет 256 бит.
- `KECCAK512` - [совместимая с ethereum реализация](http://keccak.noekeon.org/), 1/6 газа на байт, хэш составляет 512 бит.

Использование газа округляется в меньшую сторону.

## Крипто

В настоящее время доступен только один криптографический алгоритм - `CHKSIGN`: проверьте подпись Ed25519 хеша `h` для открытого ключа `k`.

- Для совместимости с блокчейнами предыдущего поколения, такими как Bitcoin и Ethereum, нам также необходимо проверить подписи `secp256k1`.
- Для современных криптографических алгоритмов абсолютный минимум - это сложение и умножение кривых.
- Для совместимости с Ethereum 2.0 PoS и некоторыми другими современными криптографическими алгоритмами нам нужна схема BLS-подписи на кривой bls12-381.
- Для некоторого защищенного оборудования требуется secp256r1 == P256 == prime256v1.

### secp256k1

Подписи Bitcoin/Ethereum. Использует [реализацию libsecp256k1](https://github.com/bitcoin-core/secp256k1).

| <br/>Синтаксис Fift | <br/>Стек                         | <br/>Описание                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :------------------ | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ECRECOVER`         | *`hash v r s - 0 или h x1 x2 -1`* | Восстанавливает открытый ключ из подписи, идентично операциям Bitcoin/Ethereum.<br/>Принимает 32-байтовый хэш как uint256 `hash`; 65-байтовая подпись как uint8 `v` и uint256 `r`, `s`.<br/>Возвращает `0` в случае неудачи, открытый ключ и `-1` в случае успеха.<br/>65-байтовый открытый ключ возвращается как uint8 `h`, uint256 `x1`, `x2`.<br/>*1526 газа* |

### secp256r1

Использует реализацию OpenSSL. Интерфейс похож на `CHKSIGNS`/`CHKSIGNU`. Совместимо с Apple Secure Enclave.

| <br/>Синтаксис Fift | <br/>Стек       | <br/>Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :------------------ | :-------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `P256_CHKSIGNS`     | *`d sig k - ?`* | Проверяет seck256r1-подпись `sig` части данных среза `d` и открытый ключ `k`. Возвращает -1 в случае успеха, 0 в случае неудачи.<br/>Открытый ключ представляет собой 33-байтовый срез (закодированный в соответствии с разделом 2.3.4, пункт 2 [SECG SEC 1](https://www.secg.org/sec1-v2.pdf)).<br/>Подпись `sig` представляет собой 64-байтовый срез (два 256-битных беззнаковых целых числа `r` и `s`).<br/>*3526 газа* |
| `P256_CHKSIGNU`     | *`h sig k - ?`* | То же самое, но подписанные данные представляют собой 32-байтовую кодировку 256-битного беззнакового целого числа `h`.<br/>*3526 газа*                                                                                                                                                                                                                                                                                                                                                                                                           |

### Ристретто

Расширенная документация доступна [здесь](https://ristretto.group/). Проще говоря, Curve25519 был разработан с учетом производительности, однако из-за симметрии некоторые элементы группы имеют несколько представлений. Более простые протоколы, такие как подписи Шнорра или Диффи-Хеллмана, применяют приемы на уровне протокола для смягчения некоторых проблем, но нарушают схемы вывода ключей и маскировки ключей. И эти приемы не масштабируются до более сложных протоколов, таких как Bulletproofs. Ристретто представляет собой арифметическое абстракцию поверх Curve25519 таким образом, что каждый элемент группы соответствует уникальной точке, что является требованием для большинства криптографических протоколов. Ристретто по сути является протоколом сжатия/распаковки для Curve25519, который предлагает необходимую арифметическую абстракцию. В результате криптопротоколы легко писать правильно, при этом извлекая выгоду из высокой производительности Curve25519.

Операции Ристретто позволяют вычислять операции кривой на Curve25519 (в обратном порядке это не так), таким образом мы можем считать, что добавляем как Ристретто, так и операции по кривой Curve25519 за один шаг.

Используется реализация [libsodium](https://github.com/jedisct1/libsodium/).

Все точки ristretto-255 представлены в TVM как 256-битные целые числа без знака.
При некорректных операциях генерируется `range_chk`, если аргументы не являются допустимыми закодированными точками.
Нулевая точка представлена в виде целого числа `0`.

| <br/>Синтаксис Fift | <br/>Стек              | <br/>Описание                                                                                                                                                           |
| :------------------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `RIST255_FROMHASH`  | *`h1 h2 - x`*          | Детерминированно генерирует допустимую точку `x` из 512-битного хеша (заданного как два 256-битных целых числа).<br/>*626 газа*      |
| `RIST255_VALIDATE`  | *`x -`*                | Проверяет, что целое число `x` является допустимым представлением некоторой точки кривой. Выдает `range_chk` при ошибке.<br/>*226 газа* |
| `RIST255_ADD`       | *`x y - x+y`*          | Сложение двух точек на кривой.<br/>*626 газа*                                                                                                           |
| `RIST255_SUB`       | *`x y - x-y`*          | Вычитание двух точек на кривой.<br/>*626 газа*                                                                                                          |
| `RIST255_MUL`       | *`x n - x*n`*          | Умножает точку `x` на скаляр `n`.<br/>Допустимо любое `n`, включая отрицательное.<br/>*2026 газа*                                       |
| `RIST255_MULBASE`   | *`n - g*n`*            | Умножает точку генератора `g` на скаляр `n`.<br/>Допустимо любое `n`, включая отрицательное.<br/>*776 газа*                             |
| `RIST255_PUSHL`     | *`- l`*                | Выводит целое число `l=2^252+27742317777372353535851937790883648493`, которое соответствует порядку в группе.<br/>*26 газа*                             |
| `RIST255_QVALIDATE` | *`x - 0 или -1`*       | Тихая версия `RIST255_VALIDATE`.<br/>*234 газа*                                                                                                         |
| `RIST255_QADD`      | *`x y - 0 или x+y -1`* | Тихая версия `RIST255_ADD`. <br/>*634 газа*                                                                                                             |
| `RIST255_QSUB`      | *`x y - 0 или x-y -1`* | Тихая версия `RIST255_SUB`.<br/>*634 газа*                                                                                                              |
| `RIST255_QMUL`      | *`x n - 0 или x*n -1`* | Тихая версия `RIST255_MUL`.<br/>*2034 газа*                                                                                                             |
| `RIST255_QMULBASE`  | *`n - 0 или g*n -1`*   | Тихая версия `RIST255_MULBASE`.<br/>*784 газа*                                                                                                          |

### BLS12-381

Операции на кривой BLS12-381, удобной для сопряжения. Используется реализация [BLST](https://github.com/supranational/blst). Также, операции для схемы подписи BLS, которая основана на этой кривой.

Значения BLS представлены в TVM следующим образом:

- G1-точки и открытые ключи: 48-байтовый срез.
- G2-точки и подписи: 96-байтовый срез.
- Элементы поля FP: 48-байтовый срез.
- Элементы поля FP2: 96-байтовый срез.
- Сообщения: срез. Количество бит должно делиться на 8.

Когда входное значение является точкой или элементом поля, срез может иметь более 48/96 байт. В этом случае берутся только первые 48/96 байт. Если в срезе меньше байтов (или если размер сообщения не делится на 8), выдается исключение переполнения ячейки.

#### Высокоуровневые операции

Это высокоуровневые операции для проверки подписей BLS.

| <br/>Синтаксис Fift        | <br/>Стек                                  | <br/>Описание                                                                                                                                                                                                                                          |
| :------------------------- | :----------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `BLS_VERIFY`               | *`pk msg sgn - bool`*                      | Проверяет подпись BLS, возвращает true в случае успеха, в противном случае false.<br/>*61034 газа*                                                                                                                                     |
| `BLS_AGGREGATE`            | *`sig_1 ... sig_n n - sig`*                | Агрегирует подписи. `n>0`. Выдает исключение, если `n=0` или если какой-либо `sig_i` не является допустимой подписью.<br/>*`gas=n*4350-2616`*                                                          |
| `BLS_FASTAGGREGATEVERIFY`- | *`pk_1 ... pk_n n msg sig - bool`*         | Проверяет агрегированную подпись BLS для ключей `pk_1...pk_n` и сообщения `msg`. Возвращает true в случае успеха, в противном случае false. Возвращает false, если `n=0`.<br/>*`gas=58034+n*3000`*     |
| `BLS_AGGREGATEVERIFY`      | *`pk_1 msg_1 ... pk_n msg_n n sgn - bool`* | Проверяет агрегированную подпись BLS для пар ключ-сообщение `pk_1 msg_1...pk_n msg_n`. Возвращает true в случае успеха, в противном случае false. Верните false, если `n=0`.<br/>*`gas=38534+n*22500`* |

Инструкции `VERIFY` не выбрасывают исключения при недействительных подписях и открытых ключах (за исключением исключений, связанных с переполнением ячеек), вместо этого они возвращают false.

#### Низкоуровневые операции

Это арифметические операции над элементами группы.

| <br/>Синтаксис Fift | <br/>Стек                                       | <br/>Описание                                                                                                                                                                                                                                                                                             |
| :------------------ | :---------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `BLS_G1_ADD`        | *`x y - x+y`*                                   | Сложение на G1.<br/>*3934 газа*                                                                                                                                                                                                                                                           |
| `BLS_G1_SUB`        | *`x y - x-y`*                                   | Вычитание на G1.<br/>*3934 газа*                                                                                                                                                                                                                                                          |
| `BLS_G1_NEG`        | *`x - -x`*                                      | Отрицание на G1.<br/>*784 газа*                                                                                                                                                                                                                                                           |
| `BLS_G1_MUL`        | *`x s - x*s`*                                   | Умножает точку G1 `x` на скаляр `s`.<br/>Допустим любой `s`, включая отрицательный.<br/>*5234 газа*                                                                                                                                                                       |
| `BLS_G1_MULTIEXP`   | *`x_1 s_1 ... x_n s_n n - x_1*s_1+...+x_n*s_n`* | Вычисляет `x_1*s_1+...+x_n*s_n` для точек G1 `x_i` и скаляров `s_i`. Возвращает нулевую точку, если `n=0`.<br/>Любое `s_i` допустимо, включая отрицательное.<br/>*`gas=11409+n*630+n/floor(max(log2(n),4))*8820`*                                         |
| `BLS_G1_ZERO`       | *`- zero`*                                      | Помещает нулевую точку в G1.<br/>*34 газа*                                                                                                                                                                                                                                                |
| `BLS_MAP_TO_G1`     | *`f - x`*                                       | Преобразует элемент FP `f` в точку G1.<br/>*2384 газа*                                                                                                                                                                                                                                    |
| `BLS_G1_INGROUP`    | *`x - bool`*                                    | Проверяет, что срез `x` представляет допустимый элемент G1.<br/>*2984 газа*                                                                                                                                                                                                               |
| `BLS_G1_ISZERO`     | *`x - bool`*                                    | Проверяет, что точка G1 `x` равна нулю.<br/>*34 газа*                                                                                                                                                                                                                                     |
| `BLS_G2_ADD`        | *`x y - x+y`*                                   | Сложение на G2.<br/>*6134 газа*                                                                                                                                                                                                                                                           |
| `BLS_G2_SUB`        | *`x y - x-y`*                                   | Вычитание на G2.<br/>*6134 газа*                                                                                                                                                                                                                                                          |
| `BLS_G2_NEG`        | *`x - -x`*                                      | Отрицание на G2.<br/>*1584 газа*                                                                                                                                                                                                                                                          |
| `BLS_G2_MUL`        | *`x s - x*s`*                                   | Умножает точку G2 `x` на скаляр `s`.<br/>Любое `s` допустимо, включая отрицательное.<br/>*10584 газа*                                                                                                                                                                     |
| `BLS_G2_MULTIEXP`   | *`x_1 s_1 ... x_n s_n n - x_1*s_1+...+x_n*s_n`* | Вычисляет `x_1*s_1+...+x_n*s_n` для точек G2 `x_i` и скаляров `s_i`. Возвращает нулевую точку, если `n=0`.<br/>Любое `s_i` допустимо, включая отрицательное.<br/>*`gas=30422+n*1280+n/floor(max(log2(n),4))*22840`*                                       |
| `BLS_G2_ZERO`       | *`- zero`*                                      | Помещает нулевую точку в G2.<br/>*34 газа*                                                                                                                                                                                                                                                |
| `BLS_MAP_TO_G2`     | *`f - x`*                                       | Преобразует элемент FP2 `f` в точку G2.<br/>*7984 газа*                                                                                                                                                                                                                                   |
| `BLS_G2_INGROUP`    | *`x - bool`*                                    | Проверяет, что срез `x` представляет допустимый элемент G2.<br/>*4284 газа*                                                                                                                                                                                                               |
| `BLS_G2_ISZERO`     | *`x - bool`*                                    | Проверяет, что точка G2 `x` равна нулю.<br/>*34 газа*                                                                                                                                                                                                                                     |
| `BLS_PAIRING`       | *`x_1 y_1 ... x_n y_n n - bool`*                | Учитывая точки G1 `x_i` и точки G2 `y_i`, вычисляет и умножает пары `x_i,y_i`. Возвращает true, если результат является мультипликативным тождеством в FP12, в противном случае возвращает false. Возвращает false, если `n=0`.<br/>*`gas=20034+n*11800`* |
| `BLS_PUSHR`         | *`- r`*                                         | Изменяет порядок G1 и G2 (приблизительно `2^255`).<br/>*34 газа*                                                                                                                                                                                                       |

`INGROUP`, `ISZERO` не выбрасывают исключение на недопустимых точках (кроме исключений переполнения ячеек), вместо этого они возвращают false.

Другие арифметические операции выбрасывают исключение на недопустимых точках кривой. Обратите внимание, что они не проверяют, принадлежат ли заданные точки кривой группе G1/G2. Используйте инструкцию `INGROUP`, чтобы проверить это.

## RUNVM

В настоящее время код в TVM не может вызвать внешний ненадежный код "в изолированной среде". Другими словами, внешний код всегда может необратимо обновить код, данные контракта или задать действия (например, отправку всех денег).
Инструкция `RUNVM` позволяет создать независимый экземпляр виртуальной машины, запустить нужный код и получить необходимые данные (стек, регистры, потребление газа и т. д.) без риска загрязнения состояния вызывающей стороны. Безопасный запуск произвольного кода может быть полезен для [плагинов в стиле v4](/v3/documentation/smart-contracts/contracts-specs/wallet-contracts#wallet-v4), вычислений субконтрактов в стиле `init` [Tact's](https://docs.tact-lang.org) и т. д.

| <br/>Синтаксис Fift | <br/>Стек                                                                                                | <br/>Описание                                                                                                                                                                                                                                                                    |
| :------------------ | :------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `flags RUNVM`       | *`x_1 ... x_n n code [r] [c4] [c7] [g_l] [g_m] - x'_1 ... x'_m exitcode [data'] [c4'] [c5] [g_c]`*       | Запускает дочернюю виртуальную машину с кодом `code` и стеком `x_1...x_n`. Возвращает результирующий стек `x'_1...x'_m` и код выхода.<br/>Другие аргументы и возвращаемые значения включаются флагами, см. ниже. |
| `RUNVMX`            | *`x_1 ... x_n n code [r] [c4] [c7] [g_l] [g_m] flags - x'_1 ... x'_m exitcode [data'] [c4'] [c5] [g_c]`* | То же самое, но извлекает флаги из стека.                                                                                                                                                                                                                        |

Флаги похожи на `runvmx` в fift:

- `+1`: присвоить c3 значение кода
- `+2`: вставить неявный 0 перед запуском кода
- `+4`: взять `c4` из стека (постоянные данные), вернуть его конечное значение
- `+8`: взять лимит газа `g_l` из стека, вернуть потребленный газ `g_c`
- `+16`: взять `c7` из стека (контекст смарт-контракта)
- `+32`: вернуть конечное значение `c5` (действия)
- `+64`: вытолкнуть жесткий лимит газа (включено ACCEPT) `g_m` из стека
- `+128`: "изолированное потребление газа". Дочерняя VM будет иметь отдельный набор посещенных ячеек и отдельный счетчик chksgn.
- `+256`: вытолкнуть целое число `r`, вернуть ровно `r` значений сверху:\* Если вызов RUNVM успешен и установлено r, он возвращает r элементов. Если r не задано - возвращает все;

Стоимость газа:

- 66 газа
- 1 газ за каждый элемент стека, переданный дочерней виртуальной машине (первые 32 бесплатны)
- 1 газ за каждый элемент стека, возвращенный дочерней виртуальной машиной (первые 32 бесплатны)

## Отправка сообщений

В настоящее время сложно рассчитать стоимость отправки сообщения в контракте (что приводит к некоторым приближениям, как в [жетонах](https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-wallet.fc#L94)) и невозможно вернуть запрос, если фаза действия неверна. Также невозможно точно вычесть из входящего сообщения сумму "постоянной платы за логику контракта" и "расходов на газ".

- `SENDMSG` принимает ячейку и режим в качестве входных данных. Создает выходное действие и возвращает плату за создание сообщения. Режим имеет тот же эффект, что и в случае SENDRAWMSG. Кроме того, `+1024` означает - не создавать действие, только оценить плату. Другие режимы влияют на расчет платы следующим образом: `+64` заменяет весь баланс входящего сообщения в качестве исходящего значения (немного неточно, расходы на газ, которые невозможно оценить до завершения расчета, не учитываются), `+128` заменяет значение всего баланса контракта до начала фазы расчета (немного неточно, поскольку расходы на газ, которые невозможно оценить до завершения фазы расчета, не учитываются).
- `SENDRAWMSG`, `RAWRESERVE`, `SETLIBCODE`, `CHANGELIB` - добавлен флаг `+16`, что означает в случае сбоя действия - возврат транзакции. Никакого эффекта, если используется `+2`.

## Аудиты безопасности

Обновление виртуальной машины TON (TVM) было проанализировано на предмет безопасности и потенциальных уязвимостей.

**Аудиторская фирма**: Trail of Bits
**Аудиторский отчет**:

- [Аудиторский отчет Trail of Bits - Обновление TVM](https://docs.ton.org/audits/TVM_Upgrade_ToB_2023.pdf)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/changelog/tvm-upgrade-2024-04.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/changelog/tvm-upgrade-2024-04.md
================================================
# Обновление TVM 2024.04

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Добавлены новые инструкции по расчету дешевых комиссионных сборов

:::tip
Это обновление активно в основной сети с 16 марта (см. https://t.me/tonstatus/101). Предварительный просмотр этого обновления для blueprint доступен в пакетах `@ton/sandbox@0.16.0-tvmbeta.3`, `@ton-community/func-js@0.6.3-tvmbeta.3` и `@ton-community/func-js-bin@0.4.5-tvmbeta.3`.
:::

Это обновление активируется Config8 `version` >= 6.

## c7

**c7** кортеж расширен с 14 до 16 элементов:

- **14**: кортеж, содержащий некоторые параметры конфигурации в виде срезов ячеек. Если параметр отсутствует в конфигурации, значение равно null.
  - **0**: `StoragePrices` из `ConfigParam 18`. Не весь словарь, а только одна запись StoragePrices, которая соответствует текущему времени.
  - **1**: `ConfigParam 19` (глобальный идентификатор).
  - **2**: `ConfigParam 20` (цены на газ mc).
  - **3**: `ConfigParam 21` (цены на газ).
  - **4**: `ConfigParam 24` (стоимость пересылки mc).
  - **5**: `ConfigParam 25` (стоимость пересылки).
  - **6**: `ConfigParam 43` (ограничения по размеру).
- **15**: "[причитающийся платеж](https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L237)" - текущий долг за плату за хранение (nanoton). Код операции Asm: `DUEPAYMENT`.
- **16**: "использование предварительно скомпилированного газа" - использование газа для текущего контракта, если он предварительно скомпилирован (см. ConfigParam 45), в противном случае null. Код операции Asm: `GETPRECOMPILEDGAS`.

Идея этого расширения c7 распакованными параметрами конфигурации заключается в следующем: эти данные будут извлечены из глобальной конфигурации исполнителем транзакции, поэтому они уже представлены в памяти исполнителя. Однако (до расширения) смарт-контракту необходимо получать все эти параметры по одному из словаря конфигурации, что является дорогостоящим и потенциально непредсказуемым по газу (поскольку стоимость зависит от количества параметров).

Необходима оплата по факту, чтобы контракт мог правильно оценить плату за хранение: когда сообщение отправляется в режиме по умолчанию (возвращаемом) в смарт-контракт, плата за хранение вычитается (или добавляется в поле due_payment, содержащее долг, связанный с платой за хранение), предыдущее значение сообщения добавляется к балансу. Таким образом, если контракт после обработки сообщения отправляет излишки газа обратно с режимом = 64, это означает, что если баланс контракта достигнет 0, при следующих транзакциях плата за хранение начнет накапливаться в due_payment (а не вычитаться из входящих сообщений). Таким образом, долг будет молча накапливаться до тех пор, пока аккаунт не будет заморожен. `DUEPAYMENT` позволяет разработчику явно учитывать/удерживать комиссию за хранение и тем самым предотвращать любые проблемы.

## Новые коды операций

### Коды операций для работы с новыми значениями c7

26 газа для каждого, за исключением `SENDMSG` (из-за операций с ячейками).

| <br/>Синтаксис Fift   | <br/>Стек         | <br/>Описание                                                                                                                                                                         |
| :-------------------- | :---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `UNPACKEDCONFIGTUPLE` | *`- c`*           | Извлекает кортеж срезов конфигураций из c7                                                                                                                                            |
| `DUEPAYMENT`          | *`- i`*           | Извлекает значение причитающегося платежа из c7                                                                                                                                       |
| `GLOBALID`            | *`- i`*           | Теперь извлекает `ConfigParam 19` из from c7, формируя словарь конфигурации.                                                                                          |
| `SENDMSG`             | Режим *`msg - i`* | Теперь извлекает `ConfigParam 24/25` (цены сообщений) и `ConfigParam 43` (`max_msg_cells`) из c7, а не из словаря конфигурации. |

### Коды операций для обработки параметров конфигурации

Введение кортежа срезов конфигураций в исполнителе транзакций TON сделало анализ параметров комиссии более экономичным. Однако, поскольку в будущем могут быть введены новые конструкторы параметров конфигурации, может потребоваться обновление смарт-контрактов для интерпретации этих новых параметров. Для решения этой проблемы были введены специальные коды операций для расчета платы. Эти коды операций считывают параметры из c7 и рассчитывают плату таким же образом, как исполнитель. С введением новых конструкторов параметров эти коды операций будут обновлены для учета изменений. Это позволяет смарт-контрактам полагаться на эти инструкции для расчета платы без необходимости интерпретировать все типы конструкторов.

26 газа для каждого.

| <br/>Синтаксис Fift   | <br/>Стек                            | <br/>Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| :-------------------- | :----------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `GETGASFEE`           | *`gas_used is_mc - price`*           | Рассчитывает стоимость вычислений в nanoton для транзакции, которая потребляет *`gas_used`* газа.                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `GETSTORAGEFEE`       | *`cells bits seconds is_mc - price`* | Рассчитывает плату за хранение в nanoton для контракта на основе текущих цен на хранение. `cells` и `bits` — это размер [`AccountState`](https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L247) (с дедупликацией, включая корневую ячейку).                                                                                                                                                                                                                            |
| `GETFORWARDFEE`       | *`cells bits is_mc - price`*         | Рассчитывает стоимость пересылки в nanoton для исходящего сообщения. *`is_mc`* равно true, если источник или получатель находятся в мастерчейне, false, если оба находятся в бейсчейне. Обратите внимание, что ячейки и биты в сообщении следует подсчитывать с учетом дедупликации и правил *root-is-not-counted*.                                                                                                                                                                                                                 |
| `GETPRECOMPILEDGAS`   | *`- null`*                           | зарезервировано, в настоящее время возвращает `null`. Возвращает стоимость выполнения контракта в единицах газа, если этот контракт *предварительно скомпилирован*                                                                                                                                                                                                                                                                                                                                                                                                  |
| `GETORIGINALFWDFEE`   | *`fwd_fee is_mc - orig_fwd_fee`*     | вычисляет `fwd_fee * 2^16 / first_frac`. Может использоваться для получения исходного `fwd_fee` сообщения (в качестве замены для жестко закодированных значений, таких как [это](https://github.com/ton-blockchain/token-contract/blob/21e7844fa6dbed34e0f4c70eb5f0824409640a30/ft/jetton-wallet.fc#L224C17-L224C46)) из `fwd_fee`, проанализированного из входящего сообщения. *`is_mc`* имеет значение true, если отправитель или получатель находятся в мастерчейне, и false, если оба находятся в бейсчейне. |
| `GETGASFEESIMPLE`     | *`gas_used is_mc - price`*           | Рассчитывает дополнительные вычислительные затраты в nanoton для транзакции, которая потребляет дополнительные *`gas_used`*. Другими словами, то же самое, что `GETFORWARDFEESIMPLE`, но без фиксированной цены (просто `(gas_used * price) / 2^16`).                                                                                                                                                                                                                                                                            |
| `GETFORWARDFEESIMPLE` | *`cells bits is_mc - price`*         | Вычисляет дополнительную стоимость пересылки в nanoton для сообщения, содержащего дополнительные *`cells`* и *`bits`*. Другими словами, то же самое, что `GETFORWARDFEE`, но без фиксированной цены (просто `(bits*bit_price + cells*cell_price) / 2^16`).                                                                                                                                                                                                                                                                       |

`gas_used`, `cells`, `bits`, `time_delta` — целые числа в диапазоне `0..2^63-1`.

### Операции на уровне ячеек

Операции для работы с доказательствами Меркла, где ячейки могут иметь ненулевой уровень и несколько хешей. 26 газа для каждого.

| <br/>Синтаксис Fift | <br/>Стек             | <br/>Описание                    |
| :------------------ | :-------------------- | :------------------------------- |
| `CLEVEL`            | *`cell - level`*      | Возвращает уровень ячейки        |
| `CLEVELMASK`        | *`cell - level_mask`* | Возвращает маску уровня ячейки   |
| `i CHASHI`          | *`cell - hash`*       | Возвращает `i`-й хэш ячейки      |
| `i CDEPTHI`         | *`cell - depth`*      | Возвращает `i`-ую глубину ячейки |
| `CHASHIX`           | *`cell i - depth`*    | Возвращает `i`-й хэш ячейки      |
| `CDEPTHIX`          | *`cell i - depth`*    | Возвращает `i`-ую глубину ячейки |

`i` находится в диапазоне `0..3`.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/specification/runvm.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/specification/runvm.mdx
================================================
# Спецификация RUNVM

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В настоящее время у кода в TVM нет возможности вызывать внешний ненадежный код "в изолированной среде". Другими словами, внешний код всегда может необратимо обновить код, данные контракта или установить действия (например, отправить все деньги).

Инструкция `RUNVM` позволяет создать независимый экземпляр VM, запустить нужный код и получить необходимые данные (стек, регистры, потребление газа и т. д.) без риска загрязнения состояния вызывающей стороны. Запуск произвольного кода безопасным способом может быть полезен для [плагинов в стиле v4](/v3/documentation/smart-contracts/contracts-specs/wallet-contracts#wallet-v4), расчета субконтракта в стиле `init` Tact и т. д.

| xxxxxxxxxxxxx<br/>Синтаксис Fift | xxxxxxxxxxxxxxxxxxxxxxx<br/>Стек                                                                         | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>Описание                                                                                                                                                                                                                                                     |
| :------------------------------- | :------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `flags RUNVM`                    | _`x_1 ... x_n n code [r] [c4] [c7] [g_l] [g_m] - x'_1 ... x'_m exitcode [data'] [c4'] [c5] [g_c]`_       | Запускает дочернюю VM с кодом `code` и стеком `x_1...x_n`. Возвращает результирующий стек `x'_1...x'_m` и код выхода.<br/>Другие аргументы и возвращаемые значения включаются флагами, см. ниже.                                                                                                                      |
| `RUNVMX`                         | _`x_1 ... x_n n code [r] [c4] [c7] [g_l] [g_m] flags - x'_1 ... x'_m exitcode [data'] [c4'] [c5] [g_c]`_ | То же самое, но выводит флаги из стека.                                                                                                                                                                                                                                                                               |

Флаги похожи на `runvmx` в fift:

- `+1`: установить c3 в код
- `+2`: ввести неявный 0 перед запуском кода
- `+4`: взять `c4` из стека (постоянные данные), вернуть его окончательное значение
- `+8`: взять лимит газа "g_l" из стека, вернуть потребленный газ "g_c"
- `+16`: взять `c7` из стека (контекст смарт-контракта)
- `+32`: вернуть конечное значение `c5` (действия)
- `+64`: выводит жесткий лимит газа (включен ACCEPT) `g_m` из стека
- `+128`: "изолированное потребление газа". Дочерняя VM будет иметь отдельный набор посещенных ячеек и отдельный счетчик chksgn.
- `+256`: выводит целое число `r`, возвращает ровно `r` значений сверху:
- Если вызов RUNVM успешен и r установлено, он возвращает r элементов. Если r не установлено - возвращает все;
- Если RUNVM успешен, но в стеке недостаточно элементов (глубина стека меньше r), это рассматривается как исключение в дочерней VM с exit_code=-3 и exit_arg=0 (поэтому 0 возвращается как единственный элемент стека);
- Если RUNVM завершается с исключением - возвращается только один элемент - exit arg (не путать с exit_code);
- В случае OOG exit_code = -14 и exit_arg - это количество газа.

Стоимость газа:

- 66 газа
- 1 газ за каждый элемент стека, переданный дочерней виртуальной машине (первые 32 бесплатны)
- 1 газ за каждый элемент стека, возвращенный дочерней виртуальной машиной (первые 32 бесплатны)

## См. также

- [Инструкции TVM](/v3/documentation/tvm/instructions)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-exit-codes.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-exit-codes.md
================================================
# Коды выхода TVM

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Если TVM завершается с произвольным 16-битным целым числом без знака `exit_code`. `exit_code` больше 1, это считается *кодом ошибки*. Следовательно, выход с таким кодом может привести к отмене или отказу транзакции.

## Стандартные коды выхода

:::info
Список стандартных кодов выхода содержит все универсальные коды выхода TVM, определенные для блокчейна TON. Альтернативные коды выхода следует искать в исходном коде соответствующего контракта.
:::

| Код выхода | Фаза TVM        | Описание                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------- | --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `0`        | Фаза вычислений | Стандартный код выхода при успешном выполнении.                                                                                                                                                                                                                                                                                                                              |
| `1`        | Фаза вычислений | Альтернативный код выхода при успешном выполнении.                                                                                                                                                                                                                                                                                                                           |
| `2`        | Фаза вычислений | Незаполнение стека. Последний код операции израсходовал больше элементов, чем имеется в стеках. <sup>1</sup>                                                                                                                                                                                                                                                 |
| `3`        | Фаза вычислений | Переполнение стека. В стеке сохранено больше значений, чем разрешено этой версией TVM.                                                                                                                                                                                                                                                                       |
| `4`        | Фаза вычислений | Переполнение целого числа. Целое число не помещается в −2<sup>256</sup> ≤ x < 2<sup>256</sup> или произошло деление на ноль.                                                                                                                                                                                                        |
| `5`        | Фаза вычислений | Целое число выходит за пределы ожидаемого диапазона.                                                                                                                                                                                                                                                                                                                         |
| `6`        | Фаза вычислений | Недопустимый код операции. Инструкция неизвестна в текущей версии TVM.                                                                                                                                                                                                                                                                                       |
| `7`        | Фаза вычислений | Ошибка проверки типа. Аргумент примитива имеет неверный тип значения. <sup>1</sup>                                                                                                                                                                                                                                                                           |
| `8`        | Фаза вычислений | Переполнение ячейки. Запись в строитель невозможна, так как после операции будет более 1023 бит или 4 ссылок.                                                                                                                                                                                                                                                |
| `9`        | Фаза вычислений | Незаполнение ячейки. Операция чтения из примитива среза попыталась прочитать больше бит или ссылок, чем доступно.                                                                                                                                                                                                                                            |
| `10`       | Фаза вычислений | Ошибка словаря. Ошибка во время манипуляции со словарем (хэш-карты).                                                                                                                                                                                                                                                                      |
| `11`       | Фаза вычислений | Чаще всего вызывается попыткой вызвать get-метод, идентификатор которого не найден в коде (отсутствует модификатор `method_id` или указано неправильное имя get -метода при попытке его вызова). В [документации TVM](https://ton.org/tvm.pdf) это описывается как "Неизвестная ошибка, может быть выдана пользовательскими программами". |
| `12`       | Фаза вычислений | Выдается TVM в ситуациях, которые считаются невозможными.                                                                                                                                                                                                                                                                                                                    |
| `13`       | Фаза вычислений | Ошибка отсутствия газа. Выдается TVM, когда оставшийся газ становится отрицательным.                                                                                                                                                                                                                                                                         |
| `-14`      | Фаза вычислений | Это указывает на ошибку отсутствия газа, такую ​​же, как код `13`. Он отрицательный, потому что его [нельзя подделать](https://github.com/ton-blockchain/ton/blob/20758d6bdd0c1327091287e8a620f660d1a9f4da/crypto/vm/vm.cpp#L492)                                                                                                                                            |
| `32`       | Фаза действий   | Список действий недействителен. Устанавливается во время фазы действия, если регистр c5 после выполнения содержит объект, который невозможно проанализировать.                                                                                                                                                                                               |
| `-32`      | Фаза действий   | (то же, что и пред. 32) - Идентификатор метода не найден. Возвращается TonLib при попытке выполнить несуществующий get-метод.                                                                                                                                                                                             |
| `33`       | Фаза действий   | Список действий слишком длинный.                                                                                                                                                                                                                                                                                                                                             |
| `34`       | Фаза действий   | Действие недопустимо или не поддерживается. Устанавливается на этапе действия, если текущее действие не может быть применено.                                                                                                                                                                                                                                |
| `35`       | Фаза действий   | Недопустимый исходный адрес в исходящем сообщении.                                                                                                                                                                                                                                                                                                                           |
| `36`       | Фаза действий   | Недопустимый адрес назначения в исходящем сообщении.                                                                                                                                                                                                                                                                                                                         |
| `37`       | Фаза действий   | Недостаточно TON. Сообщение отправляет слишком много TON, или после вычета сборов остается недостаточно TON.                                                                                                                                                                                                                                                 |
| `38`       | Фаза действий   | Недостаточно дополнительных валют.                                                                                                                                                                                                                                                                                                                                           |
| `40`       | Фаза действий   | Недостаточно средств для обработки сообщения. Эта ошибка возникает, когда газа достаточно только для частичного покрытия сообщения, но недостаточно для полного его покрытия.                                                                                                                                                                                |
| `43`       | Фаза действий   | Превышено максимальное количество ячеек в библиотеке или превышена максимальная глубина дерева Меркла.                                                                                                                                                                                                                                                                       |

<sup>1</sup> Если вы столкнулись с таким исключением в контракте func, это, вероятно, означает ошибку типа в объявлениях asm.

:::info
Часто можно увидеть код выхода `0xffff` (65535 в десятичной форме). Обычно это означает, что полученный код операции неизвестен контракту. При написании контрактов этот код задается самим разработчиком.
:::



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-initialization.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-initialization.md
================================================
# Инициализация TVM

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::info
To maximize your comprehension of this page, familiarizing yourself with the [TL-B language](/v3/documentation/data-formats/tlb/cell-boc) is highly recommended.

- [TVM Retracer](https://retracer.ton.org/)
  :::

TVM вызывается во время фазы вычислений обычных и/или других транзакций.

## Начальное состояние

Новый экземпляр TVM инициализируется до выполнения смарт-контракта следующим образом:

- Оригинальный **cc** (текущая продолжительность) инициализируется с помощью ячейки среза, созданного из раздела `code` смарт-контракта. В случае замороженного или неинициализированного состояния аккаунта, код должен быть указан в поле `init` входящего сообщения.

- **cp** (текущая кодовая страница TVM) устанавливается на значение по умолчанию, которое равно 0. Если смарт-контракт хочет использовать другую кодовую страницу TVM *x*, то он должен переключиться на нее, используя `SETCODEPAGE` *x* в качестве первой инструкции своего кода.

- Значения **газа** (*лимиты газа*) инициализируются в соответствии с результатами фазы кредитования.

- Вычисление **библиотек** (*контекст библиотеки*) [описано ниже](#library-context).

- Процесс инициализации **стека** зависит от события, которое вызвало транзакцию, и его содержимое [описано ниже](#stack).

- Контрольный регистр **c0** (возвращаемая продолжительность) инициализируется экстраординарной продолжительностью `ec_quit` с параметром 0. При выполнении это продолжительность ведет к завершению TVM с кодом выхода 0.

- Контрольный регистр **c1** (альтернативная возвращаемая продолжительность) инициализируется экстраординарной продолжительностью `ec_quit` с параметром 1. При вызове она приводит к завершению TVM с кодом выхода 1. Обратите внимание, что оба кода выхода 0 и 1 считаются успешным завершением TVM.

- Контрольный регистр **c2** (обработчик исключений) инициализируется экстраординарной продолжительностью `ec_quit_exc`. При вызове она извлекает верхнее целое число из стека (равное номеру исключения) и завершает TVM с кодом выхода, равным этому целому числу. Таким образом, по умолчанию все исключения приводят к завершению выполнения смарт-контракта с кодом выхода, равным номеру исключения.

- Контрольный регистр **c3** (словарь кода) инициализируется ячейкой с кодом смарт-контракта, например **cc** (текущая продолжительность), описанным выше.

- Контрольный регистр **c4** (корень постоянных данных) инициализируется постоянными данными смарт-контракта, хранящимися в его разделе `data`. В случае замороженного или неинициализированного состояния аккаунта, данные должны быть предоставлены в поле `init` входящего сообщения. Обратите внимание, что постоянные данные смарт-контракта не обязательно должны быть загружены полностью, чтобы это произошло. Вместо этого загружается корень, и TVM может загружать другие ячейки по их ссылкам из корня только при доступе к ним, тем самым предоставляя форму виртуальной памяти.

- Контрольный регистр **c5** (корень действий) инициализируется пустой ячейкой. Примитивы "выходных действий" TVM, такие как `SENDMSG`, накапливают *выходные действия* (например, исходящие сообщения) в этом регистре, которые должны быть выполнены после успешного завершения смарт-контракта. Схема TL-B для ее сериализации [описана ниже](#control-register-c5)

- Контрольный регистр **c7** (корень временных данных) инициализируется как кортеж, а его структура [описана ниже](#control-register-c7)

## Контекст библиотеки

Контекст библиотеки_ (среда библиотеки) смарт-контракта — это хэш-карта, отображающая 256-битные хэши ячеек (представлений) в соответствующие ячейки. Когда во время выполнения смарт-контракта осуществляется доступ к ссылке на внешнюю ячейку, в библиотечной среде выполняется поиск ячейки, на которую ссылаются, и ссылка на внешнюю ячейку прозрачно заменяется найденной ячейкой.

Среда библиотеки для вызова смарт-контракта вычисляется следующим образом:

1. Глобальная среда библиотеки для текущего воркчейна берется из текущего состояния мастерчейна.
2. Затем она дополняется локальной средой библиотеки смарт-контракта, хранящейся в поле `library` состояния смарт-контракта. Учитываются только 256-битные ключи, равные хэшам соответствующих значений ячеек. Если ключ присутствует как в глобальной, так и в локальной среде библиотеки, локальная среда имеет приоритет при слиянии.
3. Наконец, она дополняется полем `library` поля `init` входящего сообщения (если таковое имеется). Обратите внимание, что если аккаунт заморожен или не инициализирован, поле `library` сообщения будет использоваться вместо локальной среды библиотеки из предыдущего шага. Библиотека сообщений имеет более низкий приоритет, чем локальная и глобальная библиотечные среды.

Наиболее распространенный способ создания общих библиотек для TVM — это публикация ссылки на корневую ячейку библиотеки в мастерчейне.

## Стек

Инициализация стека TVM происходит после формирования начального состояния TVM и зависит от события, вызвавшего транзакцию:

- внутреннее сообщение
- внешнее сообщение
- тик-так
- подготовка к разделению
- установка слияния

Последний элемент, помещенный в стек, всегда является *селектором функции*, который является *целым числом*, идентифицирующим событие, вызвавшее транзакцию.

### Внутреннее сообщение

В случае внутреннего сообщения стек инициализируется путем помещения аргументов в функцию `main()` смарт-контракта следующим образом:

- Баланс *b* смарт-контракта (после зачисления значения входящего сообщения) передается как *целое* количество nanoton.
- Баланс *b*<sub>m</sub> входящего сообщения *m* передается как *целое* количество nanoton.
- Входящее сообщение *m* передается как ячейка, которая содержит сериализованное значение типа *Message X*, где *X* - тип тела сообщения.
- Тело *m*<sub>b</sub> входящего сообщения, равное значению поля body *m* и переданное как срез ячейки.
- Селектор функции *s*, обычно равный 0.

После этого выполняется код смарт-контракта, равный его начальному значению **c3**. Он выбирает правильную функцию в соответствии с *s*, которая, как ожидается, обработает оставшиеся аргументы функции и затем завершается.

### Внешнее сообщение

Входящее внешнее сообщение обрабатывается аналогично [внутреннему сообщению, описанному выше](#internal-message), со следующими изменениями:

- Селектор функции *s* устанавливается в -1.
- Баланс *b*<sub>m</sub> входящего сообщения всегда равен 0.
- Начальный текущий лимит газа *g*<sub>l</sub> всегда равен 0. Однако начальный кредит газа *g*<sub>c</sub> > 0.

Смарт-контракт должен завершиться при *g*<sub>c</sub> = 0 или *g*<sub>r</sub> ≥ *g*<sub>c</sub>; в противном случае транзакция и содержащий ее блок недействительны. Валидаторы или коллаторы, предлагающие кандидата на блок, никогда не должны включать транзакции, обрабатывающие входящие внешние сообщения, которые являются недействительными.

### Тик-так

В случае транзакций тик-так стек инициализируется путем передачи аргументов в функцию `main()` смарт-контракта следующим образом:

- Баланс *b* текущего аккаунта передается как *целое* количество nanoton.
- 256-битный адрес текущего аккаунта внутри мастерчейна как беззнаковое *целое* число.
- Целое число, равное 0 для тик-транзакций и -1 для ток-транзакций.
- Селектор функции *s*, равный -2.

### Подготовка разделения

В случае транзакции подготовки разделения стек инициализируется путем передачи аргументов в функцию `main()` смарт-контракта следующим образом:

- Баланс *b* текущего аккаунта передается как *целое* количество nanoton.
- *Срез*, содержащий *SplitMergeInfo*.
- 256-битный адрес текущего аккаунта.
- 256-битный адрес дочернего аккаунта.
- Целое число 0 ≤ *d* ≤ 63, равное положению единственного бита, в котором адреса текущего и дочернего аккаунтов различаются.
- Селектор функции *s*, равный -3.

### Установка слияния

В случае транзакции установки слияния стек инициализируется путем передачи аргументов в функцию `main()` смарт-контракта следующим образом:

- Баланс *b* текущего аккаунта (уже объединенный с балансом nanoton дочернего аккаунта) передается как *целое* число nanoton.
- Баланс *b'* дочернего аккаунта, взятый из входящего сообщения *m*, передается как *целое* число nanoton.
- Сообщение *m* из дочернего аккаунта, автоматически сгенерированное транзакцией подготовки слияния. Его поле `init` содержит конечное состояние дочернего аккаунта. Сообщение передается как ячейка, которая содержит сериализованное значение типа *Message X*, где *X* — тип тела сообщения.
- Состояние дочернего аккаунта, представленное параметром *StateInit*.
- *Срез*, содержащий *SplitMergeInfo*.
- 256-битный адрес текущего аккаунта.
- 256-битный адрес дочернего аккаунта.
- Целое число 0 ≤ *d* ≤ 63, равное положению единственного бита, в котором адреса текущего и дочернего аккаунтов различаются.
- Селектор функций *s*, равный -4.

## Контрольный регистр c5

*Выходные действия* смарт-контракта накапливаются в ячейке, хранящейся в контрольном регистре **c5**: сама ячейка содержит последнее действие в списке и ссылку на предыдущее, таким образом образуя связанный список.

Список также может быть сериализован как значение типа *OutList n*, где *n* — длина списка:

```tlb
out_list_empty$_ = OutList 0;

out_list$_ {n:#}
  prev:^(OutList n)
  action:OutAction
  = OutList (n + 1);

out_list_node$_
  prev:^Cell
  action:OutAction = OutListNode;
```

Список возможных действий при этом состоит из:

- `action_send_msg` — для отправки исходящего сообщения
- `action_set_code` — для установки кода операции
- `action_reserve_currency` — для хранения коллекции валют
- `action_change_library` — для изменения библиотеки

Как описано в соответствующей схеме TL-B:

```tlb
action_send_msg#0ec3c86d
  mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
  
action_set_code#ad4de08e
  new_code:^Cell = OutAction;
  
action_reserve_currency#36e6b809
  mode:(## 8)
  currency:CurrencyCollection = OutAction;

libref_hash$0
  lib_hash:bits256 = LibRef;
libref_ref$1
  library:^Cell = LibRef;
action_change_library#26fa1dd4
  mode:(## 7) { mode <= 2 }
  libref:LibRef = OutAction;
```

## Контрольный регистр c7

Контрольный регистр **c7** содержит корень временных данных в виде кортежа, сформированного типом *SmartContractInfo*, содержащим некоторые базовые данные контекста блокчейна, такие как время, глобальная конфигурация и т. д. Он описывается следующей схемой TL-B:

```tlb
smc_info#076ef1ea
  actions:uint16 msgs_sent:uint16
  unixtime:uint32 block_lt:uint64 trans_lt:uint64 
  rand_seed:bits256 balance_remaining:CurrencyCollection
  myself:MsgAddressInt global_config:(Maybe Cell) = SmartContractInfo;
```

Первым компонентом этого кортежа является значение *Integer*, которое всегда равно 0x076ef1ea, после чего следуют 9 именованных полей:

| Поле                | Тип                                                                                 | Описание                                                                                                                                                                                                                  |
| ------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `actions`           | uint16                                                                              | Изначально инициализируется 0, но увеличивается на единицу всякий раз, когда выходное действие устанавливается примитивом выходного действия не-RAW                                                                       |
| `msgs_sent`         | uint16                                                                              | Количество отправленных сообщений                                                                                                                                                                                         |
| `unixtime`          | uint32                                                                              | Временная метка Unix в секундах                                                                                                                                                                                           |
| `block_lt`          | uint64                                                                              | Представляет *логическое время* предыдущего блока этого аккаунта. [Подробнее о логическом времени](/v3/documentation/smart-contracts/message-management/messages-and-transactions#what-is-a-logical-time) |
| `trans_lt`          | uint64                                                                              | Представляет *логическое время* предыдущей транзакции этого аккаунта                                                                                                                                                      |
| `rand_seed`         | bits256                                                                             | Инициализируется детерминированно, начиная с `rand_seed` блока, адреса аккаунта, хеша входящего обрабатываемого сообщения (если есть) и логического времени транзакции `trans_lt`                      |
| `balance_remaining` | [CurrencyCollection](/v3/documentation/data-formats/tlb/msg-tlb#currencycollection) | Оставшийся баланс смарт-контракта                                                                                                                                                                                         |
| `myself`            | [MsgAddressInt](/v3/documentation/data-formats/tlb/msg-tlb#msgaddressint-tl-b)      | Адрес этого смарт-контракта                                                                                                                                                                                               |
| `global_config`     | (Возможно, ячейка)                                               | Содержит информацию о глобальной конфигурации                                                                                                                                                                             |

Обратите внимание, что в предстоящем обновлении TVM кортеж **c7** был расширен с 10 до 14 элементов. Подробнее об этом читайте [здесь](/v3/documentation/tvm/changelog/tvm-upgrade-2023-07).

## См. также

- Оригинальное описание инициализации TVM из технического документа



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-overview.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/tvm/tvm-overview.mdx
================================================
import Button from '@site/src/components/button'

# Обзор TVM

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Все смарт-контракты TON выполняются на собственной виртуальной машине TON (TVM). TVM построена по _принципу стека_, что делает ее эффективной и простой в реализации.

В этом документе представлен общий обзор того, как TVM выполняет транзакции.

:::tip

- Исходный код TVM — [**Реализация TVM C++**](https://github.com/ton-blockchain/ton/tree/master/crypto/vm)
- [TVM Retracer](https://retracer.ton.org/)
  :::

## Курс TON: TVM

:::tip
Перед началом курса убедитесь, что вы хорошо понимаете основы технологии блокчейн. Если у вас есть пробелы в знаниях, рекомендуем пройти курс [Основы блокчейна с TON](https://stepik.org/course/201294/promo) ([версия RU](https://stepik.org/course/202221/), [версия CHN](https://stepik.org/course/200976/)).
:::

[Курс по блокчейну TON](https://stepik.org/course/176754/) — это комплексное руководство по разработке на блокчейне TON.

Модуль 2 полностью охватывает **TVM**, транзакции, масштабируемость и бизнес-кейсы.

<Button href="https://stepik.org/course/176754/promo"
        colorType={'primary'} sizeType={'sm'}>

Пройдите курс по блокчейну TON

</Button>

<Button href="https://stepik.org/course/201638/promo"
        colorType={'secondary'} sizeType={'sm'}>

CHN

</Button>

<Button href="https://stepik.org/course/201855/promo"
        colorType={'secondary'} sizeType={'sm'}>

RU

</Button>

## Транзакции и фазы

Когда на аккаунте в одной из цепочек TON происходит какое-либо событие, оно вызывает **транзакцию**. Наиболее распространенным событием является "получение некоторого сообщения", но, вообще говоря, могут быть `tick-tock`, `merge`, `split` и другие события.

Каждая транзакция состоит из 5 фаз:

1. **Фаза хранения** - на этой фазе рассчитываются сборы за хранение, накопленные контрактом из-за занятия некоторого пространства в состоянии цепочки. Подробнее читайте в разделе [плата за хранение](/v3/documentation/smart-contracts/transaction-fees/fees-low-level#storage-fee).
2. **Фаза кредита** - на этой фазе рассчитывается баланс контракта относительно (возможной) стоимости входящего сообщения и собранной платы за хранение.
3. **Фаза вычислений** - на этом этапе TVM выполняет контракт (см. ниже), а результатом выполнения контракта является совокупность `exit_code`, `actions` (сериализованный список действий), `gas_details`, `new_storage` и некоторых других.
4. **Фаза действий** - если фаза вычислений прошла успешно, на этом этапе обрабатываются `actions` из фазы вычислений. В частности, действия могут включать отправку сообщений, обновление кода смарт-контракта, обновление библиотек и т. д. Обратите внимание, что некоторые действия могут завершиться неудачей во время обработки (например, если мы попытаемся отправить сообщение с большим количеством TON, чем есть в контракте), в этом случае вся транзакция может быть отменена или это действие может быть пропущено (это зависит от режима действий, другими словами, контракт может отправить сообщение типа `send-or-revert` или `try-send-if-no-ignore`).
5. **Фаза возврата** — если фаза вычислений не удалась (возвращено `exit_code >= 2`), в этой фазе формируется _сообщение о возврате_ для транзакций, инициированных входящим сообщением.

## Фаза вычислений

В этой фазе происходит выполнение TVM.

:::tip

- TVM 4.3.5 - [**Документ по блокчейну TON**](https://docs.ton.org/assets/files/tblkch-6aaf006b94ee2843a982ebf21d7c1247.pdf)
  :::

### Пропуск фазы вычислений

Фаза вычислений заключается в вызове TVM с правильными входными данными. В некоторых случаях TVM вообще не может быть вызван (например, если аккаунт отсутствует, не инициализирован или заморожен, а обрабатываемое входящее сообщение не имеет полей кода или данных или эти поля имеют неверный хеш)

Это отражено в соответствующих [конструкторах](https://github.com/ton-blockchain/ton/blob/5c392e0f2d946877bb79a09ed35068f7b0bd333a/crypto/block/block.tlb#L314):

- `cskip_no_state$00` - [Отсутствие состояния](https://testnet.tonviewer.com/transaction/7e78394d082882375a5d21affa6397dec60fc5a3ecbea87f401b0e460fb5c80c) (т. е. код и данные смарт-контракта) как в аккаунте (несуществующем, неинициализированном или замороженном), так и в сообщении.

- `cskip_bad_state$01` - Недопустимое состояние, переданное в сообщении (т. е. хэш состояния отличается от ожидаемого значения) замороженного или неинициализированного аккаунта.

- `cskip_no_gas$10` - [Отсутствие средств](https://testnet.tonviewer.com/transaction/a1612cde7fd66139a7d04b30f38db192bdb743a8b12054feba3c16061a4cb9a6) для покупки газа. (Около < 0,00004 TON к [08.2024](https://testnet.tonviewer.com/transaction/9789306d7b29318c90477aa3df6599ee4a897031162ad41a24decb87db65402b))

### Состояние TVM

В любой момент состояние TVM полностью определяется 6 свойствами:

- Стек (см. ниже)
- Регистры управления - (см. ниже) проще говоря, это означает до 16 переменных, которые могут быть напрямую установлены и прочитаны во время выполнения
- Текущее продолжение - объект, который описывает текущую выполняемую последовательность инструкций
- Текущая кодовая страница - проще говоря, это версия TVM, которая в данный момент запущена
- Лимиты газа - набор из 4 целочисленных значений; текущий лимит газа g<sub>l</sub>, максимальный лимит газа g<sub>m</sub>, оставшийся газ g<sub>r</sub> и кредит газа g<sub>c</sub>
- Контекст библиотеки - хэш-карта библиотек, которые может вызывать TVM

### TVM - это стековая машина

TVM - это стековая машина по принципу "последний вошел - первый вышел". Всего существует 7 типов переменных, которые могут храниться в стеке — три типа, не являющихся ячейками:

- Integer — 257-битные целые числа со знаком
- Tuple — упорядоченная коллекция из до 255 элементов с произвольными типами значений, возможно, разными.
- Null

И четыре различных вида ячеек:

- Cell — базовая (возможно, вложенная) непрозрачная структура, используемая блокчейном TON для хранения всех данных
- Slice — специальный объект, позволяющий читать из ячейки
- Builder — специальный объект, позволяющий создавать новые ячейки
- Continuation — специальный объект, позволяющий использовать ячейку в качестве источника инструкций TVM

### Управляющие регистры

- `c0` — Содержит следующее продолжение или возврат продолжения (аналогично адресу возврата подпрограммы в обычных конструкциях). Это значение должно быть продолжением.
- `c1` — Содержит альтернативное (возвратное) продолжение; это значение должно быть продолжением.
- `c2` — Содержит обработчик исключений. Это значение является продолжением, которое вызывается при возникновении исключения.
- `c3` — Вспомогательный регистр, содержит текущий словарь, по сути хэш-карту, содержащую код всех функций, используемых в программе. Это значение должно быть продолжением.
- `c4` — Содержит корень постоянных данных или просто раздел `data` контракта. Это значение является ячейкой.
- `c5` — Содержит выходные действия. Это значение является ячейкой.
- `c7` — Содержит корень временных данных. Это кортеж.

### Инициализация TVM

TVM инициализируется, когда выполнение транзакции достигает фазы вычисления, а затем выполняет команды (коды операций) из _текущего продолжения_, пока не останется больше команд для выполнения (и продолжения для возвратных переходов).

Подробное описание процесса инициализации можно найти здесь: [Инициализация TVM](/v3/documentation/tvm/tvm-initialization)

## Инструкции TVM

Список инструкций TVM можно найти здесь: [Инструкции TVM](/v3/documentation/tvm/instructions).

### Результат выполнения TVM

Помимо exit_code и данных о потребленном газе, TVM косвенно выводит следующие данные:

- Регистр c4 — ячейка, которая будет сохранена как новая `data` смарт-контракта (если выполнение не будет отменено на этой или последующих фазах)
- Регистр c5 — (список выходных действий) ячейка с последним действием в списке и ссылка на ячейку с предыдущим действием (рекурсивно)

Всеми остальными значениями регистра можно пренебречь.

Обратите внимание, что существует глобальное ограничение на максимальную глубину ячейки `<1024` во время выполнения контракта. Однако регистры c4 и c5 должны быть `<=512` в глубину. Выход за эти пределы приводит к ошибке в конце фазы вычислений.
Дополнительное ограничение накладывается на фазе действий. Контракт не может создать более 255 выходных действий.

:::tip
Если контракт хочет отправить более 255 сообщений, он может сделать это, отправив сообщение самому себе, в котором будет содержаться запрос на отправку оставшихся сообщений. Пример такого подхода можно увидеть по ссылке https://github.com/ton-blockchain/highload-wallet-contract-v3/blob/main/contracts/highload-wallet-v3.func#L50.
:::

## См. также

- [Инструкции TVM](/v3/documentation/tvm/instructions)
- [TON TVM](https://ton.org/tvm.pdf) Концепции TVM (могут содержать устаревшую информацию)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/whitepapers/overview.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/documentation/whitepapers/overview.md
================================================
# Технические документы

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

В этом разделе представлена ​​оригинальная документация, написанная доктором Николаем Дуровым, которая всесторонне описывает все части TON.

## Оригинальная документация

:::info
Обратите внимание, что здесь и далее код, комментарии и/или документация могут содержать параметры, методы и определения “gram”, “nanogram” и т. д., которые являются наследием оригинального кода TON, разработанного Telegram. Криптовалюта Gram никогда не выпускалась. Валюта TON — Toncoin, а валюта тестовой сети TON — Test Toncoin.
:::

- [TON Whitepaper](https://docs.ton.org/ton.pdf)

  Технический документ TON – общее описание блокчейна TON (The Open Network).

- [TON Virtual Machine](https://docs.ton.org/tvm.pdf)

  Описание виртуальной машины TON (может включать устаревшую информацию о кодах операций, актуальный список в разделе [Инструкция TVM](/v3/documentation/tvm/tvm-overview)).

- [TON Blockchain](https://docs.ton.org/tblkch.pdf)

  Описание блокчейна Telegram Open Network (может включать устаревшую информацию).

- [Catchain Consensus Protocol](https://docs.ton.org/catchain.pdf)

  Описание протокола консенсуса "Задача византийских генералов"
  (Byzantine Fault Tolerant - BFT), используемого блокчейном TON при создании новых блоков.

- [Fift Documentation](https://docs.ton.org/fiftbase.pdf)

  Описание языка Fift и его использования в TON.

## Переводы

- **\[Русский]** [korolyow/ton_docs_ru](https://github.com/Korolyow/TON_docs_ru) — Технические документы TON на русском языке. (*эта версия создана сообществом, TON Foundation не может гарантировать качество перевода*)
- **\[Традиционный китайский]** [awesome-doge/the-open-network-whitepaper](https://github.com/awesome-doge/TON_Paper/blob/main/zh_ton.pdf) — Технические документы TON на традиционном китайском языке. (*создано сообществом, TON Foundation не может гарантировать качество перевода*)
- **\[Упрощенный китайский]** [kojhliang/Ton_White_Paper_SC](https://github.com/kojhliang/Ton_White_Paper_SC/blob/main/Ton%E5%8C%BA%E5%9D%97%E9%93%BE%E7%99%BD%E7%9A%AE%E4%B9%A6_%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88.pdf) — Технические документы TON на упрощенном китайском. (*создано сообществом, TON Foundation не может гарантировать качество перевода*)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/api-keys.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/api-keys.mdx
================================================
# Как получить ключ Toncenter API

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Обзор

При использовании TON HTTP API `токен` (`ключ`), как правило, не требуется. Однако он разблокирует ограничения на запросы. Существует несколько доступных тарифных планов, все из которых можно просмотреть в мини-приложении Toncenter

## Как получить ключ

Чтобы получить ключ, зайдите в [@toncenter](https://t.me/toncenter), нажмите кнопку `start` и следуйте инструкциям.

![Telegram-бот](/img/registration-process/telegram-bot.png)

Нажмите кнопку `Manage API Keys` или `Toncenter`, чтобы открыть мини-приложение Telegram.

![Основное мини приложение Toncenter](/img/registration-process/toncenter-main-miniapp.png)

Нажмите `Create API Key`.

![Create API Key](/img/registration-process/create-api-key.png)

Заполните необходимые поля и нажмите `Create`. Вот и все! Теперь ключ можно использовать для отправки запросов.

## Как обновить план подписки

Чтобы обновить свой план подписки, выполните следующие действия:

- Нажмите кнопку `MANAGE` в верхней части приложения; откроется окно с планами.
- Выберите нужный тарифный план и нажмите `Purchase Subscription`.
- Отправьте необходимое количество TON по предложенному адресу.

## Устранение неполадок

Если Ваше приложение Telegram устарело, мини-приложение может работать некорректно. Попробуйте обновить приложение Telegram.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/api-types.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/api-types.md
================================================
# Типы API

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

**Высокодоступные API для блокчейна - это основной элемент безопасной, удобной и быстрой разработки полезных приложений на TON.**

- [TON HTTP API](/v3/guidelines/dapps/apis-sdks/ton-http-apis) - API, позволяющий работать с *индексированной информацией блокчейна*.
- [TON ADNL API](/v3/guidelines/dapps/apis-sdks/ton-adnl-apis) - безопасный API для взаимодействия с TON, основанный на протоколе ADNL.

:::tip Состояние инфраструктуры TON

- [status.toncenter](https://status.toncenter.com/) - различная статистика активности узлов за последний час.
- [Tonstat.us](https://tonstat.us/) - Графана в реальном времени, обновляется каждые 5 минут.
  :::

## API-интерфейсы Toncenter

- [TON Index](https://toncenter.com/api/v3/) - TON Index собирает данные с полного узла в базу данных PostgreSQL и предоставляет удобный API к индексированному блокчейну.
- [toncenter/v2](https://toncenter.com/) - Этот API обеспечивает HTTP-доступ к блокчейну TON - получение информации об учетных записях и кошельках, поиск блоков и транзакций, отправка сообщений в блокчейн, вызов get методов умных контрактов и многое другое.

## Сторонние API

- [tonapi.io](https://docs.tonconsole.com/tonapi) - быстрый индексированный API, предоставляющий базовую информацию об аккаунтах, транзакциях, блоках, данные для конкретных приложений о NFT, аукционах, Jetton, TON DNS и подписках. Он также предоставляет аннотированные данные о цепочках транзакций.
- [TONX API](https://docs.tonxapi.com/) - API, специально разработанный для бесперебойной разработки DApps, обеспечивая легкий доступ к различным инструментам и данным.
- [dton.io](https://dton.io/graphql/) - GraphQL API, который может предоставлять данные об аккаунтах, транзакциях и блоках, а также специфические для приложения данные о NFT, аукционах, Jetton и TON DNS.
- [ton-api-v4](https://mainnet-v4.tonhubapi.com) - еще один lite-api, сосредоточенный на скорости через агрессивное кэширование в CDN.
- [docs.nftscan.com](https://docs.nftscan.com/reference/ton/model/asset-model) - API для работы с NFT на блокчейне TON.
- [everspace.center](https://everspace.center/toncoin) - Простой RPC API для доступа к блокчейну TON.

## Дополнительные API

### API для получения курса Toncoin

- https://docs.tonconsole.com/tonapi/rest-api/rates
- https://coinmarketcap.com/api/documentation/v1/
- https://apiguide.coingecko.com/getting-started

### API для преобразования адресов

:::info
Предпочтительнее преобразовывать адрес с помощью локального алгоритма, дополнительную информацию ознакомьтесь в разделе документации [Адреса](/v3/documentation/smart-contracts/addresses).
:::

#### От удобной к Raw формату

/api/v2/unpackAddress

Curl

```curl
curl -X 'GET' \
'https://toncenter.com/api/v2/unpackAddress?address=EQApAj3rEnJJSxEjEHVKrH3QZgto_MQMOmk8l72azaXlY1zB' \
-H 'accept: application/json'
```

Response body

```curl
{
"ok": true,
"result": "0:29023deb1272494b112310754aac7dd0660b68fcc40c3a693c97bd9acda5e563"
}
```

#### От удобной к Raw формату

/api/v2/packAddress

Curl

```curl
curl -X 'GET' \
'https://toncenter.com/api/v2/packAddress?address=0%3A29023deb1272494b112310754aac7dd0660b68fcc40c3a693c97bd9acda5e563' \
-H 'accept: application/json'
```

Response body

```json
{
  "ok": true,
  "result": "EQApAj3rEnJJSxEjEHVKrH3QZgto/MQMOmk8l72azaXlY1zB"
}
```

## См. также

- [TON HTTP API](/v3/guidelines/dapps/apis-sdks/ton-http-apis)
- [Список SDK](/v3/guidelines/dapps/apis-sdks/sdk)
- [TON Cookbook](/v3/guidelines/dapps/cookbook)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/getblock-ton-api.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/getblock-ton-api.md
================================================
# TON API от GetBlock

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

:::tip Состояние инфраструктуры TON

- [status.toncenter](https://status.toncenter.com/) - различная статистика активности узлов за последний час.
- [Tonstat.us](https://tonstat.us/) - Графана в реальном времени, обновляется каждые 5 минут
  :::

Это руководство охватит основные шаги получения и использования приватных конечных точек RPC от GetBlock для доступа к блокчейну TON.

:::info
[GetBlock](https://getblock.io/) - это поставщик Web3 инфраструктуры, предлагающий конечные точки API на основе HTTP для взаимодействия клиентов с различными блокчейн-сетями, включая TON.
:::

## Как получить доступ к конечным точкам блокчейна TON

Чтобы начать использовать конечные точки GetBlock, пользователи должны войти в свой аккаунт, получить URL-адрес для конечной точки TON и все готово к работе. Далее приведены более подробные инструкции.

### 1. Создайте учетную запись GetBlock

Посетите [веб-сайт] GetBlock (https://getblock.io/?utm_source=external&utm_medium=article&utm_campaign=ton_docs) и найдите на главной странице кнопку "Get Started for Free". Зарегистрируйте аккаунт, используя адрес электронной почты или подключив кошелек MetaMask.

![GetBlock.io\_main\_page](/img/docs/getblock-img/unnamed-2.png?=RAW)

### 2. Выберите блокчейн TON

После входа вы будете перенаправлены на панель управления. Найдите раздел, называемый "My Endpoints", и выберите "TON" в выпадающем меню "Protocols".

Выберите желаемую сеть и тип API (JSON-RPC или JSON-RPC(v2)).

![GetBlock\account\\_dashboard](/img/docs/getblock-img/unnamed-4.png)

### 3. Сгенерируйте URL конечной точки

Нажмите на кнопку "Get", чтобы сгенерировать URL-адрес вашей конечной точки блокчейна TON.

Все конечные точки в GetBlock API имеют последовательную структуру: `https://go.getblock.io/[ACCESS TOKEN]/`.

Эти токены доступа служат уникальными идентификаторами для каждого пользователя или приложения и содержат информацию, необходимую для маршрутизации запросов к соответствующим конечным точкам без раскрытия чувствительных данных. Они в конечном итоге заменяют необходимость отдельных заголовков авторизации или API-ключей.

Пользователи имеют возможность генерировать несколько конечных точек, заменять токены, если они скомпрометированы и удалять неиспользуемые конечные точки.

![GetBlock\_account\_endpoints](/img/docs/getblock-img/unnamed-3.png)

Теперь вы можете использовать эти URL-адреса для взаимодействия с блокчейном TON, запрашивать данные, отправлять транзакции и создавать децентрализованные приложения без необходимости настройки и поддержания инфраструктуры.

### Бесплатные запросы и ограничения для пользователей

Обратите внимание, что каждому зарегистрированному пользователю GetBlock предоставляется до 40 000 бесплатных запросов, ограниченных 60 запросами в секунду (RPS). Баланс запросов обновляется ежедневно и может использоваться на любых общих конечных точках для поддерживаемых блокчейн-сетей.

Для получения расширенных функций и возможностей пользователи могут воспользоваться платными опциями, которые будут описаны ниже.

GetBlock.io предлагает два типа тарифных планов: Общие узлы и Выделенные узлы. Клиенты могут выбрать тариф, исходя из своих требований и бюджета.

### Общие узлы

- Уровень доступа, где одни и те же узлы используются несколькими клиентами одновременно;
- Ограничение скорости увеличено до 200 RPS;
- Подходит для индивидуального использования или для приложений с меньшими объемами транзакций и требованиями к ресурсам по сравнению с полностью масштабированными производственными приложениями;
- Более доступный вариант для индивидуальных разработчиков или небольших команд с ограниченным бюджетом.

Общие узлы предлагают экономически эффективное решение для доступа к инфраструктуре блокчейна TON без необходимости значительных первоначальных инвестиций или обязательств.

По мере того как разработчики будут масштабировать свои приложения и нуждаться в дополнительных ресурсах, они смогут легко обновить свои планы подписки или перейти на выделенные узлы, если это будет необходимо.

### Выделенные узлы

- Один узел выделяется исключительно для одного клиента;
  Нет ограничений на запросы;
- Открывает доступ к архивным узлам, различным местоположениям серверов и пользовательским настройкам;
- Гарантирует клиентам обслуживание и поддержку на высшем уровне.

Это следующий уровень решения для разработчиков и децентрализованных приложений (dApps), требующих улучшенной пропускной способности, более высокой скорости подключения к узлам и гарантированных ресурсов при масштабировании.

## Как использовать TON HTTP API от GetBlock

В этом разделе мы погрузимся в практическое использование TON HTTP API, предоставленного GetBlock. Мы рассмотрим примеры, чтобы продемонстрировать, как эффективно использовать сгенерированные конечные точки для вашего взаимодействия с блокчейном.

### Примеры обычных вызовов API

Давайте начнем с простого примера, используя метод '/getAddressBalance' для получения баланса конкретного адреса с помощью команды curl.

```
curl --location --request GET 'https://go.getblock.io/[ACCESS-TOKEN]/getAddressBalance?address=EQDXZ2c5LnA12Eum-DlguTmfYkMOvNeFCh4rBD0tgmwjcFI-' \

--header 'Content-Type: application/json'
```

Не забудьте заменить `ACCESS-TOKEN` на ваш реальный токен доступа, предоставленный GetBlock.

Это выведет баланс в nanotons.

![getAddressBalance\_response\_on\_TON\_blockchain](/img/docs/getblock-img/unnamed-2.png)

Некоторые другие доступные методы для запросов к блокчейну TON:

| # | Метод | Конечная точка     | Описание                                                                                                           |
| - | ----- | ------------------ | ------------------------------------------------------------------------------------------------------------------ |
| 1 | GET   | getAddressState    | возвращает текущий статус (uninitialized, active, или frozen) указанного адреса в блокчейне TON |
| 2 | GET   | getMasterchainInfo | Получает информацию о состоянии masterchain                                                                        |
| 3 | GET   | getTokenData       | Получает подробные сведения об NFT или Jetton, связанных с указанным аккаунтом в сети TON                          |
| 4 | GET   | packAddress        | Преобразует адрес TON из raw формата в удобный для чтения                                                          |
| 5 | POST  | sendBoc            | Отправляет сериализованные файлы BOC вместе с внешними сообщениями в блокчейн для выполнения                       |

Пожалуйста, обратитесь к [документации] GetBlock (https://getblock.io/docs/ton/json-rpc/ton_jsonrpc/), чтобы получить подробную справочную информацию об API с примерами и списком дополнительных методов.

### Развертывание умных контрактов

Разработчики могут использовать те же URL-адреса конечных точек для непрерывного развертывания контрактов на блокчейне TON с использованием библиотеки TON.

Библиотека инициализирует клиент для подключения к сети через конечные точки HTTP API GetBlock.

![Изображение из TON Blueprint IDE](/img/docs/getblock-img/unnamed-6.png)

Этот руководство должно предоставить подробный обзор для разработчиков, которые хотят эффективно использовать API GetBlock с блокчейном TON.

Не стесняйтесь узнать больше на веб-сайте или написать в службу поддержки GetBlock через чат, Telegram или форму на сайте.




================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/overview.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/overview.md
================================================
# Обзор

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Цель этого статьи - помочь вам выбрать правильные инструменты для разработки приложений в экосистеме TON.

## Разработка TMA

- Используйте [Mini Apps SDKs](/v3/guidelines/dapps/tma/overview#mini-apps-sdks) для разработки [Мини приложений Telegram](/v3/guidelines/dapps/tma/overview).
- Выберите [SDK, базирующийся на JS/TS](/v3/guidelines/dapps/apis-sdks/sdk#typescript--javascript) для взаимодействия с блокчейном TON.

## Разработка DApps

- Используйте Tolk, FunC или Tact [языки программирования](/v3/documentation/smart-contracts/overview#programming-languages), если требуется разработка умных контрактов на блокчейне TON для вашего [DApp](/v3/guidelines/dapps/overview).
- Чтобы взаимодействовать с блокчейном TON и обрабатывать его данные, выберите один из перечисленных [SDK](/v3/guidelines/dapps/apis-sdks/sdk). Одними из самых популярных языков для этого назначения:
    - [JS/TS](/v3/guidelines/dapps/apis-sdks/sdk#typescript--javascript)
    - [Go](/v3/guidelines/dapps/apis-sdks/sdk#go)
    - [Python](/v3/guidelines/dapps/apis-sdks/sdk#python)
- Чтобы интегрировать аутентификацию пользователей с их кошельками TON (включая логику обработки платежей) в ваш DApp, используйте [TON Connect](/v3/guidelines/ton-connect/overview).

## Аналитика данных TON

Довольно часто разработчикам необходимо выполнять аналитические запросы поверх данных on-chain: например, для отслеживания исторических изменений и агрегирования данных из нескольких аккаунтов.
Блокчейны не предназначены для такого рода рабочей нагрузки, и необходимо построить конвейер индексации и запустить аналитические запросы off-chain. Создание таких конвейеров
с нуля может быть ресурсоемким, поэтому можно использовать одну из следующих альтернатив:

- Dune Analytics содержит набор таблиц с данными TON: необработанные транзакции и сообщения, события с жетонами и сделки на DEX. Dune позволяет создавать пользовательские диаграммы и панели мониторинга, получать результаты запросов через API и настраивать оповещения. Перед началом написания запросов, пожалуйста, ознакомьтесь с этим руководством для получения рекомендаций, советов и трюков.
- Интеграция Dune основана на базе общедоступного хранилища данных проекта [ton-etl](https://github.com/re-doubt/ton-etl/blob/main/datalake/README.md). Это конвейер анализа и декодирования, который загружает необработанные и декодированные данные в контейнер S3 **s3://ton-blockchain-public-datalake/v1/** в формате AVRO. Контейнер общедоступный, и каждый может использовать его с такими инструментами, как [Amazon Athena](https://aws.amazon.com/athena/) (см. [DDL](https://github.com/re-doubt/ton-etl/blob/main/datalake/athena_ddl.sql)) или Apache Spark. Данные обновляются ежедневно.
- Если вам необходимо отслеживать данные в цепочке практически в режиме реального времени, вы можете запустить свой собственный [Узел Ton](/v3/documentation/infra/nodes/node-types) и запустить [ton-etl](https://github.com/re-doubt/ton-etl/blob/main/README.md) или [ton-index-worker](https://github.com/toncenter/ton-index-worker).
- [chainbase](https://docs.chainbase.com/catalog/Ton/Overview) поставляется с набором необработанных и декодированных таблиц с данными TON. Позволяет выполнять SQL-запросы и получать результаты через API.

## Состояние инфраструктуры

- [status.toncenter](https://status.toncenter.com/) - различная статистика активности узлов за последний час.
- [Tonstat.us](https://tonstat.us/) - Графана в реальном времени, обновляется каждые 5 минут.

## См. также

- [SDK](/v3/guidelines/dapps/apis-sdks/sdk)
- [Руководства по разработке TMA](/v3/guidelines/dapps/tma/tutorials/step-by-step-guide)
- [Руководства по TON Connect](/v3/guidelines/ton-connect/guidelines/how-ton-connect-works)
- [Обработка платежей](/v3/guidelines/dapps/asset-processing/payments-processing)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/sdk.mdx
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/sdk.mdx
================================================
# SDK

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Мгновенно перейдите в ваш предпочтительный язык, используя правую боковую панель.

## Обзор

Существует несколько способов подключения к блокчейну:

1. Поставщик данных RPC или другой API: в большинстве случаев вам нужно _полагаться_ на его стабильность и безопасность.
2. Подключение через ADNL вы подключаетесь к [liteserver](/v3/guidelines/nodes/running-nodes/liteserver-node). Они могут быть недоступны, но при определенном уровне валидации (реализованном в библиотеке), не могут лгать.
3. Бинарный файл Tonlib: вы также подключаетесь к liteserver, поэтому к нему применимы все преимущества и недостатки. Однако ваше приложение также содержит динамически загружаемую библиотеку, скомпилированную вне.
4. Только Offchain. Эти SDK позволяют создавать и сериализовывать ячейки, которые можно передавать в API.

### TypeScript / JavaScript

| Библиотека                                      | Подключение к блокчейну                                                                                    | Описание                                                                                                                                                                                             |
| ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [ton](https://github.com/ton-org/ton)           | через RPC ([Orbs](https://www.orbs.com/ton-access/) / [Toncenter](https://toncenter.com/api/v2/) / и т.д.) | Удобная клиентская библиотека с обертками кошельков для разработки dApps на блокчейне TON.                                                                                                           |
| [tonweb](https://github.com/toncenter/tonweb)   | через RPC ([Orbs](https://www.orbs.com/ton-access/) / [Toncenter](https://toncenter.com/api/v2/) / и т.д.) | TON JS SDK старого образца, с минимальным количеством внешних зависимостей, тщательно протестированный в производстве.                                                                               |
| [tonkite/adnl](https://github.com/tonkite/adnl) | [ADNL](/v3/documentation/network/protocols/adnl/adnl-tcp) нативно / через WebSocket                        | TypeScript реализация ADNL.                                                                                                                                                                          |
| [tonutils](https://github.com/thekiba/tonutils) | Собственный [ADNL](/v3/documentation/network/protocols/adnl/adnl-tcp)                                      | Интерфейс на основе TypeScript для создания и взаимодействия с приложениями в экосистеме TON. Из-за нативной зависимости от ADNL его нельзя использовать для взаимодействия с блокчейном в браузере. |
| [foton](https://foton.sh/)                      | через RPC ([Orbs](https://www.orbs.com/ton-access/) / [Toncenter](https://toncenter.com/api/v2/) / и т.д.) | Инструментарий на основе TypeScript для взаимодействия с кошельками TON и самим блокчейном в целом. Библиотека объединяет существующие решения (Blueprint и TON Connect) в один удобный API.         |

### Java

| Библиотека                                 | Подключение к блокчейну | Описание                            |
| ------------------------------------------ | ----------------------- | ----------------------------------- |
| [ton4j](https://github.com/neodix42/ton4j) | Двоичные файлы Tonlib   | Java SDK для The Open Network (TON) |

### Python

<!-- tonsdk был исключен из-за неправильной сериализации ячеек, он сейчас устарел -->

| Библиотека                                                    | Подключение к блокчейну                                                                                                                                        | Описание                                                                                                                                     |
| ------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| [pytoniq](https://github.com/yungwine/pytoniq)                | Встроенный ADNL                                                                                                                                                | SDK на языке Python с нативным LiteClient и другими реализациями протоколов на основе ADNL.                                                  |
| [pytoniq-core](https://github.com/yungwine/pytoniq-core)      | _только для offchain_                                                                                                                                          | Мощный transport-free SDK на языке Python                                                                                                    |
| [tonutils](https://github.com/nessshon/tonutils)              | через RPC ([TONAPI](https://tonapi.io/api-v2) / [Toncenter](https://toncenter.com/api/v3/)) / Встроенный ADNL ([pytoniq](https://github.com/yungwine/pytoniq)) | Tonutils — это высокоуровневая объектно-ориентированная библиотека для Python, предназначенная для упрощения взаимодействия с блокчейном TON |
| [pytonlib](https://github.com/toncenter/pytonlib)             | Двоичные файлы Tonlib                                                                                                                                          | Это автономная библиотека Python, основанная на libtonlibjson, представленная в виде бинарной зависимости от TON monorepo.                   |
| [mytonlib](https://github.com/igroman787/mytonlib)            | Встроенный ADNL                                                                                                                                                | Нативная библиотека Python SDK для работы с The Open Network                                                                                 |
| [TonTools](https://github.com/yungwine/TonTools)              | через RPC ([Orbs](https://www.orbs.com/ton-access/) / [Toncenter](https://toncenter.com/api/v2/) / и т.д.)                                                     | TonTools - это высокоуровневая объектно-ориентированная библиотека для Python, которая позволяет взаимодействовать с блокчейном TON.         |
| [tonpy](https://github.com/disintar/tonpy)                    | Встроенный ADNL                                                                                                                                                | Python пакет, предоставляющий структуры данных и API для взаимодействия с блокчейном TON.                                                    |
| [tvm_valuetypes](https://github.com/toncenter/tvm_valuetypes) | _только для offchain_                                                                                                                                          | библиотека — это набор инструментов для работы с типами TVM.                                                                                 |
| [pytvm](https://github.com/yungwine/pytvm)                    | _offchain_                                                                                                                                                     | Python эмулятор TVM, использующий привязки к стандартному C++ эмулятору                                                                      |

### C#

| Библиотека                                                        | Подключение к блокчейну | Описание                                                                                                                                                      |
| ----------------------------------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [TonSdk.NET](https://github.com/continuation-team/TonSdk.NET)     | Встроенный ADNL или RPC | Нативный C# SDK для The Open Network.                                                                                                                         |
| [justdmitry/TonLib.NET](https://github.com/justdmitry/TonLib.NET) | Двоичные файлы Tonlib   | .NET SDK для The Open Network, подключаемый через libtonlibjson, подключающийся через libtonlibjson, представлен в виде бинарной зависимости от TON monorepo. |

### Rust

| Библиотека                                                    | Подключение к блокчейну | Описание                                                                                                                       |
| ------------------------------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| [tonlib-rs](https://github.com/ston-fi/tonlib-rs)             | Двоичные файлы Tonlib   | Rust SDK для The Open Network, добавляющий бинарную зависимость от TON monorepo.                                               |
| [getgems-io/ton-grpc](https://github.com/getgems-io/ton-grpc) | Двоичные файлы Tonlib   | Привязки Rust для tonlibjson (таким образом, зависящие от двоичного файла из TON monorepo) и сервисов, построенных поверх него |

### Go

| Библиотека                                               | Подключение к блокчейну | Описание                                              |
| -------------------------------------------------------- | ----------------------- | ----------------------------------------------------- |
| [tonutils-go](https://github.com/xssnick/tonutils-go)    | Встроенный ADNL         | Библиотека Golang для взаимодействия с блокчейном TON |
| [tongo](https://github.com/tonkeeper/tongo)              | Встроенный ADNL         | Реализация библиотек на языке Go для блокчейна TON    |
| [tonlib-go](https://github.com/ton-blockchain/tonlib-go) | Двоичные файлы Tonlib   | Официальные привязки для libtonlibjson                |

### SDK для других языков

| Библиотека                                                                  | Язык   | Подключение к блокчейну                                                                                    | Описание                                                                       |   |
| --------------------------------------------------------------------------- | ------ | ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | - |
| [ton-kotlin](https://github.com/ton-community/ton-kotlin)                   | Kotlin | Встроенный ADNL                                                                                            | Kotlin/Multiplatform SDK для The Open Network.                                 |   |
| [tonlib-java](https://github.com/ton-blockchain/tonlib-java)                | Java   | Двоичные файлы Tonlib                                                                                      | JVM оболочка для TonLib, которую можно использовать с Java/Scala/Kotlin/и т.д. |   |
| [ayrat555/ton](https://github.com/ayrat555/ton)                             | Elixir | _только для offchain_                                                                                      | TON SDK для Elixir.                                                            |   |
| [C++ Tonlib](https://github.com/ton-blockchain/ton/tree/master/example/cpp) | C++    | Двоичные файлы Tonlib                                                                                      | Официальные примеры по взаимодействию с умными контрактами в TON monorepo      | . |
| [Java Tonlib](https://github.com/ton-blockchain/tonlib-java)                | Java   | Двоичные файлы Tonlib                                                                                      | Официальные примеры по взаимодействию с умными контрактами в TON monorepo.     |   |
| [labraburn/SwiftyTON](https://github.com/labraburn/SwiftyTON)               | Swift  | Двоичные файлы Tonlib                                                                                      | Встроенная оболочка Swift для tonlib с функцией async/await.                   |   |
| [tonlib-xcframework](https://github.com/labraburn/tonlib-xcframework)       | Swift  | Двоичные файлы Tonlib                                                                                      | Помощник сборки Tonlib для iOS, все архитектуры.                               |   |
| [labraburn/node-tonlib](https://github.com/labraburn/node-tonlib)           | NodeJS | Двоичные файлы Tonlib                                                                                      | Дополнение на C++ для NodeJS для работы с tonlibjson.                          |   |
| [olifanton/ton](https://github.com/olifanton/ton)                           | PHP    | через RPC ([Orbs](https://www.orbs.com/ton-access/) / [Toncenter](https://toncenter.com/api/v2/) / и т.д.) | PHP SDK с набором стандартных примитивов и контрактов.                         |   |



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/ton-adnl-apis.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/ton-adnl-apis.md
================================================
# TON ADNL API

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Существует несколько способов подключения к блокчейну:

1. Поставщик данных RPC или другой API: в большинстве случаев вам нужно *полагаться* на его стабильность и безопасность.
2. **ADNL-соединение**: вы подключаетесь к [liteserver](/v3/guidelines/nodes/running-nodes/liteserver-node). Они могут быть недоступны, но при определенном уровне проверки (реализованном в библиотеке) не могут лгать.
3. Двоичный файл Tonlib: вы также подключаетесь к liteserver, поэтому все преимущества и недостатки остаются, но ваше приложение также содержит библиотеку с динамической загрузкой, скомпилированную извне.
4. Только для offchain. Такие SDK позволяют создавать и сериализовать ячейки, которые затем можно отправить в API.

Клиенты подключаются непосредственно к Liteserver (узлам), используя двоичный протокол.

Клиент загружает ключевые блоки, текущее состояние аккаунта и их **Доказательства Меркла**, что гарантирует достоверность полученных данных.

Операции чтения (например, вызов get-метода) выполняются путем запуска локального TVM с загруженным и проверенным состоянием. Важно отметить, что нет необходимости скачивать полное состояние блокчейна; клиент загружает только то, что необходимо для операции.

Вы можете подключиться к публичным Liteserver из глобальной конфигурации ([основной сети](https://ton.org/global-config.json) или [местовой сети](https://ton.org/testnet-global.config.json)), либо запустить свой собственный [Liteserver](/v3/documentation/infra/nodes/node-types) и управлять им с помощью [ADNL SDK](/v3/guidelines/dapps/apis-sdks/sdk#overview).

Подробнее о [Доказательствах Меркла](/v3/documentation/data-formats/tlb/proofs) читайте в [Техническом документе TON](https://ton.org/ton.pdf) 2.3.10, 2.3.11.

Публичные liteserver (из глобальной конфигурации) существуют для быстрого начала работы с TON. Они могут использоваться для обучения программированию в TON или для приложений и скриптов, которым не требуется 100% бесперебойной работы.

Для создания рабочей инфраструктуры - рекомендуется использовать хорошо подготовленную инфраструктуру:

- [настроить собственный liteserver](/v3/guidelines/nodes/running-nodes/liteserver-node),
- использовать премиум-провайдеров Liteserver [@liteserver_bot](https://t.me/liteserver_bot)

## Плюсы и минусы

- ✅ Надежность. Использует API с хэшами доказательств Меркла для проверки входящих двоичных данных.

- ✅ Безопасный. Поскольку он проверяет доказательства Меркла, вы даже можете использовать ненадежные liteserver.

- ✅ Быстрый. Подключается напрямую к узлам блокчейна TON, вместо использования промежуточного ПО HTTP.

- ❌ Сложно. Требуется больше времени, чтобы разобраться.

- ❌ Сначала бэкенд. Несовместим с веб-фронтендами (созданными для протокола, отличного от HTTP) или требует прокси-сервера HTTP-ADNL.

## Справочник API

Запросы и ответы к серверу описываются схемой [TL](/v3/documentation/data-formats/tl), которая позволяет вам генерировать типизированный интерфейс для определенного языка программирования.

[Схема TonLib TL](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/tonlib_api.tl)



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/ton-http-apis.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/apis-sdks/ton-http-apis.md
================================================
# TON API на основе HTTP

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

Существует несколько способов подключения к блокчейну:

1. **Поставщик данных RPC или другой API**: в большинстве случаев вам придется *положиться* на его стабильность и безопасность.
2. Подключение ADNL: вы подключаетесь к [liteserver](/v3/guidelines/nodes/running-nodes/liteserver-node). Он может быть недоступен, но при определенном уровне проверки (реализованном в библиотеке) он не может лгать.
3. Двоичный файл Tonlib: вы также подключаетесь к liteserver, поэтому остаются все преимущества и недостатки, но ваше приложение включает динамически загружаемую библиотеку, скомпилированную извне.
4. Только для Offchain. Такие SDK позволяют создавать и сериализовать ячейки, которые затем можно отправить в API.

## Плюсы и минусы

- ✅ Привычный и подходящий для быстрого старта, он идеально подходит для каждого новичка, который хочет поиграть с TON.

- ✅ Веб-ориентированный. Идеально подходит для загрузки данных из смарт-контрактов TON через Интернет, а также позволяет отправлять сообщения.

- ❌ Упрощенный. Невозможно получить информацию, когда вам нужен индексированный API TON.

- ❌ HTTP-промежуточное программное обеспечение.  Вы не сможете полностью доверять ответам сервера, если сервер не дополнит данные блокчейна [доказательствами Меркла](/v3/documentation/data-formats/tlb/proofs) для проверки их подлинности.

## Узлы RPC

:::tip Состояние инфраструктуры TON

- [status.toncenter](https://status.toncenter.com/) - различная статистика активности узлов за последний час.

- [Tonstat.us](https://tonstat.us/) - Графана в реальном времени, обновляется каждые 5 минут
  :::

- [QuickNode](https://www.quicknode.com/chains/ton?utm_source=ton-docs) — ведущий поставщик узлов блокчейна, предлагающий самый быстрый доступ с интеллектуальной маршрутизацией DNS для оптимизированного глобального охвата и масштабируемости с балансировкой нагрузки.

- [Chainstack](https://chainstack.com/build-better-with-ton/) - узлы RPC и индексатор в нескольких регионах с географическим распределением и балансировкой нагрузки.

- [Tatum](https://docs.tatum.io/reference/rpc-ton) - доступ к RPC узлам TON и мощным инструментам разработчика в одной простой для использования платформе.

- [GetBlock Nodes](https://getblock.io/nodes/ton/) - подключитесь и протестируйте свои dApps с использованием узлов GetBlock

- [TON Access](https://www.orbs.com/ton-access/) - HTTP API для The Open Network (TON).

- [Toncenter](https://toncenter.com/api/v2/) — проект сообщества для быстрого старта с API. (Получите ключ API [@tonapibot](https://t.me/tonapibot))

- [ton-node-docker](https://github.com/fmira21/ton-node-docker) - Полный узел Docker и API Toncenter.

- [toncenter/ton-http-api](https://github.com/toncenter/ton-http-api) — запустите свой собственный RPC-узел.

- [nownodes.io](https://nownodes.io/nodes) — полноценные узлы NOWNodes и обозреватели блокчейнов через API.

- [Chainbase](https://chainbase.com/chainNetwork/TON) — API узлов и инфраструктура данных для The Open Network.

## Индексатор

### Индексатор Toncenter TON

Индексаторы позволяют составлять список кошельков жетонов, NFT, транзакций по определенным фильтрам, а не только извлекать конкретные из них.

- Можно использовать публичный индекс TON: тестирование и разработка бесплатны, [премиум](https://t.me/tonapibot) для рабочей среды - [toncenter.com/api/v3/](https://toncenter.com/api/v3/).
- Запустите свой собственный индексатор TON с помощью [Worker](https://github.com/toncenter/ton-index-worker/tree/36134e7376986c5517ee65e6a1ddd54b1c76cdba) и [оболочки API индексатора TON](https://github.com/toncenter/ton-indexer).

### Anton

Написанный на Go, Anton — это индексатор блокчейна The Open Network с открытым исходным кодом, доступный по лицензии Apache License 2.0. Anton разработан для предоставления разработчикам масштабируемого, гибкого решения для доступа и анализа данных блокчейна. Наша цель — помочь разработчикам и пользователям понять, как используется блокчейн, и дать разработчикам возможность добавлять собственные контракты с пользовательскими схемами сообщений в наш проводник.

- [Проект GitHub](https://github.com/tonindexer/anton) - для запуска собственного индексатора
- [Документация по API Swagger](https://github.com/tonindexer/anton), [Примеры запросов к API](https://github.com/tonindexer/anton/blob/main/docs/API.md) - чтобы использовать, изучите документацию и примеры
- [Apache Superset](https://github.com/tonindexer/anton) - для просмотра данных

### Узлы GraphQL

Узлы GraphQL также действуют как индексаторы.

- dton.io](https://dton.io/graphql) - а также предоставление данных контрактов, дополненных проанализированными флагами "is jetton", "is NFT", позволяет эмулировать транзакции и получать трассировки выполнения.

## Другие API

- [TonAPI](https://docs.tonconsole.com/tonapi) — API, разработанный для того, чтобы предоставить пользователям упрощенный интерфейс, не беспокоясь о низкоуровневых деталях смарт-контрактов.



================================================
FILE: i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/asset-processing/jettons.md
URL: https://github.com/ton-community/ton-docs/blob/main/i18n/ru/docusaurus-plugin-content-docs/current/v3/guidelines/dapps/asset-processing/jettons.md
================================================
import ThemedImage from '@theme/ThemedImage';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/components/button';

# Обработка жетонов

:::warning
Эта страница переведена сообществом на русский язык, но нуждается в улучшениях. Если вы хотите принять участие в переводе свяжитесь с [@alexgton](https://t.me/alexgton).
:::

## Лучшие практики обработки жетонов

Жетоны - это токены в блокчейне TON - их можно рассматривать аналогично токенам ERC-20 в сети Ethereum.

:::info Подтверждение транзакции
Транзакции в TON становятся необратимыми уже после одного подтверждения. Для лучшего пользовательского опыта (UX/UI) рекомендуется избегать дополнительного ожидания.
:::

#### Вывод средств

[Highload Wallet v3](/v3/documentation/smart-contracts/contracts-specs/highload-wallet#highload-wallet-v3) - это новейшее решение блокчейна TON, которое является золотым стандартом для вывода жетонов. Он позволяет вам воспользоваться преимуществами пакетной отправки средств.

[Пакетное снятие средств](https://github.com/toncenter/examples/blob/main/withdrawals-jettons-highload-batch.js) - означает, что несколько переводов отправляются пакетами, что обеспечивает быстрый и дешевый вывод средств.

#### Зачисления

:::info
Рекомендуется настроить несколько кошельков пополнения MEMO для улучшения производительности.
:::

[Пополнения с Memo](https://github.com/toncenter/examples/blob/main/deposits-jettons.js) - позволяет вам иметь один кошелек пополнения, и пользователи добавляют Memo, чтобы быть идентифицированными вашей системой. Это означает, что вам не нужно сканировать весь блокчейн, но это немного менее удобно для пользователей.

[Пополнения без Memo](https://github.com/gobicycle/bicycle) - Это решение также существует, но его интеграция более сложна. Однако мы можем помочь вам с этим, если вы предпочтете выбрать этот путь. Пожалуйста, уведомите нас до того, как решите реализовать этот подход.

### Дополнительная информация

:::caution Уведомление о транзакции
Ожидается, что каждый сервис в Экосистеме установит `forward_ton_amount` равный 0,000000001 TON (1 нанотон), когда будет производиться вывод жетонов, чтобы отправить Jetton Notify при [успешном переводе](https://testnet.tonviewer.com/transaction/a0eede398d554318326b6e13081c2441f8b9a814bf9704e2e2f44f24adb3d407), иначе перевод не будет соответствовать стандарту и не сможет быть обработан другими CEX и сервисами.
:::

- Пожалуйста, найдите пример JS lib - [tonweb](https://github.com/toncenter/tonweb) - это официальная JS библиотека от TON Foundation.

- Если Вы хотите использовать Java, Вы можете заглянуть в [ton4j](https://github.com/neodix42/ton4j/tree/main).

- Для Go следует рассмотреть [tonutils-go](https://github.com/xssnick/tonutils-go). На данный момент мы рекомендуем JS lib.

## Оглавление

:::tip
В следующих документах представлены подробные сведения об архитектуре жетонов в целом, а также основные концепции TON, которые могут отличаться от EVM-подобных и других блокчейнов. Это крайне важно, чтобы получить хорошее понимание TON, и оно значительно поможет вам.
:::

В этом документе описано следующее по порядку:

1. Общие сведения
2. Архитектура
3. Контракт Jetton Master (Выпуск токенов)
4. Контракт Jetton Wallet (кошелек пользователя)
5. Макеты сообщений
6. Обработка жетонов (off-chain)
7. Обработка жетонов (on-chain)
8. Обработка кошелька
9. Лучшие практики

## Общие сведения

:::info
Транзакции TON необратимы после одного подтверждения.
Для ясного понимания читатель должен быть знаком с основными принципами обработки активов, описанными в [этом разделе нашей документации](/v3/documentation/dapps/assets/overview). В частности, важно знать [контракты](/v3/documentation/smart-contracts/addresses#everything-is-a-smart-contract), [кошельки](/v3/guidelines/smart-contracts/howto/wallet), [сообщения](/v3/documentation/smart-contracts/message-management/messages-and-transactions) и процесс развертывания.
:::

:::info
Для лучшего пользовательского опыта рекомендуется избегать ожидания дополнительных блоков после того, как транзакции будут завершены в блокчейне TON. Подробнее можно прочитать в [Catchain.pdf](https://docs.ton.org/catchain.pdf#page=3).
:::

Быстрый переход к основному описанию обработки Jetton:

<Button href="/v3/guidelines/dapps/asset-processing/jettons#accepting-jettons-from-users-through-a-centralized-wallet" colorType={'primary'} sizeType={'sm'}>
Централизованная обработка 
</Button>

<Button href="/v3/guidelines/dapps/asset-processing/jettons#accepting-jettons-from-user-deposit-addresses"
colorType="secondary" sizeType={'sm'}>
On-Chain обработка 
</Button>

<br></br><br></br>

Блокчейн TON и лежащая в его основе экосистема классифицируют взаимозаменяемые токены (FT) как жетоны. Поскольку в блокчейне применяется шардинг, наша реализация взаимозаменяемых токенов уникальна по сравнению с аналогичными моделями блокчейнов.

В этом анализе мы более подробно рассмотрим формальные стандарты, описывающи [поведение](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md) и [метаданные](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md) жетонов.
Менее формальный обзор архитектуры жетонов, ориентированный на шардинг, можно найти в нашем блоге ["anatomy of jettons"](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons).

Мы также предоставили конкретные подробности, обсуждая наш процессор платежей TON с открытым исходным кодом ([bicycle](https://github.com/gobicycle/bicycle)), который позволяет пользователям вносить и выводить как Toncoin, так и жетоны, используя отдельный адрес депозита без использования текстового поля memo.

## Архитектура Jetton

Стандартизированные токены в TON реализованы с использованием набора смарт-контрактов, включая:

- Смарт-контракт [Jetton master](https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-minter.fc)
- Смарт-контракт [Jetton wallet](https://github.com/ton-blockchain/token-contract/blob/main/ft/jetton-wallet.fc)

<br></br>
<ThemedImage
alt=""
sources={{
light: '/img/docs/asset-processing/jetton_contracts.png?raw=true',
dark: '/img/docs/asset-processing/jetton_contracts_dark.png?raw=true',
}}
/> <br></br>

## Смарт-контракт Jetton master

Смарт-контракт jetton master хранит общую информацию о жетоне (включая общее предложение, ссылку на метаданные или сами метаданные).

:::warning Остерегайтесь мошенничества с жетонами

Jetton с `symbol` ==`TON` или те, которые содержат системные уведомления, такие как: ERROR, SYSTEM и другие. Обязательно проверьте, отображаются ли жетоны в вашем интерфейсе таким образом, чтобы их нельзя было смешивать с переводами TON, системными уведомлениями и т. д. Иногда даже `symbol`, `name` и `image` созданы таким образом, чтобы выглядеть почти одинаково с оригиналом с целью обмана пользователей.

Чтобы исключить возможность мошенничества для пользователей TON, пожалуйста, найдите **оригинальный адрес жетона** (Смарт-контракт Jetton master) для определенных типов жетонов или **перейдите на официальный канал или веб-сайт проекта в социальных сетях** для получения **правильной информации**. Проверяйте активы, чтобы исключить возможность мошенничества с помощью списка [Tonkeeper ton-assets](https://github.com/tonkeeper/ton-assets).
:::

### Получение данных о жетоне

Для извлечения более конкретных данных жетона используйте *get* метод контракта `get_jetton_data()`.

Этот метод возвращает следующие данные:

| Имя                  | Тип     | Описание                                                                                                                                                                                                                                                                                                        |
| -------------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `total_supply`       | `int`   | общее количество выпущенных жетонов, измеренное в неделимых единицах.                                                                                                                                                                                                                           |
| `mintable`           | `int`   | информация о возможности чеканки новых жетонов. Это значение равно -1 (можно чеканить) или 0 (нельзя чеканить).                                                                                                                           |
| `admin_address`      | `slice` |                                                                                                                                                                                                                                                                                                                 |
| `jetton_content`     | `cell`  | данные в соответствии с [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md), см. [страницу анализа метаданных жетона](/v3/guidelines/dapps/asset-processing/nft-processing/metadata-parsing) для получения дополнительной информации. |
| `jetton_wallet_code` | `cell`  |                                                                                                                                                                                                                                                                                                                 |

Также можно использовать метод `/jetton/masters` из [Toncenter API](https://toncenter.com/api/v3/#/default/get_jetton_masters_api_v3_jetton_masters_get) для получения уже декодированных данных и метаданных жетона. Мы также разработали методы для (js) [tonweb](https://github.com/toncenter/tonweb/blob/master/src/contract/token/ft/JettonMinter.js#L85) и (js) [ton-core/ton](https://github.com/ton-core/ton/blob/master/src/jetton/JettonMaster.ts#L28), (go) [tongo](https://github.com/tonkeeper/tongo/blob/master/liteapi/jetton.go#L48) и (go) [tonutils-go](https://github.com/xssnick/tonutils-go/blob/33fd62d754d3a01329ed5c904db542ab4a11017b/ton/jetton/jetton.go#L79), (python) [pytonlib](https://github.com/toncenter/pytonlib/blob/d96276ec8a46546638cb939dea23612876a62881/pytonlib/client.py#L742) и многих других [SDK](/v3/guidelines/dapps/apis-sdks/sdk).

Пример использования [Tonweb](https://github.com/toncenter/tonweb) для запуска метода get и получения url для метаданных off-chain:

```js
import TonWeb from "tonweb";
const tonweb = new TonWeb();
const jettonMinter = new TonWeb.token.jetton.JettonMinter(tonweb.provider, {address: "<JETTON_MASTER_ADDRESS>"});
const data = await jettonMinter.getJettonData();
console.log('Total supply:', data.totalSupply.toString());
console.log('URI to off-chain metadata:', data.jettonContentUri);
```

### Jetton minter

Как упоминалось ранее, жетоны могут быть либо выпускаемыми `mintable`, либо не выпускаемыми `non-mintable`.

Если они не выпускаемые, логика становится простой — нет способа чеканить дополнительные токены. Чтобы чеканить жетоны в первый раз, обратитесь к странице [выпуск своего первого жетона](/v3/guidelines/dapps/tutorials/mint-your-first-token).

Если жетоны выпускаемые, в [minter contract](https://github.com/ton-blockchain/minter-contract/blob/main/contracts/jetton-minter.fc) есть специальная функция для чеканки дополнительных жетонов. Эту функцию можно вызвать, отправив внутреннее сообщение со специальным opcode с адреса администратора.

Если администратор жетона хочет ограничить их выпуск, есть три способа сделать это:

1. Если вы не можете или не хотите обновлять код контракта, администратор должен передать право собственности с текущего администратора на нулевой адрес. Это оставит контракт без действующего администратора, таким образом, не давая никому возможности чеканить жетоны. Однако это также предотвратит любые изменения метаданных жетона.
2. Если у вас есть доступ к исходному коду и вы можете его изменить, вы можете создать метод в контракте, который устанавливает флаг для прерывания любого процесса чеканки после его вызова, и добавит инструкцию для проверки этого флага в функции выпуска.
3. Если вы можете обновлять код контракта, вы можете добавить ограничения, обновив код уже развернутого контракта.

## Смарт-контракт Jetton wallet

Контракты `Jetton wallet` используются для **отправки**, **получения** и **сжигания** жетонов. Каждый *контракт jetton wallet* хранит информацию о балансе кошелька для определенных пользователей.
В некоторых случаях jetton wallet используются отдельно для каждого владельца жетона для каждого его типа.

`Jetton wallets` **не следует путать с кошельками**, предназначенными для взаимодействия с блокчейном и хранящих только актива Toncoin (например, кошельки v3R2, highload кошельки и т.д.), которые отвечают за поддержку и управление только определенным типом жетонов.

### Развертывание Jetton Wallet

При `передаче жетонов` между кошельками транзакции (сообщения) требуют определенного количества TON в качестве оплаты сетевых комиссий за **газ** и выполнения действий согласно коду контракта Jetton wallet.
Это означает, что получателю не нужно развертывать Jetton wallet перед получением жетонов. Jetton wallet получателя будет развернут автоматически, если отправитель имеет достаточно TON в кошельке для оплаты необходимых комиссий за газ.

### Получение адреса Jetton wallet для конкретного пользователя

Для получения `jetton wallet` `address` с помощью `owner address`(адрес кошелька TON), `Jetton master contract` предоставляет get метод `get_wallet_address(slice owner_address)`.

<Tabs groupId="retrieve-wallet-address">
<TabItem value="api" label="API">

> Запустите `get_wallet_address(slice owner_address)` через метод `/runGetMethod` из [Toncenter API](https://toncenter.com/api/v3/#/default/run_get_method_api_v3_runGetMethod_post). В реальных случаях (не в тестовых) важно всегда проверять, что кошелек действительно принадлежит нужному Jetton Master. Подроднее смотрите пример кода.

</TabItem>
<TabItem value="js" label="js">

```js
import TonWeb from 'tonweb';
const tonweb = new TonWeb();
const jettonMinter = new TonWeb.token.jetton.JettonMinter(tonweb.provider, { address: '<JETTON_MASTER_ADDRESS>' });
const jettonWalletAddress = await jettonMinter.getJettonWalletAddress(new TonWeb.utils.Address('<OWNER_WALLET_ADDRESS>'));

// It is important to always check that wallet indeed is attributed to desired Jetton Master:
const jettonWallet = new TonWeb.token.jetton.JettonWallet(tonweb.provider, {
  address: jettonWalletAddress
});
const jettonData = await jettonWallet.getData();
if (jettonData.jettonMinterAddress.toString(false) !== jettonMinter.address.toString(false)) {
  throw new Error('jetton minter address from jetton wallet doesnt match config');
}

console.log('Jetton wallet address:', jettonWalletAddress.toString(true, true, true));
```

</TabItem>
</Tabs>

:::tip
Дополнительные примеры можно найти в [TON Cookbook](/v3/guidelines/dapps/cookbook#tep-74-jettons-standard).
:::

### Получение данных для определенного Jetton wallet

Чтобы получить баланс кошелька, данные об владельце и другую информацию, связанную с конкретным контрактом jetton wallet, используйте get метод `get_wallet_data()` в контракте jetton wallet.

Этот метод возвращает следующие данные:

| Имя                  | Тип   |
| -------------------- | ----- |
| `balance`            | int   |
| `owner`              | slice |
| `jetton`             | slice |
| `jetton_wallet_code` | cell  |

<Tabs groupId="retrieve-jetton-wallet-data">
<TabItem value="api" label="API">

> Используйте get метод `/jetton/wallets` из [API Toncenter](https://toncenter.com/api/v3/#/default/get_jetton_wallets_api_v3_jetton_wallets_get) для получения ранее декодированных данных jetton wallet.

</TabItem>

<TabItem value="js" label="js">

```js
import TonWeb from "tonweb";
const tonweb = new TonWeb();
const walletAddress = "EQBYc3DSi36qur7-DLDYd-AmRRb4-zk6VkzX0etv5Pa-Bq4Y";
const jettonWallet = new TonWeb.token.jetton.JettonWallet(tonweb.provider,{address: walletAddress});
const data = await jettonWallet.getData();
console.log('Jetton balance:', data.balance.toString());
console.log('Jetton owner address:', data.ownerAddress.toString(true, true, true));
// It is important to always check that Jetton Master indeed recognize wallet
const jettonMinter = new TonWeb.token.jetton.JettonMinter(tonweb.provider, {address: data.jettonMinterAddress.toString(false)});
const expectedJettonWalletAddress = await jettonMinter.getJettonWalletAddress(data.ownerAddress.toString(false));
if (expectedJettonWalletAddress.toString(false) !== new TonWeb.utils.Address(walletAddress).toString(false)) {
  throw new Error('jetton minter does not recognize the wallet');
}

console.log('Jetton master address:', data.jettonMinterAddress.toString(true, true, true));
```

</TabItem>
</Tabs>

## Макеты сообщений

:::tip Сообщения
Подробнее о сообщениях читайте [здесь](/v3/documentation/smart-contracts/message-management/messages-and-transactions).
:::

Обмен между Jetton wallet и кошельками TON происходит через следующую последовательность сообщений:

<br></br>
<ThemedImage
alt=""
sources={{
light: '/img/docs/asset-processing/jetton_transfer.png?raw=true',
dark: '/img/docs/asset-processing/jetton_transfer_dark.png?raw=true',
}}
/> <br></br>

#### Сообщение 0

`Sender -> sender's jetton wallet`. Сообщение о *передаче* содержит следующие данные:

| Имя                    | Тип        | Описание                                                                                                                                                                                                                                                        |
| ---------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query_id`             | uint64     | Позволяет приложениям связывать три типа сообщений `Transfer`, `Transfer notification` и `Excesses` друг с другом. Для корректного выполнения этого процесса рекомендуется **всегда использовать уникальный query id запроса**. |
| `amount`               | coins      | Общая сумма `ton coin`, которая будет отправлена ​​с сообщением.                                                                                                                                                                                |
| `destination`          | address    | Адрес нового владельца жетона                                                                                                                                                                                                                                   |
| `response_destination` | address    | Адрес кошелька, используемый для возврата оставшихся ton coin с сообщением об излишках.                                                                                                                                                         |
| `custom_payload`       | maybe cell | Размер всегда >= 1 бит. Пользовательские данные (которые используются как отправителем, так и получателем jetton wallet для внутренней логики).                                                              |
| `forward_ton_amount`   | coins      | Должно быть > 0, если вы хотите отправить ` transfer notification` с `forward payload`. Это **часть значения `amount` и должно быть меньше чем `amount`**                                                                                       |
| `forward_payload`      | maybe cell | Размер всегда >= 1 бит. Если первые 32 бита = 0x0, это простое сообщение.                                                                                                                                                       |

#### Сообщение 2'

`payee's jetton wallet -> payee`. Сообщение с уведомлением о переводе. **Отправляется только если** `forward_ton_amount` **не равен нулю**. Содержит следующие данные:

| Имя               | Тип     |
| ----------------- | ------- |
| `query_id`        | uint64  |
| `amount`          | coins   |
| `sender`          | address |
| `forward_payload` | cell    |

Здесь адрес `sender` - это адрес `Jetton wallet` Алисы.

#### Сообщение 2''

`payee's jetton wallet -> Sender`. Тело сообщения. **Отправляется только в том случае, если после уплаты комиссий остались какие-либо монеты ton**. Содержит следующие данные:

| Имя        | Тип    |
| ---------- | ------ |
| `query_id` | uint64 |

:::tip Стандарт жетонов
Подробное описание полей контракта jetton wallet можно найти в интерфейсе описании `стандарта жетона` [TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md).
:::

## Как отправлять переводы жетонов с комментариями и уведомлениями

Для отправки транзакции требуется определенное количество ton coins для оплаты **комиссии** и **сообщения об уведомлении**.

Чтобы отправить **комментарий**, вам нужно настроить `forward payload`. Установите **первые 32 бита на 0x0** и добавьте **свой текст**, `forward payload` отправляется во внутреннем сообщении `jetton notify 0x7362d09c`. Оно будет сгенерировано только в том случае, если `forward_ton_amount` > 0.
:::info
Рекомендуемое `forward_ton_amount` для перевода жетонов с комментарием составляет 1 nanoton.
:::

В конце концов, чтобы получить `Excess 0xd53276db` сообщение, необходимо настроить `response destination`.

Иногда при отправке жетонов может возникнуть ошибка `709`. Эта ошибка указывает на то, что количество Toncoin, прикрепленное к сообщению, недостаточно для его отправки. Убедитесь, что `Toncoin > to_nano(TRANSFER_CONSUMPTION) + forward_ton_amount`, что обычно >0,04, если только forward payload не очень большая. Комиссия зависит от различных факторов, включая детали Jetton code и необходимость развертывания нового Jetton wallet для получателя.
Рекомендуется добавить к сообщению запас Toncoin и указать свой адрес в качестве `response_destination` для извлечения сообщения `Excess 0xd53276db`. Например, вы можете добавить 0,05 TON к сообщению, установив `forward_ton_amount` в размере 1 nanoton (это количество TON будет прикреплено к сообщению `jetton notify` 0x7362d09c).

Вы также можете столкнуться с ошибкой [`cskip_no_gas`](/v3/documentation/tvm/tvm-overview#compute-phase-skipped), которая указывает на то, что жетоны были успешно переведены, но никаких других вычислений не было выполнено. Это распространенная ситуация, когда значение `forward_ton_amount` равно 1 nanoton.

:::tip
Проверьте [лучшие практики](/v3/guidelines/dapps/asset-processing/jettons#best-practices) на примере *"отправки жетонов с комментариями"*.
:::

## Обработка жетонов off-chain

:::info Подтверждение транзакции
Транзакции TON необратимы после одного подтверждения. Для лучшего пользовательского опыта рекомендуется избегать ожидания дополнительных блоков после завершения транзакций в блокчейне TON. Подробнее читайте в [Catchain.pdf](https://docs.ton.org/catchain.pdf#page=3).
:::

Есть два способа получить жетоны:

- в **централизованном горячем кошельке**.
- используя кошелек с **отдельным адресом** для **каждого отдельного пользователя**.

В целях безопасности предпочтительнее иметь **отдельные горячие кошельки** для **отдельных жетонов** (несколько кошельков для каждого типа актива).

При обработке средств также рекомендуется иметь холодный кошелек для хранения избыточных средств, которые не участвуют в процессах автоматического депозита и вывода.

### Добавление новых жетонов для обработки активов и первичной проверки

1. Найдите правильный адрес [смарт-контракта](/v3/guidelines/dapps/asset-processing/jettons#jetton-master-smart-contract).
2. Получите [метаданные](/v3/guidelines/dapps/asset-processing/jettons#retrieving-jetton-data).
3. Проверьте на [мошенничество](/v3/guidelines/dapps/asset-processing/jettons#jetton-master-smart-contract).

### Идентификация неизвестного жетона при получении уведомления о переводе

Если в вашем кошельке получено уведомление о переводе неизвестного жетона, то ваш кошелек был создан для хранения определенного жетона.

Адрес отправителя внутреннего сообщения, содержащего тело `Transfer notification`, является адресом Jetton wallet. Его не следует путать с полем `sender` в [теле](/v3/guidelines/dapps/asset-processing/jettons#message-2) `Transfer notification`.

1. Получите адрес Jetton master для нового Jetton wallet, [получив данные кошелька](/v3/guidelines/dapps/asset-processing/jettons#retrieving-data-for-a-specific-jetton-wallet).
2. Получите адрес Jetton wallet для вашего адреса кошелька (как владельца), используя контракт Jetton master: [Как получить адрес Jetton wallet для данного пользователя](#retrieving-jetton-wallet-addresses-for-a-given-user)
3. Сравните адрес, возвращенный master контрактом, и фактический адрес токена кошелька.
  Если они совпадают, это идеальный вариант. Если нет, то вы, вероятно, получили мошеннический токен, который является поддельным.
4. Получите метаданные жетона: [Как получить метаданные жетона](#retrieving-jetton-data).
5. Проверьте поля `symbol` и `name` на наличие признаков мошенничества. При необходимости предупредите пользователя. [Добавление нового жетона для обработки и первичных проверок.](#adding-new-jettons-for-asset-processing-and-initial-verification).

### Прием жетонов от пользователей через централизованный кошелек

:::info
Чтобы предотвратить затор во входящих транзакциях на один кошелек, предлагается принимать депозиты через несколько кошельков и расширять количество этих кошельков по мере необходимости.
:::

:::caution Уведомление о транзакции
Ожидается, что каждый сервис в экосистеме установит `forward_ton_amount` на 0,000000001 TON (1 nanoton) при выводе жетона, чтобы отправить Jetton Notify при [успешном переводе](https://testnet.tonviewer.com/transaction/a0eede398d554318326b6e13081c2441f8b9a814bf9704e2e2f44f24adb3d407), в противном случае перевод не будет соответствовать стандарту и не сможет быть обработан другими CEX и сервисами.
:::

В этом сценарии платежный сервис создает уникальный идентификатор memo для каждого отправителя, раскрывая адрес централизованного кошелька и отправляемые суммы. Отправитель отправляет токены на указанный централизованный адрес с обязательным memo в комментарии.

**Преимущества этого метода:** Этот метод очень прост, поскольку при получении токенов не взимается никаких дополнительных комиссий, и они поступают непосредственно в горячий кошелек.

**Недостатки этого метода:** этот метод требует, чтобы все пользователи добавляли комментарий к переводу, что может привести к большему количеству ошибок при депозите (забытые memo, неправильные memo и т. д.), что означает большую нагрузку на службу поддержки.

Примеры с использованием Tonweb:

1. [Прием депозитов жетонов на отдельный горячий кошелек с комментариями (memo)](https://github.com/toncenter/examples/blob/main/deposits-jettons.js)
2. [Пример выводы жетонов](https://github.com/toncenter/examples/blob/main/withdrawals-jettons.js)

#### Подготовка

1. [Составьте список принимаемых жетонов](/v3/guidelines/dapps/asset-processing/jettons#adding-new-jettons-for-asset-processing-and-initial-verification) (адреса Jetton master).
2. Разверните горячий кошелек (используя v3R2, если не ожидается вывод жетонов; highload v3 - если ожидается вывод). [Разверните кошелек](/v3/guidelines/dapps/asset-processing/payments-processing#wallet-deployment).
3. Выполните тестовый перевод жетонов, используя адрес горячего кошелька для его инициализации.

#### Обработка входящих жетонов

1. Загрузите список принимаемых жетонов.
2. [Извлеките адрес Jetton wallet](#retrieving-jetton-wallet-addresses-for-a-given-user) для развернутого горячего кошелька.
3. Извлеките адрес Jetton master для каждого Jetton wallet, используя [полученные данные кошелька](/v3/guidelines/dapps/asset-processing/jettons#retrieving-data-for-a-specific-jetton-wallet).
4. Сравните адреса контракта Jetton master из шага 1 и шага 3 (непосредственно выше). Если адреса не совпадают, необходимо сообщить об ошибке проверки адреса жетона.
5. Извлеките список последних необработанных транзакций, с помощью учетной записи горячего кошелька и пройдитесь по нему (проверив каждую транзакцию отдельно). См:  [Проверка транзакций контракта](/v3/guidelines/dapps/asset-processing/payments-processing#check-contracts-transactions).
6. Проверьте входящее сообщение (in_msg) на предмет транзакций и извлеките исходный адрес из входящего сообщения. [Пример Tonweb](https://github.com/toncenter/examples/blob/9f20f7104411771793dfbbdf07f0ca4860f12de2/deposits-jettons-single-wallet.js#L84)
7. Если исходный адрес совпадает с адресом Jetton wallet, то необходимо продолжить обработку транзакции. Если нет, то пропустите обработку и проверьте следующую транзакцию.
8. Убедитесь, что тело сообщения не пусто и первые 32 бита сообщения совпадают с op code `transfer notification` `0x7362d09c`.
  [Пример с использованием Tonweb](https://github.com/toncenter/examples/blob/9f20f7104411771793dfbbdf07f0ca4860f12de2/deposits-jettons-single-wallet.js#L91).
  Если тело сообщения пустое или op code недействителен - пропустите транзакцию.
9. Прочитайте другие данные тела сообщения, включая `query_id`, `amount`, `sender`, `forward_payload`.
  [Макеты сообщений контрактов жетона](/v3/guidelines/dapps/asset-processing/jettons#message-layouts), [Пример с использованием Tonweb](https://github.com/toncenter/examples/blob/9f20f7104411771793dfbbdf07f0ca4860f12de2/deposits-jettons-single-wallet.js#L105)
10. Попытайтесь извлечь текстовые комментарии из данных `forward_payload`. Первые 32 бита должны совпадать с op code `0x000000`, а остальные - с текстом в UTF-8 кодировке.
  [Пример с использованием Tonweb](https://github.com/toncenter/examples/blob/9f20f7104411771793dfbbdf07f0ca4860f12de2/deposits-jettons-single-wallet.js#L110)
11. Если данные `forward_payload` пусты или op code недействителен - пропустите транзакцию.
12. Сравните полученный комментарий с сохраненными memo. Если есть совпадение (идентификация пользователя всегда возможна) - отправьте депозит.
13. Начните заново с шага 5 и повторяйте процесс, пока не пройдете весь список транзакций.

### Прием жетонов с адресов депозитов пользователей

Чтобы принимать жетоны с адресов депозитов пользователей, необходимо, чтобы платежный сервис создавал свой собственный индивидуальный адрес (депозит) для каждого участника, отправляющего средства. В этом случае требуется выполнение нескольких параллельных процессов, включая создание новых депозитов, сканирование блоков на наличие транзакций, вывод средств с депозитов на горячий кошелек и т. д.

Поскольку горячий кошелек может использовать один Jetton wallet для каждого типа жетона, необходимо создать несколько кошельков для инициирования депозитов. Чтобы создать большое количество кошельков, но при этом управлять ими с помощью одной seed-фразы (или закрытого ключа), необходимо указать другой `subwallet_id` при их создании. В TON поддерживается функциональность для создания субкошельков версий v3 и выше.

#### Создание субкошелька в Tonweb

```js
const WalletClass = tonweb.wallet.all['v3R2'];
const wallet = new WalletClass(tonweb.provider, {
    publicKey: keyPair.publicKey,
    wc: 0,
    walletId: <SUBWALLET_ID>,
});
```

#### Подготовка

1. [Подготовьте список принимаемых жетонов](#adding-new-jettons-for-asset-processing-and-initial-verification).
2. Разверните горячий кошелек (используя v3R2, если не ожидается вывод жетонов; highload v3 - если ожидается вывод жетонов). [Разверните кошелек](/v3/guidelines/dapps/asset-processing/payments-processing#wallet-deployment).

#### Создание депозитов

1. Примите запрос на создание нового депозита для пользователя.
2. Сгенерируйте новый адрес субкошелька (/v3R2) на основе seed-фразы горячего кошелька. [Создание субкошелька в Tonweb](#creating-a-subwallet-in-tonweb)
3. Принимающий адрес может быть предоставлен пользователю как адрес, используемый для депозитов жетонов (это адрес владельца депозитного Jetton wallet). Инициализация кошелька не требуется, это можно сделать при выводе жетонов из депозита.
4. Для этого адреса необходимо рассчитать адрес кошелька Jetton через контракт Jetton master.
  [Как получить адрес Jetton wallet для определенного пользователя](#retrieving-jetton-wallet-addresses-for-a-given-user).
5. Добавьте адрес Jetton wallet в пул адресов для отслеживания транзакций и сохраните адрес субкошелька.

#### Обработка транзакций

:::info Подтверждение транзакции
Транзакции TON необратимы после одного подтверждения. Для лучшего пользовательского опыта рекомендуется избегать ожидания дополнительных блоков после завершения транзакций в блокчейне TON. Подробнее читайте в [Catchain.pdf](https://docs.ton.org/catchain.pdf#page=3).
:::

Не всегда возможно определить точное количество жетонов, полученных из сообщения, поскольку Jetton wallet не может отправлять сообщения `transfer notification`, `excesses` и `internal transfer`. Они не стандартизированы. Это означает, что нет гарантии, что `internal transfer` можно будет декодировать.

Поэтому для определения суммы, полученной в кошельке, необходимо запросить балансы с помощью get метода. Для получения ключевых данных при запросе балансов, блоки используются в соответствии с состоянием учетной записи для конкретного on-chain блока. [Подготовка к принятию блока с помощью Tonweb](https://github.com/toncenter/tonweb/blob/master/src/test-block-subscribe.js).

Этот процесс выполняется следующим образом:

1. Подготовьте прием блока (путем подготовки системы к принятию новых блоков).
2. Получите новый блок и сохраните ID предыдущего блока.
3. Получите транзакции из блоков.
4. Отфильтруйте транзакции, используемые только с адресами из пула депозитного Jetton wallet.
5. Декодируйте сообщения, используя тело `transfer notification`для получения более подробных данных, включая адрес `sender`, `amount` жетонов и комментарий. (См.: [Обработка входящих жетонов](#processing-incoming-jettons))
6. Если есть хотя бы одна транзакция с недекодируемыми исходящими сообщениями (тело сообщения не содержит op code для `transfer notification` и op code для `excesses`) или без исходящих сообщений в учетной записи, то баланс жетонов должен быть запрошен с использованием get метода для текущего блока, в то время как предыдущий блок используется для расчета разницы в балансах. Теперь полный баланс депозита изменяется из-за транзакций, проведенных в рамках блока.
7. В качестве идентификатора для неопознанного перевода жетонов (без уведомления о переводе) могут использоваться данные транзакции, если присутствует одна такая транзакция или данные блока (если в блоке их присутствует несколько).
8. Теперь необходимо проверить баланс депозита, чтобы убедиться, что он правильный. Если баланс депозита достаточен для инициирования перевода между горячим кошельком и существующем Jetton wallet, жетоны нужно вывести, чтобы гарантировать, что баланс кошелька уменьшился.
9. Перезапустите с шага 2 и повторите весь процесс.

#### Вывод средств с депозитов

Переводы с депозита на горячий кошелек не следует делать с каждым пополнением депозита, поскольку за операцию перевода взимается комиссия в TON (оплачивается в виде сетевых сборов за газ). Важно определить ограниченную минимальную сумму жетонов, которое требуется для того, чтобы перевод (и, следовательно, депозит) был выгодным.

По умолчанию владельцы депозитных Jetton wallet не инициализируются. Это связано с тем, что нет  предварительно установленного требования к оплате комиссии за хранение. Депозитные Jetton wallet могут быть развернуты при `transfer` сообщений с телом перевода, которое затем может быть немедленно уничтожено. Для этого инженер должен использовать специальный механизм отправки сообщений: [128 + 32](/v3/documentation/smart-contracts/message-management/sending-messages#message-modes).

1. Получите список депозитов, отмеченных для вывода на горячий кошелек
2. Получите сохраненные адреса владельцев для каждого депозита
3. Затем отправьте сообщения на каждый адрес владельца (путем объединения нескольких таких сообщений в пакет) из highload кошелька с прикрепленной суммой TON Jetton. Это определяется путем сложения комиссий, используемых для инициализации кошелька v3R2 + комиссий за отправку сообщения с телом  `transfer` + произвольной суммы TON, связанной с `forward_ton_amount` (если необходимо). Присоединенная сумма TON определяется путем сложения комиссий за инициализацию кошелька v3R2 (значение) + комиссий за отправку сообщения с телом `transfer` (значение) + произвольной суммы TON для `forward_ton_amount` (значение) (если необходимо).
4. Когда баланс на адресе станет ненулевым, статус аккаунта изменится. Подождите несколько секунд и проверьте статус аккаунта, он вскоре изменится с состояния `nonexists` на `uninit`.
5. Для каждого адреса владельца (со статусом `uninit`) необходимо отправить внешнее сообщение с v3R2 кошелька  init и body с сообщением `transfer` для зачисления в Jetton wallet = 128 + 32. Для `transfer` пользователь должен указать адрес горячего кошелька в качестве `destination` и `response destination`. Можно добавить текстовый комментарий, чтобы упростить идентификацию перевода.
6. Проверьте доставку жетонов, используя адрес депозита на адрес горячего кошелька, учитывая [обработку входящей информации о жетонах, которая представлена здесь](#processing-incoming-jettons).

### Вывод жетонов

:::info Важно

Ниже вы найдете пошаговое руководство по обработке вывода жетонов
:::

Для вывода жетонов кошелек отправляет сообщения с телом `transfer` на соответствующий Jetton wallet. Затем Jetton wallet отправляет жетоны получателю. Важно прикрепить некоторое количество TON (минимум 1 nanoTON) в качестве `forward_ton_amount` (и необязательный комментарий к `forward_payload`), чтобы вызвать `transfer notification`. См.: [Макеты сообщений контрактов жетонов](/v3/guidelines/dapps/asset-processing/jettons#message-layouts)

#### Подготовка

1. Подготовьте список жетонов для вывода: [Добавление новых жетонов для обработки и первичной проверки](#adding-new-jettons-for-asset-processing-and-initial-verification)
2. Инициируйте развертывание горячего кошелька. Рекомендуется использовать Highload v3. [Развертывание кошелька](/v3/guidelines/dapps/asset-processing/payments-processing#wallet-deployment)
3. Выполните перевод жетонов с использованием адреса горячего кошелька, чтобы инициализировать Jetton wallet и пополнить его баланс.

#### Обработка вывода средств

1. Загрузите список обработанных жетонов
2. Получите адреса Jetton wallet для развернутого горячего кошелька: [Как извлечь адреса Jetton wallet для заданного пользователя](#retrieving-jetton-wallet-addresses-for-a-given-user)
3. Получите адреса Jetton master для каждого Jetton wallet: [Как получить данные для Jetton wallet](#retrieving-data-for-a-specific-jetton-wallet).
  Требуется параметр `jetton` (который на самом деле является адресом контракта Jetton master).
4. Сравните адреса из контракта Jetton master из шага 1 и шага 3. Если адреса не совпадают, следует сообщить об ошибке проверки адреса жетона.
5. Получите запрос на вывод, в которых фактически указывается тип жетона, переводимая сумма и адрес кошелька получателя.
6. Проверьте баланс Jetton wallet, чтобы убедиться, что есть достаточно средств для выполнения вывода.
7. Создайте [сообщение](/v3/guidelines/dapps/asset-processing/jettons#message-0).
8. При использовании highload кошелька рекомендуется собирать пакет сообщений и отправлять по одному пакету за раз для оптимизации комиссий.
9. Сохраните время истечения срока для исходящих внешних сообщений (это время, пока кошелек успешно не обработает сообщение, после этого кошелек больше не будет принимать сообщение)
10. Отправьте одно сообщение или несколько сообщений (пакет сообщений).
11. Получите список последних необработанных транзакций в учетной записи горячего кошелька и выполните его итерацию. Узнайте больше здесь: [Проверка транзакций контракта](/v3/guidelines/dapps/asset-processing/payments-processing#check-contracts-transactions), [Пример Tonweb](https://github.com/toncenter/examples/blob/9f20f7104411771793dfbbdf07f0ca4860f12de2/deposits-single-wallet.js#L43) или используйте метод Toncenter API `/getTransactions`.
12. Просмотрите исходящие сообщения в аккаунте.
13. Если существует сообщение с op code `transfer`, то его следует декодировать для получения значения `query_id`. Полученные `query_id` необходимо пометить как успешно отправленные.
14. Если время, необходимое для обработки текущей сканированной транзакции, превышает время истечения срока действия, а исходящее сообщение с заданным `query_id` не найдено, то запрос следует (это необязательно) пометить как просроченный и безопасно отправить повторно.
15. Просмотрите входящие сообщения в аккаунте.
16. Если существует сообщение, которое использует op code `Excess 0xd53276db`, сообщение должно быть декодировано, а значение `query_id` должно быть извлечено. Найденный `query_id` должен быть помечен как успешно доставленный.
17. Перейдите к шагу 5. Просроченные запросы, которые не были успешно отправлены, должны быть возвращены в список вывода.

## Обработка жетонов on-chain

Обычно для приема и обработки жетонов обработчик сообщений, отвечающий за внутренние сообщения, использует op code `op=0x7362d09c`.

:::info Подтверждение транзакции
Транзакции TON необратимы после всего лишь одного подтверждения. Для лучшего пользовательского опыта рекомендуется избегать ожидания дополнительных блоков после завершения транзакций в блокчейне TON. Подробнее в [Catchain.pdf](https://docs.ton.org/catchain.pdf#page=3).
:::

### Рекомендации по обработке on-chain

Ниже приведен `список рекомендаций`, которые **необходимо учитывать при обработке жетонов on-chain**:

1. **Идентифицируйте входящие жетоны** по типу их кошелька, а не по их контракту Jetton master. Другими словами, ваш контракт должен взаимодействовать (получать и отправлять сообщения) с конкретным jetton wallet (не с каким-то незнакомым кошельком, использующим определенный Jetton master).
2. При связывании Jetton Wallet и контракта Jetton Master **проверьте**, что это **соединение является двунаправленным**, когда кошелек распознает master контракт и наоборот. Например, если ваша система контрактов получает уведомление от jetton wallet (который считает свой MySuperJetton своим master контрактом), его информация о переводе должна быть отображена пользователю, прежде чем показывать `symbol`, `name` и `image` контракта MySuperJetton, проверьте, что кошелек MySuperJetton использует правильную систему контрактов. В свою очередь, если вашей системе контрактов по какой-то причине необходимо отправлять жетоны с использованием MySuperJetton или контракта MySuperJetton master, проверьте, что кошелек X, как и кошелек, использует те же параметры контракта. Кроме того, перед отправкой запроса `transfer` в X убедитесь, что он распознает MySuperJetton как master.
3. Истинная сила децентрализованных финансов (DeFi) основана на возможности накладывать протоколы друг на друга, как блоки Lego. Например, скажем, жетон A обменивается на жетон B, который, в свою очередь, затем используется в качестве кредитного плеча в протоколе кредитования (когда пользователь предоставляет ликвидность), который используется для покупки NFT ... и так далее. Поэтому подумайте, как контракт может обслуживать не только пользователей off-chain, но и субъектов on-chain, прикрепляя токенизированное значение к уведомлению о переводе, добавляя custom payload, которую можно отправить с уведомлением о переводе.
4. **Помните**, что не все контракты следуют одним и тем же стандартам. К сожалению, некоторые жетоны могут быть враждебными (использующими векторы атак) и созданы исключительно для атак на ничего не подозревающих пользователей. В целях безопасности, если рассматриваемый протокол состоит из множества контрактов, не создавайте большое количество jetton wallet одного типа. В частности, не отправляйте жетоны внутри протокола между контрактом депозита, контрактом хранилища или контрактом аккаунта пользователя и т. д. Злоумышленники могут намеренно вмешиваться в логику контракта, подделывая уведомления о переводе, суммы жетонов или параметры payload. Уменьшите потенциальный потенциал атаки, используя только один кошелек в системе на жетон (для всех депозитов и снятий).
5. Также часто *бывает хорошей идеей* создать субконтракты для каждого индивидуального жетона, чтобы снизить вероятность подмены адреса (например, когда сообщение о переводе отправляется на жетон B с использованием контракта, предназначенного для жетона A).
6. **Настоятельно рекомендуется** работать с неделимыми единицами жетонов на уровне контракта. Логика с плавающей запятой обычно используется для улучшения пользовательского интерфейса (UI), и это не связано с численным учетом on-chain.

Чтобы узнать больше о [безопасном программировании смарт-контрактов в FunC от CertiK](https://blog.ton.org/secure-smart-contract-programming-in-func), не стесняйтесь читать этот ресурс. Разработчикам рекомендуется **обрабатывать все исключения смарт-контрактов**, чтобы они никогда не пропускались во время разработки приложений.

## Рекомендации по обработке Jetton wallet

Как правило, все процедуры проверки, используемые для обработки жетонов off-chain, подходят и для кошельков. Для обработки Jetton wallet наши самые важные рекомендации следующие:

1. Когда кошелек получает уведомление о переводе от неизвестного jetton wallet, **жизненно важно** доверять jetton wallet и его master адресу, поскольку это может быть вредоносная подделка. Чтобы защитить себя, проверьте Jetton Master (главный контракт), используя предоставленный им адрес, чтобы убедиться, что ваши процессы проверки распознают jetton wallet как легитимный. После того, как вы доверяете кошельку и он будет проверен как легитимный, вы можете разрешить ему доступ к остаткам на вашем аккаунте и другим данным в кошельке. Если Jetton Master не распознает этот кошелек, рекомендуется вообще не инициировать и не раскрывать ваши переводы жетонов и показывать только входящие переводы TON (Toncoin, прикрепленные к уведомлениям о переводах).
2. На практике, если пользователь хочет взаимодействовать с жетоном, а не с jetton wallet. Другими словами, пользователи отправляют wTON/oUSDT/jUSDT, jUSDC, jDAI вместо EQAjN.../EQBLE... и т. д. Часто это означает, что когда пользователь инициирует перевод жетонов, кошелек спрашивает у соответствующего jetton master, какой jetton wallet (принадлежащий пользователю) должен инициировать запрос на перевод. Важно **никогда не доверять слепо этим данным** от Master (главного контракта) контракта. Перед отправкой запроса на перевод в jetton wallet всегда проверяйте, действительно ли jetton wallet принадлежит Jetton Master, которому он, как он утверждает, принадлежит.
3. **Помните**, что недружественные Jetton Masters/jetton wallets **могут со временем менять** свои wallets/Masters. Поэтому крайне важно, чтобы пользователи проявляли должную осмотрительность и проверяли легитимность любых кошельков, с которыми они взаимодействуют, перед каждым использованием.
4. **Всегда проверяйте**, что вы отображаете жетоны в своем интерфейсе таким образом, чтобы **они не смешивались с переводами TON**, системными уведомлениями и т. д. Даже параметры `symbol`,`name` и `image` могут быть созданы, чтобы вводить пользователей в заблуждение, делая пострадавших потенциальными жертвами мошенничества. Было несколько случаев, когда вредоносные жетоны использовались для имитации переводов TON, ошибок уведомлений, вознаграждений или объявлений о заморозке активов.
5. **Всегда будьте начеку в отношении потенциальных злоумышленников**, которые создают поддельные жетоны, хорошей идеей будет предоставить пользователям функциональные возможности, необходимые для исключения нежелательных жетонов в их основном пользовательском интерфейсе.

Авторы: [kosrk](https://github.com/kosrk), [krigga](https://github.com/krigga), [EmelyanenkoK](https://github.com/EmelyanenkoK/) и [tolya-yanot](https://github.com/tolya-yanot/).

## Лучшие практики

Если вы хотите готовые тестовые примеры, проверьте [SDKs](/v3/guidelines/dapps/asset-processing/jettons#sdks) и попробуйте их запустить. Ниже приведены фрагменты кода, которые помогут вам понять обработку жетонов с помощью примеров кода.

### Отправить жетоны с комментарием

<Tabs groupId="code-examples">
<TabItem value="tonweb" label="JS (tonweb)">

<details>
<summary>
Исходный код
</summary>

```js
// first 4 bytes are tag of text comment
const comment = new Uint8Array([... new Uint8Array(4), ... new TextEncoder().encode('text comment')]);

await wallet.methods.transfer({
  secretKey: keyPair.secretKey,
  toAddress: JETTON_WALLET_ADDRESS, // address of Jetton wallet of Jetton sender
  amount: TonWeb.utils.toNano('0.05'), // total amount of TONs attached to the transfer message
  seqno: seqno,
  payload: await jettonWallet.createTransferBody({
    jettonAmount: TonWeb.utils.toNano('500'), // Jetton amount (in basic indivisible units)
    toAddress: new TonWeb.utils.Address(WALLET2_ADDRESS), // recepient user's wallet address (not Jetton wallet)
    forwardAmount: TonWeb.utils.toNano('0.01'), // some amount of TONs to invoke Transfer notification message
    forwardPayload: comment, // text comment for Transfer notification message
    responseAddress: walletAddress // return the TONs after deducting commissions back to the sender's wallet address
  }),
  sendMode: 3,
}).send()
```

</details>

</TabItem>
<TabItem value="tonutils-go" label="Golang">

<details>
<summary>
Исходный код
</summary>

```go
client := liteclient.NewConnectionPool()

// connect to testnet lite server
err := client.AddConnectionsFromConfigUrl(context.Background(), "https://ton.org/global.config.json")
if err != nil {
   panic(err)
}

ctx := client.StickyContext(context.Background())

// initialize ton api lite connection wrapper
api := ton.NewAPIClient(client)

// seed words of account, you can generate them with any wallet or using wallet.NewSeed() method
words := strings.Split("birth pattern then forest walnut then phrase walnut fan pumpkin pattern then cluster blossom verify then forest velvet pond fiction pattern collect then then", " ")

w, err := wallet.FromSeed(api, words, wallet.V3R2)
if err != nil {
   log.Fatalln("FromSeed err:", err.Error())
   return
}

token := jetton.NewJettonMasterClient(api, address.MustParseAddr("EQD0vdSA_NedR9uvbgN9EikRX-suesDxGeFg69XQMavfLqIw"))

// find our jetton wallet
tokenWallet, err := token.GetJettonWallet(ctx, w.WalletAddress())
if err != nil {
   log.Fatal(err)
}

amountTokens := tlb.MustFromDecimal("0.1", 9)

comment, err := wallet.CreateCommentCell("Hello from tonutils-go!")
if err != nil {
   log.Fatal(err)
}

// address of receiver's wallet (not token wallet, just usual)
to := address.MustParseAddr("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N")
transferPayload, err := tokenWallet.BuildTransferPayload(to, amountTokens, tlb.ZeroCoins, comment)
if err != nil {
   log.Fatal(err)
}

// your TON balance must be > 0.05 to send
msg := wallet.SimpleMessage(tokenWallet.Address(), tlb.MustFromTON("0.05"), transferPayload)

log.Println("sending transaction...")
tx, _, err := w.SendWaitTransaction(ctx, msg)
if err != nil {
   panic(err)
}
log.Println("transaction confirmed, hash:", base64.StdEncoding.EncodeToString(tx.Hash))
```

</details>

</TabItem>
<TabItem value="TonTools" label="Python">

<details>
<summary>
Исходный код
</summary>

```py
my_wallet = Wallet(provider=client, mnemonics=my_wallet_mnemonics, version='v4r2')

# for TonCenterClient and LsClient
await my_wallet.transfer_jetton(destination_address='address', jetton_master_address=jetton.address, jettons_amount=1000, fee=0.15) 

# for all clients
await my_wallet.transfer_jetton_by_jetton_wallet(destination_address='address', jetton_wallet='your jetton wallet address', jettons_amount=1000, fee=0.1)  
```

</details>

</TabItem>

<TabItem value="pytoniq" label="Python">

<details>
<summary>
Исходный код
</summary>

```py
from pytoniq import LiteBalancer, WalletV4R2, begin_cell
import asyncio

mnemonics = ["your", "mnemonics", "here"]

async def main():
    provider = LiteBalancer.from_mainnet_config(1)
    await provider.start_up()

    wallet = await WalletV4R2.from_mnemonic(provider=provider, mnemonics=mnemonics)
    USER_ADDRESS = wallet.address
    JETTON_MASTER_ADDRESS = "EQBlqsm144Dq6SjbPI4jjZvA1hqTIP3CvHovbIfW_t-SCALE"
    DESTINATION_ADDRESS = "EQAsl59qOy9C2XL5452lGbHU9bI3l4lhRaopeNZ82NRK8nlA"

    USER_JETTON_WALLET = (await provider.run_get_method(address=JETTON_MASTER_ADDRESS,
                                                        method="get_wallet_address",
                                                        stack=[begin_cell().store_address(USER_ADDRESS).end_cell().begin_parse()]))[0].load_address()
    forward_payload = (begin_cell()
                      .store_uint(0, 32) # TextComment op-code
                      .store_snake_string("Comment")
                      .end_cell())
    transfer_cell = (begin_cell()
                    .store_uint(0xf8a7ea5, 32)          # Jetton Transfer op-code
                    .store_uint(0, 64)                  # query_id
                    .store_coins(1 * 10**9)             # Jetton amount to transfer in nanojetton
                    .store_address(DESTINATION_ADDRESS) # Destination address
                    .store_address(USER_ADDRESS)        # Response address
                    .store_bit(0)                       # Custom payload is None
                    .store_coins(1)                     # Ton forward amount in nanoton
                    .store_bit(1)                       # Store forward_payload as a reference
                    .store_ref(forward_payload)         # Forward payload
                    .end_cell())

    await wallet.transfer(destination=USER_JETTON_WALLET, amount=int(0.05*1e9), body=transfer_cell)
    await provider.close_all()

asyncio.run(main())
```

</details>

</TabItem>
</Tabs>

### Принять Jetton Transfer с разбором комментариев

<Tabs groupId="parse-code-examples">
<TabItem value="tonweb" label="JS (tonweb)">

<details>
<summary>
Исходный код
</summary>

```ts
import {
    Address,
    TonClient,
    Cell,
    beginCell,
    storeMessage,
    JettonMaster,
    OpenedContract,
    JettonWallet,
    Transaction
} from '@ton/ton';


export async function retry<T>(fn: () => Promise<T>, options: { retries: number, delay: number }): Promise<T> {
    let lastError: Error | undefined;
    for (let i = 0; i < options.retries; i++) {
        try {
            return await fn();
        } catch (e) {
            if (e instanceof Error) {
                lastError = e;
            }
            await new Promise(resolve => setTimeout(resolve, options.delay));
        }
    }
    throw lastError;
}

export async function tryProcessJetton(orderId: string) : Promise<string> {

    const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'TONCENTER-API-KEY', // https://t.me/tonapibot
    });

    interface JettonInfo {
        address: string;
        decimals: number;
    }

    interface Jettons {
        jettonMinter : OpenedContract<JettonMaster>,
        jettonWalletAddress: Address,
        jettonWallet: OpenedContract<JettonWallet>
    }

    const MY_WALLET_ADDRESS = 'INSERT-YOUR-HOT-WALLET-ADDRESS'; // your HOT wallet

    const JETTONS_INFO : Record<string, JettonInfo> = {
        'jUSDC': {
            address: 'EQB-MPwrd1G6WKNkLz_VnV6WqBDd142KMQv-g1O-8QUA3728', //
            decimals: 6
        },
        'jUSDT': {
            address: 'EQBynBO23ywHy_CgarY9NK9FTz0yDsG82PtcbSTQgGoXwiuA',
            decimals: 6
        },
    }
    const jettons: Record<string, Jettons> = {};

    const prepare = async () => {
        for (const name in JETTONS_INFO) {
            const info = JETTONS_INFO[name];
            const jettonMaster = client.open(JettonMaster.create(Address.parse(info.address)));
            const userAddress = Address.parse(MY_WALLET_ADDRESS);

            const jettonUserAddress =  await jettonMaster.getWalletAddress(userAddress);
          
            console.log('My jetton wallet for ' + name + ' is ' + jettonUserAddress.toString());

            const jettonWallet = client.open(JettonWallet.create(jettonUserAddress));

            //const jettonData = await jettonWallet;
            const jettonData = await client.runMethod(jettonUserAddress, "get_wallet_data")

            jettonData.stack.pop(); //skip balance
            jettonData.stack.pop(); //skip owneer address
            const adminAddress = jettonData.stack.readAddress();


            if (adminAddress.toString() !== (Address.parse(info.address)).toString()) {
                throw new Error('jetton minter address from jetton wallet doesnt match config');
            }

            jettons[name] = {
                jettonMinter: jettonMaster,
                jettonWalletAddress: jettonUserAddress,
                jettonWallet: jettonWallet
            };
        }
    }

    const jettonWalletAddressToJettonName = (jettonWalletAddress : Address) => {
        const jettonWalletAddressString = jettonWalletAddress.toString();
        for (const name in jettons) {
            const jetton = jettons[name];

            if (jetton.jettonWallet.address.toString() === jettonWalletAddressString) {
                return name;
            }
        }
        return null;
    }

    // Subscribe
    const Subscription = async ():Promise<Transaction[]> =>{

      const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'TONCENTER-API-KEY', // https://t.me/tonapibot
      });

        const myAddress = Address.parse('INSERT-YOUR-HOT-WALLET'); // Address of receiver TON wallet
        const transactions = await client.getTransactions(myAddress, {
            limit: 5,
        });
        return transactions;
    }

    return retry(async () => {

        await prepare();
        const Transactions = await Subscription();

        for (const tx of Transactions) {

            const sourceAddress = tx.inMessage?.info.src;
            if (!sourceAddress) {
                // external message - not related to jettons
                continue;
            }

            if (!(sourceAddress instanceof Address)) {
                continue;
            }

            const in_msg = tx.inMessage;

            if (in_msg?.info.type !== 'internal') {
                // external message - not related to jettons
                continue;
            }

            // jetton master contract address check
            const jettonName = jettonWalletAddressToJettonName(sourceAddress);
            if (!jettonName) {
                // unknown or fake jetton transfer
                continue;
            }

            if (tx.inMessage === undefined || tx.inMessage?.body.hash().equals(new Cell().hash())) {
                // no in_msg or in_msg body
                continue;
            }

            const msgBody = tx.inMessage;
            const sender = tx.inMessage?.info.src;
            const originalBody = tx.inMessage?.body.beginParse();
            let body = originalBody?.clone();
            const op = body?.loadUint(32);
            if (!(op == 0x7362d09c)) {
                continue; // op != transfer_notification
            }

            console.log('op code check passed', tx.hash().toString('hex'));

            const queryId = body?.loadUint(64);
            const amount = body?.loadCoins();
            const from = body?.loadAddress();
            const maybeRef = body?.loadBit();
            const payload = maybeRef ? body?.loadRef().beginParse() : body;
            const payloadOp = payload?.loadUint(32);
            if (!(payloadOp == 0)) {
                console.log('no text comment in transfer_notification');
                continue;
            }

            const comment = payload?.loadStringTail();
            if (!(comment == orderId)) {
                continue;
            }
            
            console.log('Got ' + jettonName + ' jetton deposit ' + amount?.toString() + ' units with text comment "' + comment + '"');
            const txHash = tx.hash().toString('hex');
            return (txHash);
        }
        throw new Error('Transaction not found');
    }, {retries: 30, delay: 1000});
}
```

</details>

</TabItem>
<TabItem value="tonutils-go" label="Golang">

<details>
<summary>
Исходный код
</summary>

```go
import (
	"context"
	"fmt"
	"log"

	"github.com/xssnick/tonutils-go/address"
	"github.com/xssnick/tonutils-go/liteclient"
	"github.com/xssnick/tonutils-go/tlb"
	"github.com/xssnick/tonutils-go/ton"
	"github.com/xssnick/tonutils-go/ton/jetton"
	"github.com/xssnick/tonutils-go/tvm/cell"
)

const (
	MainnetConfig   = "https://ton.org/global.config.json"
	TestnetConfig   = "https://ton.org/global.config.json"
	MyWalletAddress = "INSERT-YOUR-HOT-WALLET-ADDRESS"
)

type JettonInfo struct {
	address  string
	decimals int
}

type Jettons struct {
	jettonMinter        *jetton.Client
	jettonWalletAddress string